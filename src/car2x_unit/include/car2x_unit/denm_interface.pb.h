// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: denm_interface.proto

#ifndef PROTOBUF_INCLUDED_denm_5finterface_2eproto
#define PROTOBUF_INCLUDED_denm_5finterface_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "itspduheader_interface.pb.h"  // IWYU pragma: export
#include "etsi_its_cdd.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_denm_5finterface_2eproto 

namespace protobuf_denm_5finterface_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_denm_5finterface_2eproto
class AlacarteContainer;
class AlacarteContainerDefaultTypeInternal;
extern AlacarteContainerDefaultTypeInternal _AlacarteContainer_default_instance_;
class DENMessage;
class DENMessageDefaultTypeInternal;
extern DENMessageDefaultTypeInternal _DENMessage_default_instance_;
class DecentralizedEnvironmentalNotificationMessage;
class DecentralizedEnvironmentalNotificationMessageDefaultTypeInternal;
extern DecentralizedEnvironmentalNotificationMessageDefaultTypeInternal _DecentralizedEnvironmentalNotificationMessage_default_instance_;
class ImpactReductionContainer;
class ImpactReductionContainerDefaultTypeInternal;
extern ImpactReductionContainerDefaultTypeInternal _ImpactReductionContainer_default_instance_;
class LocationContainer;
class LocationContainerDefaultTypeInternal;
extern LocationContainerDefaultTypeInternal _LocationContainer_default_instance_;
class ManagementContainer;
class ManagementContainerDefaultTypeInternal;
extern ManagementContainerDefaultTypeInternal _ManagementContainer_default_instance_;
class RoadWorksContainerExtended;
class RoadWorksContainerExtendedDefaultTypeInternal;
extern RoadWorksContainerExtendedDefaultTypeInternal _RoadWorksContainerExtended_default_instance_;
class SituationContainer;
class SituationContainerDefaultTypeInternal;
extern SituationContainerDefaultTypeInternal _SituationContainer_default_instance_;
class StationaryVehicleContainer;
class StationaryVehicleContainerDefaultTypeInternal;
extern StationaryVehicleContainerDefaultTypeInternal _StationaryVehicleContainer_default_instance_;
namespace google {
namespace protobuf {
template<> ::AlacarteContainer* Arena::CreateMaybeMessage<::AlacarteContainer>(Arena*);
template<> ::DENMessage* Arena::CreateMaybeMessage<::DENMessage>(Arena*);
template<> ::DecentralizedEnvironmentalNotificationMessage* Arena::CreateMaybeMessage<::DecentralizedEnvironmentalNotificationMessage>(Arena*);
template<> ::ImpactReductionContainer* Arena::CreateMaybeMessage<::ImpactReductionContainer>(Arena*);
template<> ::LocationContainer* Arena::CreateMaybeMessage<::LocationContainer>(Arena*);
template<> ::ManagementContainer* Arena::CreateMaybeMessage<::ManagementContainer>(Arena*);
template<> ::RoadWorksContainerExtended* Arena::CreateMaybeMessage<::RoadWorksContainerExtended>(Arena*);
template<> ::SituationContainer* Arena::CreateMaybeMessage<::SituationContainer>(Arena*);
template<> ::StationaryVehicleContainer* Arena::CreateMaybeMessage<::StationaryVehicleContainer>(Arena*);
}  // namespace protobuf
}  // namespace google

enum Termination {
  TRMNTN_IS_CANCELLATION = 0,
  TRMNTN_IS_NEGATION = 1
};
bool Termination_IsValid(int value);
const Termination Termination_MIN = TRMNTN_IS_CANCELLATION;
const Termination Termination_MAX = TRMNTN_IS_NEGATION;
const int Termination_ARRAYSIZE = Termination_MAX + 1;

const ::google::protobuf::EnumDescriptor* Termination_descriptor();
inline const ::std::string& Termination_Name(Termination value) {
  return ::google::protobuf::internal::NameOfEnum(
    Termination_descriptor(), value);
}
inline bool Termination_Parse(
    const ::std::string& name, Termination* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Termination>(
    Termination_descriptor(), name, value);
}
// ===================================================================

class DENMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DENMessage) */ {
 public:
  DENMessage();
  virtual ~DENMessage();

  DENMessage(const DENMessage& from);

  inline DENMessage& operator=(const DENMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DENMessage(DENMessage&& from) noexcept
    : DENMessage() {
    *this = ::std::move(from);
  }

  inline DENMessage& operator=(DENMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DENMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DENMessage* internal_default_instance() {
    return reinterpret_cast<const DENMessage*>(
               &_DENMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DENMessage* other);
  friend void swap(DENMessage& a, DENMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DENMessage* New() const final {
    return CreateMaybeMessage<DENMessage>(NULL);
  }

  DENMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DENMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DENMessage& from);
  void MergeFrom(const DENMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DENMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ItsPduHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::ItsPduHeader& _internal_header() const;
  public:
  const ::ItsPduHeader& header() const;
  ::ItsPduHeader* release_header();
  ::ItsPduHeader* mutable_header();
  void set_allocated_header(::ItsPduHeader* header);

  // required .DecentralizedEnvironmentalNotificationMessage denm = 2;
  bool has_denm() const;
  void clear_denm();
  static const int kDenmFieldNumber = 2;
  private:
  const ::DecentralizedEnvironmentalNotificationMessage& _internal_denm() const;
  public:
  const ::DecentralizedEnvironmentalNotificationMessage& denm() const;
  ::DecentralizedEnvironmentalNotificationMessage* release_denm();
  ::DecentralizedEnvironmentalNotificationMessage* mutable_denm();
  void set_allocated_denm(::DecentralizedEnvironmentalNotificationMessage* denm);

  // @@protoc_insertion_point(class_scope:DENMessage)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_denm();
  void clear_has_denm();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ItsPduHeader* header_;
  ::DecentralizedEnvironmentalNotificationMessage* denm_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecentralizedEnvironmentalNotificationMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DecentralizedEnvironmentalNotificationMessage) */ {
 public:
  DecentralizedEnvironmentalNotificationMessage();
  virtual ~DecentralizedEnvironmentalNotificationMessage();

  DecentralizedEnvironmentalNotificationMessage(const DecentralizedEnvironmentalNotificationMessage& from);

  inline DecentralizedEnvironmentalNotificationMessage& operator=(const DecentralizedEnvironmentalNotificationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DecentralizedEnvironmentalNotificationMessage(DecentralizedEnvironmentalNotificationMessage&& from) noexcept
    : DecentralizedEnvironmentalNotificationMessage() {
    *this = ::std::move(from);
  }

  inline DecentralizedEnvironmentalNotificationMessage& operator=(DecentralizedEnvironmentalNotificationMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecentralizedEnvironmentalNotificationMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecentralizedEnvironmentalNotificationMessage* internal_default_instance() {
    return reinterpret_cast<const DecentralizedEnvironmentalNotificationMessage*>(
               &_DecentralizedEnvironmentalNotificationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DecentralizedEnvironmentalNotificationMessage* other);
  friend void swap(DecentralizedEnvironmentalNotificationMessage& a, DecentralizedEnvironmentalNotificationMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DecentralizedEnvironmentalNotificationMessage* New() const final {
    return CreateMaybeMessage<DecentralizedEnvironmentalNotificationMessage>(NULL);
  }

  DecentralizedEnvironmentalNotificationMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DecentralizedEnvironmentalNotificationMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DecentralizedEnvironmentalNotificationMessage& from);
  void MergeFrom(const DecentralizedEnvironmentalNotificationMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecentralizedEnvironmentalNotificationMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ManagementContainer management = 1;
  bool has_management() const;
  void clear_management();
  static const int kManagementFieldNumber = 1;
  private:
  const ::ManagementContainer& _internal_management() const;
  public:
  const ::ManagementContainer& management() const;
  ::ManagementContainer* release_management();
  ::ManagementContainer* mutable_management();
  void set_allocated_management(::ManagementContainer* management);

  // optional .SituationContainer situation = 2;
  bool has_situation() const;
  void clear_situation();
  static const int kSituationFieldNumber = 2;
  private:
  const ::SituationContainer& _internal_situation() const;
  public:
  const ::SituationContainer& situation() const;
  ::SituationContainer* release_situation();
  ::SituationContainer* mutable_situation();
  void set_allocated_situation(::SituationContainer* situation);

  // optional .LocationContainer location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  private:
  const ::LocationContainer& _internal_location() const;
  public:
  const ::LocationContainer& location() const;
  ::LocationContainer* release_location();
  ::LocationContainer* mutable_location();
  void set_allocated_location(::LocationContainer* location);

  // optional .AlacarteContainer alacarte = 4;
  bool has_alacarte() const;
  void clear_alacarte();
  static const int kAlacarteFieldNumber = 4;
  private:
  const ::AlacarteContainer& _internal_alacarte() const;
  public:
  const ::AlacarteContainer& alacarte() const;
  ::AlacarteContainer* release_alacarte();
  ::AlacarteContainer* mutable_alacarte();
  void set_allocated_alacarte(::AlacarteContainer* alacarte);

  // @@protoc_insertion_point(class_scope:DecentralizedEnvironmentalNotificationMessage)
 private:
  void set_has_management();
  void clear_has_management();
  void set_has_situation();
  void clear_has_situation();
  void set_has_location();
  void clear_has_location();
  void set_has_alacarte();
  void clear_has_alacarte();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ManagementContainer* management_;
  ::SituationContainer* situation_;
  ::LocationContainer* location_;
  ::AlacarteContainer* alacarte_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AlacarteContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AlacarteContainer) */ {
 public:
  AlacarteContainer();
  virtual ~AlacarteContainer();

  AlacarteContainer(const AlacarteContainer& from);

  inline AlacarteContainer& operator=(const AlacarteContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AlacarteContainer(AlacarteContainer&& from) noexcept
    : AlacarteContainer() {
    *this = ::std::move(from);
  }

  inline AlacarteContainer& operator=(AlacarteContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlacarteContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AlacarteContainer* internal_default_instance() {
    return reinterpret_cast<const AlacarteContainer*>(
               &_AlacarteContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AlacarteContainer* other);
  friend void swap(AlacarteContainer& a, AlacarteContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AlacarteContainer* New() const final {
    return CreateMaybeMessage<AlacarteContainer>(NULL);
  }

  AlacarteContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AlacarteContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AlacarteContainer& from);
  void MergeFrom(const AlacarteContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlacarteContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ImpactReductionContainer impactReduction = 2;
  bool has_impactreduction() const;
  void clear_impactreduction();
  static const int kImpactReductionFieldNumber = 2;
  private:
  const ::ImpactReductionContainer& _internal_impactreduction() const;
  public:
  const ::ImpactReductionContainer& impactreduction() const;
  ::ImpactReductionContainer* release_impactreduction();
  ::ImpactReductionContainer* mutable_impactreduction();
  void set_allocated_impactreduction(::ImpactReductionContainer* impactreduction);

  // optional .RoadWorksContainerExtended roadWorks = 4;
  bool has_roadworks() const;
  void clear_roadworks();
  static const int kRoadWorksFieldNumber = 4;
  private:
  const ::RoadWorksContainerExtended& _internal_roadworks() const;
  public:
  const ::RoadWorksContainerExtended& roadworks() const;
  ::RoadWorksContainerExtended* release_roadworks();
  ::RoadWorksContainerExtended* mutable_roadworks();
  void set_allocated_roadworks(::RoadWorksContainerExtended* roadworks);

  // optional .StationaryVehicleContainer stationaryVehicle = 6;
  bool has_stationaryvehicle() const;
  void clear_stationaryvehicle();
  static const int kStationaryVehicleFieldNumber = 6;
  private:
  const ::StationaryVehicleContainer& _internal_stationaryvehicle() const;
  public:
  const ::StationaryVehicleContainer& stationaryvehicle() const;
  ::StationaryVehicleContainer* release_stationaryvehicle();
  ::StationaryVehicleContainer* mutable_stationaryvehicle();
  void set_allocated_stationaryvehicle(::StationaryVehicleContainer* stationaryvehicle);

  // optional int32 lanePosition = 1;
  bool has_laneposition() const;
  void clear_laneposition();
  static const int kLanePositionFieldNumber = 1;
  ::google::protobuf::int32 laneposition() const;
  void set_laneposition(::google::protobuf::int32 value);

  // optional int32 externalTemperature = 3;
  bool has_externaltemperature() const;
  void clear_externaltemperature();
  static const int kExternalTemperatureFieldNumber = 3;
  ::google::protobuf::int32 externaltemperature() const;
  void set_externaltemperature(::google::protobuf::int32 value);

  // optional .PositioningSolutionType positioningSolution = 5;
  bool has_positioningsolution() const;
  void clear_positioningsolution();
  static const int kPositioningSolutionFieldNumber = 5;
  ::PositioningSolutionType positioningsolution() const;
  void set_positioningsolution(::PositioningSolutionType value);

  // @@protoc_insertion_point(class_scope:AlacarteContainer)
 private:
  void set_has_laneposition();
  void clear_has_laneposition();
  void set_has_impactreduction();
  void clear_has_impactreduction();
  void set_has_externaltemperature();
  void clear_has_externaltemperature();
  void set_has_roadworks();
  void clear_has_roadworks();
  void set_has_positioningsolution();
  void clear_has_positioningsolution();
  void set_has_stationaryvehicle();
  void clear_has_stationaryvehicle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ImpactReductionContainer* impactreduction_;
  ::RoadWorksContainerExtended* roadworks_;
  ::StationaryVehicleContainer* stationaryvehicle_;
  ::google::protobuf::int32 laneposition_;
  ::google::protobuf::int32 externaltemperature_;
  int positioningsolution_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImpactReductionContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImpactReductionContainer) */ {
 public:
  ImpactReductionContainer();
  virtual ~ImpactReductionContainer();

  ImpactReductionContainer(const ImpactReductionContainer& from);

  inline ImpactReductionContainer& operator=(const ImpactReductionContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImpactReductionContainer(ImpactReductionContainer&& from) noexcept
    : ImpactReductionContainer() {
    *this = ::std::move(from);
  }

  inline ImpactReductionContainer& operator=(ImpactReductionContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImpactReductionContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImpactReductionContainer* internal_default_instance() {
    return reinterpret_cast<const ImpactReductionContainer*>(
               &_ImpactReductionContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ImpactReductionContainer* other);
  friend void swap(ImpactReductionContainer& a, ImpactReductionContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImpactReductionContainer* New() const final {
    return CreateMaybeMessage<ImpactReductionContainer>(NULL);
  }

  ImpactReductionContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImpactReductionContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImpactReductionContainer& from);
  void MergeFrom(const ImpactReductionContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImpactReductionContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 positionOfPillars = 5;
  int positionofpillars_size() const;
  void clear_positionofpillars();
  static const int kPositionOfPillarsFieldNumber = 5;
  ::google::protobuf::uint32 positionofpillars(int index) const;
  void set_positionofpillars(int index, ::google::protobuf::uint32 value);
  void add_positionofpillars(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      positionofpillars() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_positionofpillars();

  // required uint32 heightLonCarrLeft = 1;
  bool has_heightloncarrleft() const;
  void clear_heightloncarrleft();
  static const int kHeightLonCarrLeftFieldNumber = 1;
  ::google::protobuf::uint32 heightloncarrleft() const;
  void set_heightloncarrleft(::google::protobuf::uint32 value);

  // required uint32 heightLonCarrRight = 2;
  bool has_heightloncarrright() const;
  void clear_heightloncarrright();
  static const int kHeightLonCarrRightFieldNumber = 2;
  ::google::protobuf::uint32 heightloncarrright() const;
  void set_heightloncarrright(::google::protobuf::uint32 value);

  // required uint32 posLonCarrLeft = 3;
  bool has_posloncarrleft() const;
  void clear_posloncarrleft();
  static const int kPosLonCarrLeftFieldNumber = 3;
  ::google::protobuf::uint32 posloncarrleft() const;
  void set_posloncarrleft(::google::protobuf::uint32 value);

  // required uint32 posLonCarrRight = 4;
  bool has_posloncarrright() const;
  void clear_posloncarrright();
  static const int kPosLonCarrRightFieldNumber = 4;
  ::google::protobuf::uint32 posloncarrright() const;
  void set_posloncarrright(::google::protobuf::uint32 value);

  // required uint32 posCentMass = 6;
  bool has_poscentmass() const;
  void clear_poscentmass();
  static const int kPosCentMassFieldNumber = 6;
  ::google::protobuf::uint32 poscentmass() const;
  void set_poscentmass(::google::protobuf::uint32 value);

  // required uint32 wheelBaseVehicle = 7;
  bool has_wheelbasevehicle() const;
  void clear_wheelbasevehicle();
  static const int kWheelBaseVehicleFieldNumber = 7;
  ::google::protobuf::uint32 wheelbasevehicle() const;
  void set_wheelbasevehicle(::google::protobuf::uint32 value);

  // required uint32 turningRadius = 8;
  bool has_turningradius() const;
  void clear_turningradius();
  static const int kTurningRadiusFieldNumber = 8;
  ::google::protobuf::uint32 turningradius() const;
  void set_turningradius(::google::protobuf::uint32 value);

  // required uint32 posFrontAx = 9;
  bool has_posfrontax() const;
  void clear_posfrontax();
  static const int kPosFrontAxFieldNumber = 9;
  ::google::protobuf::uint32 posfrontax() const;
  void set_posfrontax(::google::protobuf::uint32 value);

  // required .PositionOfOccupants positionOfOccupants = 10;
  bool has_positionofoccupants() const;
  void clear_positionofoccupants();
  static const int kPositionOfOccupantsFieldNumber = 10;
  ::PositionOfOccupants positionofoccupants() const;
  void set_positionofoccupants(::PositionOfOccupants value);

  // required uint32 vehicleMass = 11;
  bool has_vehiclemass() const;
  void clear_vehiclemass();
  static const int kVehicleMassFieldNumber = 11;
  ::google::protobuf::uint32 vehiclemass() const;
  void set_vehiclemass(::google::protobuf::uint32 value);

  // required .RequestResponseIndication requestResponseIndication = 12;
  bool has_requestresponseindication() const;
  void clear_requestresponseindication();
  static const int kRequestResponseIndicationFieldNumber = 12;
  ::RequestResponseIndication requestresponseindication() const;
  void set_requestresponseindication(::RequestResponseIndication value);

  // @@protoc_insertion_point(class_scope:ImpactReductionContainer)
 private:
  void set_has_heightloncarrleft();
  void clear_has_heightloncarrleft();
  void set_has_heightloncarrright();
  void clear_has_heightloncarrright();
  void set_has_posloncarrleft();
  void clear_has_posloncarrleft();
  void set_has_posloncarrright();
  void clear_has_posloncarrright();
  void set_has_poscentmass();
  void clear_has_poscentmass();
  void set_has_wheelbasevehicle();
  void clear_has_wheelbasevehicle();
  void set_has_turningradius();
  void clear_has_turningradius();
  void set_has_posfrontax();
  void clear_has_posfrontax();
  void set_has_positionofoccupants();
  void clear_has_positionofoccupants();
  void set_has_vehiclemass();
  void clear_has_vehiclemass();
  void set_has_requestresponseindication();
  void clear_has_requestresponseindication();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > positionofpillars_;
  ::google::protobuf::uint32 heightloncarrleft_;
  ::google::protobuf::uint32 heightloncarrright_;
  ::google::protobuf::uint32 posloncarrleft_;
  ::google::protobuf::uint32 posloncarrright_;
  ::google::protobuf::uint32 poscentmass_;
  ::google::protobuf::uint32 wheelbasevehicle_;
  ::google::protobuf::uint32 turningradius_;
  ::google::protobuf::uint32 posfrontax_;
  int positionofoccupants_;
  ::google::protobuf::uint32 vehiclemass_;
  int requestresponseindication_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LocationContainer) */ {
 public:
  LocationContainer();
  virtual ~LocationContainer();

  LocationContainer(const LocationContainer& from);

  inline LocationContainer& operator=(const LocationContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationContainer(LocationContainer&& from) noexcept
    : LocationContainer() {
    *this = ::std::move(from);
  }

  inline LocationContainer& operator=(LocationContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationContainer* internal_default_instance() {
    return reinterpret_cast<const LocationContainer*>(
               &_LocationContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(LocationContainer* other);
  friend void swap(LocationContainer& a, LocationContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationContainer* New() const final {
    return CreateMaybeMessage<LocationContainer>(NULL);
  }

  LocationContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationContainer& from);
  void MergeFrom(const LocationContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Speed eventSpeed = 1;
  bool has_eventspeed() const;
  void clear_eventspeed();
  static const int kEventSpeedFieldNumber = 1;
  private:
  const ::Speed& _internal_eventspeed() const;
  public:
  const ::Speed& eventspeed() const;
  ::Speed* release_eventspeed();
  ::Speed* mutable_eventspeed();
  void set_allocated_eventspeed(::Speed* eventspeed);

  // optional .Heading eventPositionHeading = 2;
  bool has_eventpositionheading() const;
  void clear_eventpositionheading();
  static const int kEventPositionHeadingFieldNumber = 2;
  private:
  const ::Heading& _internal_eventpositionheading() const;
  public:
  const ::Heading& eventpositionheading() const;
  ::Heading* release_eventpositionheading();
  ::Heading* mutable_eventpositionheading();
  void set_allocated_eventpositionheading(::Heading* eventpositionheading);

  // required uint32 traces = 3;
  bool has_traces() const;
  void clear_traces();
  static const int kTracesFieldNumber = 3;
  ::google::protobuf::uint32 traces() const;
  void set_traces(::google::protobuf::uint32 value);

  // optional .RoadType roadType = 4;
  bool has_roadtype() const;
  void clear_roadtype();
  static const int kRoadTypeFieldNumber = 4;
  ::RoadType roadtype() const;
  void set_roadtype(::RoadType value);

  // @@protoc_insertion_point(class_scope:LocationContainer)
 private:
  void set_has_eventspeed();
  void clear_has_eventspeed();
  void set_has_eventpositionheading();
  void clear_has_eventpositionheading();
  void set_has_traces();
  void clear_has_traces();
  void set_has_roadtype();
  void clear_has_roadtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Speed* eventspeed_;
  ::Heading* eventpositionheading_;
  ::google::protobuf::uint32 traces_;
  int roadtype_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ManagementContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ManagementContainer) */ {
 public:
  ManagementContainer();
  virtual ~ManagementContainer();

  ManagementContainer(const ManagementContainer& from);

  inline ManagementContainer& operator=(const ManagementContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ManagementContainer(ManagementContainer&& from) noexcept
    : ManagementContainer() {
    *this = ::std::move(from);
  }

  inline ManagementContainer& operator=(ManagementContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManagementContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ManagementContainer* internal_default_instance() {
    return reinterpret_cast<const ManagementContainer*>(
               &_ManagementContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ManagementContainer* other);
  friend void swap(ManagementContainer& a, ManagementContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ManagementContainer* New() const final {
    return CreateMaybeMessage<ManagementContainer>(NULL);
  }

  ManagementContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ManagementContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ManagementContainer& from);
  void MergeFrom(const ManagementContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManagementContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ActionID actionID = 1;
  bool has_actionid() const;
  void clear_actionid();
  static const int kActionIDFieldNumber = 1;
  private:
  const ::ActionID& _internal_actionid() const;
  public:
  const ::ActionID& actionid() const;
  ::ActionID* release_actionid();
  ::ActionID* mutable_actionid();
  void set_allocated_actionid(::ActionID* actionid);

  // required .ReferencePosition eventPosition = 5;
  bool has_eventposition() const;
  void clear_eventposition();
  static const int kEventPositionFieldNumber = 5;
  private:
  const ::ReferencePosition& _internal_eventposition() const;
  public:
  const ::ReferencePosition& eventposition() const;
  ::ReferencePosition* release_eventposition();
  ::ReferencePosition* mutable_eventposition();
  void set_allocated_eventposition(::ReferencePosition* eventposition);

  // required uint64 detectionTime = 2;
  bool has_detectiontime() const;
  void clear_detectiontime();
  static const int kDetectionTimeFieldNumber = 2;
  ::google::protobuf::uint64 detectiontime() const;
  void set_detectiontime(::google::protobuf::uint64 value);

  // required uint64 referenceTime = 3;
  bool has_referencetime() const;
  void clear_referencetime();
  static const int kReferenceTimeFieldNumber = 3;
  ::google::protobuf::uint64 referencetime() const;
  void set_referencetime(::google::protobuf::uint64 value);

  // optional .Termination termination = 4;
  bool has_termination() const;
  void clear_termination();
  static const int kTerminationFieldNumber = 4;
  ::Termination termination() const;
  void set_termination(::Termination value);

  // optional .RelevanceDistance relevanceDistance = 6;
  bool has_relevancedistance() const;
  void clear_relevancedistance();
  static const int kRelevanceDistanceFieldNumber = 6;
  ::RelevanceDistance relevancedistance() const;
  void set_relevancedistance(::RelevanceDistance value);

  // optional .RelevanceTrafficDirection relevanceTrafficDirection = 7;
  bool has_relevancetrafficdirection() const;
  void clear_relevancetrafficdirection();
  static const int kRelevanceTrafficDirectionFieldNumber = 7;
  ::RelevanceTrafficDirection relevancetrafficdirection() const;
  void set_relevancetrafficdirection(::RelevanceTrafficDirection value);

  // optional uint32 transmissionInterval = 9;
  bool has_transmissioninterval() const;
  void clear_transmissioninterval();
  static const int kTransmissionIntervalFieldNumber = 9;
  ::google::protobuf::uint32 transmissioninterval() const;
  void set_transmissioninterval(::google::protobuf::uint32 value);

  // required .StationType stationType = 10;
  bool has_stationtype() const;
  void clear_stationtype();
  static const int kStationTypeFieldNumber = 10;
  ::StationType stationtype() const;
  void set_stationtype(::StationType value);

  // optional uint32 validityDuration = 8 [default = 600];
  bool has_validityduration() const;
  void clear_validityduration();
  static const int kValidityDurationFieldNumber = 8;
  ::google::protobuf::uint32 validityduration() const;
  void set_validityduration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ManagementContainer)
 private:
  void set_has_actionid();
  void clear_has_actionid();
  void set_has_detectiontime();
  void clear_has_detectiontime();
  void set_has_referencetime();
  void clear_has_referencetime();
  void set_has_termination();
  void clear_has_termination();
  void set_has_eventposition();
  void clear_has_eventposition();
  void set_has_relevancedistance();
  void clear_has_relevancedistance();
  void set_has_relevancetrafficdirection();
  void clear_has_relevancetrafficdirection();
  void set_has_validityduration();
  void clear_has_validityduration();
  void set_has_transmissioninterval();
  void clear_has_transmissioninterval();
  void set_has_stationtype();
  void clear_has_stationtype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ActionID* actionid_;
  ::ReferencePosition* eventposition_;
  ::google::protobuf::uint64 detectiontime_;
  ::google::protobuf::uint64 referencetime_;
  int termination_;
  int relevancedistance_;
  int relevancetrafficdirection_;
  ::google::protobuf::uint32 transmissioninterval_;
  int stationtype_;
  ::google::protobuf::uint32 validityduration_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadWorksContainerExtended : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoadWorksContainerExtended) */ {
 public:
  RoadWorksContainerExtended();
  virtual ~RoadWorksContainerExtended();

  RoadWorksContainerExtended(const RoadWorksContainerExtended& from);

  inline RoadWorksContainerExtended& operator=(const RoadWorksContainerExtended& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadWorksContainerExtended(RoadWorksContainerExtended&& from) noexcept
    : RoadWorksContainerExtended() {
    *this = ::std::move(from);
  }

  inline RoadWorksContainerExtended& operator=(RoadWorksContainerExtended&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadWorksContainerExtended& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadWorksContainerExtended* internal_default_instance() {
    return reinterpret_cast<const RoadWorksContainerExtended*>(
               &_RoadWorksContainerExtended_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RoadWorksContainerExtended* other);
  friend void swap(RoadWorksContainerExtended& a, RoadWorksContainerExtended& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadWorksContainerExtended* New() const final {
    return CreateMaybeMessage<RoadWorksContainerExtended>(NULL);
  }

  RoadWorksContainerExtended* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadWorksContainerExtended>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadWorksContainerExtended& from);
  void MergeFrom(const RoadWorksContainerExtended& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadWorksContainerExtended* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ClosedLanes closedLanes = 2;
  bool has_closedlanes() const;
  void clear_closedlanes();
  static const int kClosedLanesFieldNumber = 2;
  private:
  const ::ClosedLanes& _internal_closedlanes() const;
  public:
  const ::ClosedLanes& closedlanes() const;
  ::ClosedLanes* release_closedlanes();
  ::ClosedLanes* mutable_closedlanes();
  void set_allocated_closedlanes(::ClosedLanes* closedlanes);

  // optional .RestrictedTypes restriction = 3;
  bool has_restriction() const;
  void clear_restriction();
  static const int kRestrictionFieldNumber = 3;
  private:
  const ::RestrictedTypes& _internal_restriction() const;
  public:
  const ::RestrictedTypes& restriction() const;
  ::RestrictedTypes* release_restriction();
  ::RestrictedTypes* mutable_restriction();
  void set_allocated_restriction(::RestrictedTypes* restriction);

  // optional .CauseCode incidentIndication = 5;
  bool has_incidentindication() const;
  void clear_incidentindication();
  static const int kIncidentIndicationFieldNumber = 5;
  private:
  const ::CauseCode& _internal_incidentindication() const;
  public:
  const ::CauseCode& incidentindication() const;
  ::CauseCode* release_incidentindication();
  ::CauseCode* mutable_incidentindication();
  void set_allocated_incidentindication(::CauseCode* incidentindication);

  // optional .ItineraryPath recommendedPath = 6;
  bool has_recommendedpath() const;
  void clear_recommendedpath();
  static const int kRecommendedPathFieldNumber = 6;
  private:
  const ::ItineraryPath& _internal_recommendedpath() const;
  public:
  const ::ItineraryPath& recommendedpath() const;
  ::ItineraryPath* release_recommendedpath();
  ::ItineraryPath* mutable_recommendedpath();
  void set_allocated_recommendedpath(::ItineraryPath* recommendedpath);

  // optional .DeltaReferencePosition startingPointSpeedLimit = 7;
  bool has_startingpointspeedlimit() const;
  void clear_startingpointspeedlimit();
  static const int kStartingPointSpeedLimitFieldNumber = 7;
  private:
  const ::DeltaReferencePosition& _internal_startingpointspeedlimit() const;
  public:
  const ::DeltaReferencePosition& startingpointspeedlimit() const;
  ::DeltaReferencePosition* release_startingpointspeedlimit();
  ::DeltaReferencePosition* mutable_startingpointspeedlimit();
  void set_allocated_startingpointspeedlimit(::DeltaReferencePosition* startingpointspeedlimit);

  // optional .ReferenceDenms referenceDenms = 9;
  bool has_referencedenms() const;
  void clear_referencedenms();
  static const int kReferenceDenmsFieldNumber = 9;
  private:
  const ::ReferenceDenms& _internal_referencedenms() const;
  public:
  const ::ReferenceDenms& referencedenms() const;
  ::ReferenceDenms* release_referencedenms();
  ::ReferenceDenms* mutable_referencedenms();
  void set_allocated_referencedenms(::ReferenceDenms* referencedenms);

  // optional .LightBarSirenInUse lightBarSirenInUse = 1;
  bool has_lightbarsireninuse() const;
  void clear_lightbarsireninuse();
  static const int kLightBarSirenInUseFieldNumber = 1;
  ::LightBarSirenInUse lightbarsireninuse() const;
  void set_lightbarsireninuse(::LightBarSirenInUse value);

  // optional uint32 speedLimit = 4;
  bool has_speedlimit() const;
  void clear_speedlimit();
  static const int kSpeedLimitFieldNumber = 4;
  ::google::protobuf::uint32 speedlimit() const;
  void set_speedlimit(::google::protobuf::uint32 value);

  // optional .TrafficRule trafficFlowRule = 8;
  bool has_trafficflowrule() const;
  void clear_trafficflowrule();
  static const int kTrafficFlowRuleFieldNumber = 8;
  ::TrafficRule trafficflowrule() const;
  void set_trafficflowrule(::TrafficRule value);

  // @@protoc_insertion_point(class_scope:RoadWorksContainerExtended)
 private:
  void set_has_lightbarsireninuse();
  void clear_has_lightbarsireninuse();
  void set_has_closedlanes();
  void clear_has_closedlanes();
  void set_has_restriction();
  void clear_has_restriction();
  void set_has_speedlimit();
  void clear_has_speedlimit();
  void set_has_incidentindication();
  void clear_has_incidentindication();
  void set_has_recommendedpath();
  void clear_has_recommendedpath();
  void set_has_startingpointspeedlimit();
  void clear_has_startingpointspeedlimit();
  void set_has_trafficflowrule();
  void clear_has_trafficflowrule();
  void set_has_referencedenms();
  void clear_has_referencedenms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ClosedLanes* closedlanes_;
  ::RestrictedTypes* restriction_;
  ::CauseCode* incidentindication_;
  ::ItineraryPath* recommendedpath_;
  ::DeltaReferencePosition* startingpointspeedlimit_;
  ::ReferenceDenms* referencedenms_;
  int lightbarsireninuse_;
  ::google::protobuf::uint32 speedlimit_;
  int trafficflowrule_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SituationContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SituationContainer) */ {
 public:
  SituationContainer();
  virtual ~SituationContainer();

  SituationContainer(const SituationContainer& from);

  inline SituationContainer& operator=(const SituationContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SituationContainer(SituationContainer&& from) noexcept
    : SituationContainer() {
    *this = ::std::move(from);
  }

  inline SituationContainer& operator=(SituationContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SituationContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SituationContainer* internal_default_instance() {
    return reinterpret_cast<const SituationContainer*>(
               &_SituationContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SituationContainer* other);
  friend void swap(SituationContainer& a, SituationContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SituationContainer* New() const final {
    return CreateMaybeMessage<SituationContainer>(NULL);
  }

  SituationContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SituationContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SituationContainer& from);
  void MergeFrom(const SituationContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SituationContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CauseCode eventType = 2;
  bool has_eventtype() const;
  void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  private:
  const ::CauseCode& _internal_eventtype() const;
  public:
  const ::CauseCode& eventtype() const;
  ::CauseCode* release_eventtype();
  ::CauseCode* mutable_eventtype();
  void set_allocated_eventtype(::CauseCode* eventtype);

  // optional .CauseCode linkedCause = 3;
  bool has_linkedcause() const;
  void clear_linkedcause();
  static const int kLinkedCauseFieldNumber = 3;
  private:
  const ::CauseCode& _internal_linkedcause() const;
  public:
  const ::CauseCode& linkedcause() const;
  ::CauseCode* release_linkedcause();
  ::CauseCode* mutable_linkedcause();
  void set_allocated_linkedcause(::CauseCode* linkedcause);

  // optional .EventHistory eventHistory = 4;
  bool has_eventhistory() const;
  void clear_eventhistory();
  static const int kEventHistoryFieldNumber = 4;
  private:
  const ::EventHistory& _internal_eventhistory() const;
  public:
  const ::EventHistory& eventhistory() const;
  ::EventHistory* release_eventhistory();
  ::EventHistory* mutable_eventhistory();
  void set_allocated_eventhistory(::EventHistory* eventhistory);

  // required uint32 informationQuality = 1;
  bool has_informationquality() const;
  void clear_informationquality();
  static const int kInformationQualityFieldNumber = 1;
  ::google::protobuf::uint32 informationquality() const;
  void set_informationquality(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SituationContainer)
 private:
  void set_has_informationquality();
  void clear_has_informationquality();
  void set_has_eventtype();
  void clear_has_eventtype();
  void set_has_linkedcause();
  void clear_has_linkedcause();
  void set_has_eventhistory();
  void clear_has_eventhistory();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CauseCode* eventtype_;
  ::CauseCode* linkedcause_;
  ::EventHistory* eventhistory_;
  ::google::protobuf::uint32 informationquality_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StationaryVehicleContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StationaryVehicleContainer) */ {
 public:
  StationaryVehicleContainer();
  virtual ~StationaryVehicleContainer();

  StationaryVehicleContainer(const StationaryVehicleContainer& from);

  inline StationaryVehicleContainer& operator=(const StationaryVehicleContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StationaryVehicleContainer(StationaryVehicleContainer&& from) noexcept
    : StationaryVehicleContainer() {
    *this = ::std::move(from);
  }

  inline StationaryVehicleContainer& operator=(StationaryVehicleContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StationaryVehicleContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StationaryVehicleContainer* internal_default_instance() {
    return reinterpret_cast<const StationaryVehicleContainer*>(
               &_StationaryVehicleContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(StationaryVehicleContainer* other);
  friend void swap(StationaryVehicleContainer& a, StationaryVehicleContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StationaryVehicleContainer* New() const final {
    return CreateMaybeMessage<StationaryVehicleContainer>(NULL);
  }

  StationaryVehicleContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StationaryVehicleContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StationaryVehicleContainer& from);
  void MergeFrom(const StationaryVehicleContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StationaryVehicleContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CauseCode stationaryCause = 2;
  bool has_stationarycause() const;
  void clear_stationarycause();
  static const int kStationaryCauseFieldNumber = 2;
  private:
  const ::CauseCode& _internal_stationarycause() const;
  public:
  const ::CauseCode& stationarycause() const;
  ::CauseCode* release_stationarycause();
  ::CauseCode* mutable_stationarycause();
  void set_allocated_stationarycause(::CauseCode* stationarycause);

  // optional .DangerousGoodsExtended carryingDangerousGoods = 3;
  bool has_carryingdangerousgoods() const;
  void clear_carryingdangerousgoods();
  static const int kCarryingDangerousGoodsFieldNumber = 3;
  private:
  const ::DangerousGoodsExtended& _internal_carryingdangerousgoods() const;
  public:
  const ::DangerousGoodsExtended& carryingdangerousgoods() const;
  ::DangerousGoodsExtended* release_carryingdangerousgoods();
  ::DangerousGoodsExtended* mutable_carryingdangerousgoods();
  void set_allocated_carryingdangerousgoods(::DangerousGoodsExtended* carryingdangerousgoods);

  // optional .VehicleIdentification vehicleIdentification = 5;
  bool has_vehicleidentification() const;
  void clear_vehicleidentification();
  static const int kVehicleIdentificationFieldNumber = 5;
  private:
  const ::VehicleIdentification& _internal_vehicleidentification() const;
  public:
  const ::VehicleIdentification& vehicleidentification() const;
  ::VehicleIdentification* release_vehicleidentification();
  ::VehicleIdentification* mutable_vehicleidentification();
  void set_allocated_vehicleidentification(::VehicleIdentification* vehicleidentification);

  // optional .EnergyStorageType energyStorageType = 6;
  bool has_energystoragetype() const;
  void clear_energystoragetype();
  static const int kEnergyStorageTypeFieldNumber = 6;
  private:
  const ::EnergyStorageType& _internal_energystoragetype() const;
  public:
  const ::EnergyStorageType& energystoragetype() const;
  ::EnergyStorageType* release_energystoragetype();
  ::EnergyStorageType* mutable_energystoragetype();
  void set_allocated_energystoragetype(::EnergyStorageType* energystoragetype);

  // optional .StationarySince stationarySince = 1;
  bool has_stationarysince() const;
  void clear_stationarysince();
  static const int kStationarySinceFieldNumber = 1;
  ::StationarySince stationarysince() const;
  void set_stationarysince(::StationarySince value);

  // optional uint32 numberOfOccupants = 4;
  bool has_numberofoccupants() const;
  void clear_numberofoccupants();
  static const int kNumberOfOccupantsFieldNumber = 4;
  ::google::protobuf::uint32 numberofoccupants() const;
  void set_numberofoccupants(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:StationaryVehicleContainer)
 private:
  void set_has_stationarysince();
  void clear_has_stationarysince();
  void set_has_stationarycause();
  void clear_has_stationarycause();
  void set_has_carryingdangerousgoods();
  void clear_has_carryingdangerousgoods();
  void set_has_numberofoccupants();
  void clear_has_numberofoccupants();
  void set_has_vehicleidentification();
  void clear_has_vehicleidentification();
  void set_has_energystoragetype();
  void clear_has_energystoragetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CauseCode* stationarycause_;
  ::DangerousGoodsExtended* carryingdangerousgoods_;
  ::VehicleIdentification* vehicleidentification_;
  ::EnergyStorageType* energystoragetype_;
  int stationarysince_;
  ::google::protobuf::uint32 numberofoccupants_;
  friend struct ::protobuf_denm_5finterface_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DENMessage

// required .ItsPduHeader header = 1;
inline bool DENMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DENMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DENMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ItsPduHeader& DENMessage::_internal_header() const {
  return *header_;
}
inline const ::ItsPduHeader& DENMessage::header() const {
  const ::ItsPduHeader* p = header_;
  // @@protoc_insertion_point(field_get:DENMessage.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ItsPduHeader*>(
      &::_ItsPduHeader_default_instance_);
}
inline ::ItsPduHeader* DENMessage::release_header() {
  // @@protoc_insertion_point(field_release:DENMessage.header)
  clear_has_header();
  ::ItsPduHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ItsPduHeader* DENMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::ItsPduHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DENMessage.header)
  return header_;
}
inline void DENMessage::set_allocated_header(::ItsPduHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:DENMessage.header)
}

// required .DecentralizedEnvironmentalNotificationMessage denm = 2;
inline bool DENMessage::has_denm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DENMessage::set_has_denm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DENMessage::clear_has_denm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DENMessage::clear_denm() {
  if (denm_ != NULL) denm_->Clear();
  clear_has_denm();
}
inline const ::DecentralizedEnvironmentalNotificationMessage& DENMessage::_internal_denm() const {
  return *denm_;
}
inline const ::DecentralizedEnvironmentalNotificationMessage& DENMessage::denm() const {
  const ::DecentralizedEnvironmentalNotificationMessage* p = denm_;
  // @@protoc_insertion_point(field_get:DENMessage.denm)
  return p != NULL ? *p : *reinterpret_cast<const ::DecentralizedEnvironmentalNotificationMessage*>(
      &::_DecentralizedEnvironmentalNotificationMessage_default_instance_);
}
inline ::DecentralizedEnvironmentalNotificationMessage* DENMessage::release_denm() {
  // @@protoc_insertion_point(field_release:DENMessage.denm)
  clear_has_denm();
  ::DecentralizedEnvironmentalNotificationMessage* temp = denm_;
  denm_ = NULL;
  return temp;
}
inline ::DecentralizedEnvironmentalNotificationMessage* DENMessage::mutable_denm() {
  set_has_denm();
  if (denm_ == NULL) {
    auto* p = CreateMaybeMessage<::DecentralizedEnvironmentalNotificationMessage>(GetArenaNoVirtual());
    denm_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DENMessage.denm)
  return denm_;
}
inline void DENMessage::set_allocated_denm(::DecentralizedEnvironmentalNotificationMessage* denm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete denm_;
  }
  if (denm) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      denm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, denm, submessage_arena);
    }
    set_has_denm();
  } else {
    clear_has_denm();
  }
  denm_ = denm;
  // @@protoc_insertion_point(field_set_allocated:DENMessage.denm)
}

// -------------------------------------------------------------------

// DecentralizedEnvironmentalNotificationMessage

// required .ManagementContainer management = 1;
inline bool DecentralizedEnvironmentalNotificationMessage::has_management() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecentralizedEnvironmentalNotificationMessage::set_has_management() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecentralizedEnvironmentalNotificationMessage::clear_has_management() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecentralizedEnvironmentalNotificationMessage::clear_management() {
  if (management_ != NULL) management_->Clear();
  clear_has_management();
}
inline const ::ManagementContainer& DecentralizedEnvironmentalNotificationMessage::_internal_management() const {
  return *management_;
}
inline const ::ManagementContainer& DecentralizedEnvironmentalNotificationMessage::management() const {
  const ::ManagementContainer* p = management_;
  // @@protoc_insertion_point(field_get:DecentralizedEnvironmentalNotificationMessage.management)
  return p != NULL ? *p : *reinterpret_cast<const ::ManagementContainer*>(
      &::_ManagementContainer_default_instance_);
}
inline ::ManagementContainer* DecentralizedEnvironmentalNotificationMessage::release_management() {
  // @@protoc_insertion_point(field_release:DecentralizedEnvironmentalNotificationMessage.management)
  clear_has_management();
  ::ManagementContainer* temp = management_;
  management_ = NULL;
  return temp;
}
inline ::ManagementContainer* DecentralizedEnvironmentalNotificationMessage::mutable_management() {
  set_has_management();
  if (management_ == NULL) {
    auto* p = CreateMaybeMessage<::ManagementContainer>(GetArenaNoVirtual());
    management_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DecentralizedEnvironmentalNotificationMessage.management)
  return management_;
}
inline void DecentralizedEnvironmentalNotificationMessage::set_allocated_management(::ManagementContainer* management) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete management_;
  }
  if (management) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      management = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, management, submessage_arena);
    }
    set_has_management();
  } else {
    clear_has_management();
  }
  management_ = management;
  // @@protoc_insertion_point(field_set_allocated:DecentralizedEnvironmentalNotificationMessage.management)
}

// optional .SituationContainer situation = 2;
inline bool DecentralizedEnvironmentalNotificationMessage::has_situation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecentralizedEnvironmentalNotificationMessage::set_has_situation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecentralizedEnvironmentalNotificationMessage::clear_has_situation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecentralizedEnvironmentalNotificationMessage::clear_situation() {
  if (situation_ != NULL) situation_->Clear();
  clear_has_situation();
}
inline const ::SituationContainer& DecentralizedEnvironmentalNotificationMessage::_internal_situation() const {
  return *situation_;
}
inline const ::SituationContainer& DecentralizedEnvironmentalNotificationMessage::situation() const {
  const ::SituationContainer* p = situation_;
  // @@protoc_insertion_point(field_get:DecentralizedEnvironmentalNotificationMessage.situation)
  return p != NULL ? *p : *reinterpret_cast<const ::SituationContainer*>(
      &::_SituationContainer_default_instance_);
}
inline ::SituationContainer* DecentralizedEnvironmentalNotificationMessage::release_situation() {
  // @@protoc_insertion_point(field_release:DecentralizedEnvironmentalNotificationMessage.situation)
  clear_has_situation();
  ::SituationContainer* temp = situation_;
  situation_ = NULL;
  return temp;
}
inline ::SituationContainer* DecentralizedEnvironmentalNotificationMessage::mutable_situation() {
  set_has_situation();
  if (situation_ == NULL) {
    auto* p = CreateMaybeMessage<::SituationContainer>(GetArenaNoVirtual());
    situation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DecentralizedEnvironmentalNotificationMessage.situation)
  return situation_;
}
inline void DecentralizedEnvironmentalNotificationMessage::set_allocated_situation(::SituationContainer* situation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete situation_;
  }
  if (situation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      situation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, situation, submessage_arena);
    }
    set_has_situation();
  } else {
    clear_has_situation();
  }
  situation_ = situation;
  // @@protoc_insertion_point(field_set_allocated:DecentralizedEnvironmentalNotificationMessage.situation)
}

// optional .LocationContainer location = 3;
inline bool DecentralizedEnvironmentalNotificationMessage::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecentralizedEnvironmentalNotificationMessage::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecentralizedEnvironmentalNotificationMessage::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecentralizedEnvironmentalNotificationMessage::clear_location() {
  if (location_ != NULL) location_->Clear();
  clear_has_location();
}
inline const ::LocationContainer& DecentralizedEnvironmentalNotificationMessage::_internal_location() const {
  return *location_;
}
inline const ::LocationContainer& DecentralizedEnvironmentalNotificationMessage::location() const {
  const ::LocationContainer* p = location_;
  // @@protoc_insertion_point(field_get:DecentralizedEnvironmentalNotificationMessage.location)
  return p != NULL ? *p : *reinterpret_cast<const ::LocationContainer*>(
      &::_LocationContainer_default_instance_);
}
inline ::LocationContainer* DecentralizedEnvironmentalNotificationMessage::release_location() {
  // @@protoc_insertion_point(field_release:DecentralizedEnvironmentalNotificationMessage.location)
  clear_has_location();
  ::LocationContainer* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::LocationContainer* DecentralizedEnvironmentalNotificationMessage::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::LocationContainer>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DecentralizedEnvironmentalNotificationMessage.location)
  return location_;
}
inline void DecentralizedEnvironmentalNotificationMessage::set_allocated_location(::LocationContainer* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    set_has_location();
  } else {
    clear_has_location();
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:DecentralizedEnvironmentalNotificationMessage.location)
}

// optional .AlacarteContainer alacarte = 4;
inline bool DecentralizedEnvironmentalNotificationMessage::has_alacarte() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DecentralizedEnvironmentalNotificationMessage::set_has_alacarte() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DecentralizedEnvironmentalNotificationMessage::clear_has_alacarte() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DecentralizedEnvironmentalNotificationMessage::clear_alacarte() {
  if (alacarte_ != NULL) alacarte_->Clear();
  clear_has_alacarte();
}
inline const ::AlacarteContainer& DecentralizedEnvironmentalNotificationMessage::_internal_alacarte() const {
  return *alacarte_;
}
inline const ::AlacarteContainer& DecentralizedEnvironmentalNotificationMessage::alacarte() const {
  const ::AlacarteContainer* p = alacarte_;
  // @@protoc_insertion_point(field_get:DecentralizedEnvironmentalNotificationMessage.alacarte)
  return p != NULL ? *p : *reinterpret_cast<const ::AlacarteContainer*>(
      &::_AlacarteContainer_default_instance_);
}
inline ::AlacarteContainer* DecentralizedEnvironmentalNotificationMessage::release_alacarte() {
  // @@protoc_insertion_point(field_release:DecentralizedEnvironmentalNotificationMessage.alacarte)
  clear_has_alacarte();
  ::AlacarteContainer* temp = alacarte_;
  alacarte_ = NULL;
  return temp;
}
inline ::AlacarteContainer* DecentralizedEnvironmentalNotificationMessage::mutable_alacarte() {
  set_has_alacarte();
  if (alacarte_ == NULL) {
    auto* p = CreateMaybeMessage<::AlacarteContainer>(GetArenaNoVirtual());
    alacarte_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DecentralizedEnvironmentalNotificationMessage.alacarte)
  return alacarte_;
}
inline void DecentralizedEnvironmentalNotificationMessage::set_allocated_alacarte(::AlacarteContainer* alacarte) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete alacarte_;
  }
  if (alacarte) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alacarte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alacarte, submessage_arena);
    }
    set_has_alacarte();
  } else {
    clear_has_alacarte();
  }
  alacarte_ = alacarte;
  // @@protoc_insertion_point(field_set_allocated:DecentralizedEnvironmentalNotificationMessage.alacarte)
}

// -------------------------------------------------------------------

// AlacarteContainer

// optional int32 lanePosition = 1;
inline bool AlacarteContainer::has_laneposition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AlacarteContainer::set_has_laneposition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AlacarteContainer::clear_has_laneposition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AlacarteContainer::clear_laneposition() {
  laneposition_ = 0;
  clear_has_laneposition();
}
inline ::google::protobuf::int32 AlacarteContainer::laneposition() const {
  // @@protoc_insertion_point(field_get:AlacarteContainer.lanePosition)
  return laneposition_;
}
inline void AlacarteContainer::set_laneposition(::google::protobuf::int32 value) {
  set_has_laneposition();
  laneposition_ = value;
  // @@protoc_insertion_point(field_set:AlacarteContainer.lanePosition)
}

// optional .ImpactReductionContainer impactReduction = 2;
inline bool AlacarteContainer::has_impactreduction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlacarteContainer::set_has_impactreduction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlacarteContainer::clear_has_impactreduction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlacarteContainer::clear_impactreduction() {
  if (impactreduction_ != NULL) impactreduction_->Clear();
  clear_has_impactreduction();
}
inline const ::ImpactReductionContainer& AlacarteContainer::_internal_impactreduction() const {
  return *impactreduction_;
}
inline const ::ImpactReductionContainer& AlacarteContainer::impactreduction() const {
  const ::ImpactReductionContainer* p = impactreduction_;
  // @@protoc_insertion_point(field_get:AlacarteContainer.impactReduction)
  return p != NULL ? *p : *reinterpret_cast<const ::ImpactReductionContainer*>(
      &::_ImpactReductionContainer_default_instance_);
}
inline ::ImpactReductionContainer* AlacarteContainer::release_impactreduction() {
  // @@protoc_insertion_point(field_release:AlacarteContainer.impactReduction)
  clear_has_impactreduction();
  ::ImpactReductionContainer* temp = impactreduction_;
  impactreduction_ = NULL;
  return temp;
}
inline ::ImpactReductionContainer* AlacarteContainer::mutable_impactreduction() {
  set_has_impactreduction();
  if (impactreduction_ == NULL) {
    auto* p = CreateMaybeMessage<::ImpactReductionContainer>(GetArenaNoVirtual());
    impactreduction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AlacarteContainer.impactReduction)
  return impactreduction_;
}
inline void AlacarteContainer::set_allocated_impactreduction(::ImpactReductionContainer* impactreduction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete impactreduction_;
  }
  if (impactreduction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      impactreduction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, impactreduction, submessage_arena);
    }
    set_has_impactreduction();
  } else {
    clear_has_impactreduction();
  }
  impactreduction_ = impactreduction;
  // @@protoc_insertion_point(field_set_allocated:AlacarteContainer.impactReduction)
}

// optional int32 externalTemperature = 3;
inline bool AlacarteContainer::has_externaltemperature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AlacarteContainer::set_has_externaltemperature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AlacarteContainer::clear_has_externaltemperature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AlacarteContainer::clear_externaltemperature() {
  externaltemperature_ = 0;
  clear_has_externaltemperature();
}
inline ::google::protobuf::int32 AlacarteContainer::externaltemperature() const {
  // @@protoc_insertion_point(field_get:AlacarteContainer.externalTemperature)
  return externaltemperature_;
}
inline void AlacarteContainer::set_externaltemperature(::google::protobuf::int32 value) {
  set_has_externaltemperature();
  externaltemperature_ = value;
  // @@protoc_insertion_point(field_set:AlacarteContainer.externalTemperature)
}

// optional .RoadWorksContainerExtended roadWorks = 4;
inline bool AlacarteContainer::has_roadworks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlacarteContainer::set_has_roadworks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlacarteContainer::clear_has_roadworks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlacarteContainer::clear_roadworks() {
  if (roadworks_ != NULL) roadworks_->Clear();
  clear_has_roadworks();
}
inline const ::RoadWorksContainerExtended& AlacarteContainer::_internal_roadworks() const {
  return *roadworks_;
}
inline const ::RoadWorksContainerExtended& AlacarteContainer::roadworks() const {
  const ::RoadWorksContainerExtended* p = roadworks_;
  // @@protoc_insertion_point(field_get:AlacarteContainer.roadWorks)
  return p != NULL ? *p : *reinterpret_cast<const ::RoadWorksContainerExtended*>(
      &::_RoadWorksContainerExtended_default_instance_);
}
inline ::RoadWorksContainerExtended* AlacarteContainer::release_roadworks() {
  // @@protoc_insertion_point(field_release:AlacarteContainer.roadWorks)
  clear_has_roadworks();
  ::RoadWorksContainerExtended* temp = roadworks_;
  roadworks_ = NULL;
  return temp;
}
inline ::RoadWorksContainerExtended* AlacarteContainer::mutable_roadworks() {
  set_has_roadworks();
  if (roadworks_ == NULL) {
    auto* p = CreateMaybeMessage<::RoadWorksContainerExtended>(GetArenaNoVirtual());
    roadworks_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AlacarteContainer.roadWorks)
  return roadworks_;
}
inline void AlacarteContainer::set_allocated_roadworks(::RoadWorksContainerExtended* roadworks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roadworks_;
  }
  if (roadworks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roadworks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roadworks, submessage_arena);
    }
    set_has_roadworks();
  } else {
    clear_has_roadworks();
  }
  roadworks_ = roadworks;
  // @@protoc_insertion_point(field_set_allocated:AlacarteContainer.roadWorks)
}

// optional .PositioningSolutionType positioningSolution = 5;
inline bool AlacarteContainer::has_positioningsolution() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AlacarteContainer::set_has_positioningsolution() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AlacarteContainer::clear_has_positioningsolution() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AlacarteContainer::clear_positioningsolution() {
  positioningsolution_ = 0;
  clear_has_positioningsolution();
}
inline ::PositioningSolutionType AlacarteContainer::positioningsolution() const {
  // @@protoc_insertion_point(field_get:AlacarteContainer.positioningSolution)
  return static_cast< ::PositioningSolutionType >(positioningsolution_);
}
inline void AlacarteContainer::set_positioningsolution(::PositioningSolutionType value) {
  assert(::PositioningSolutionType_IsValid(value));
  set_has_positioningsolution();
  positioningsolution_ = value;
  // @@protoc_insertion_point(field_set:AlacarteContainer.positioningSolution)
}

// optional .StationaryVehicleContainer stationaryVehicle = 6;
inline bool AlacarteContainer::has_stationaryvehicle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlacarteContainer::set_has_stationaryvehicle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlacarteContainer::clear_has_stationaryvehicle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlacarteContainer::clear_stationaryvehicle() {
  if (stationaryvehicle_ != NULL) stationaryvehicle_->Clear();
  clear_has_stationaryvehicle();
}
inline const ::StationaryVehicleContainer& AlacarteContainer::_internal_stationaryvehicle() const {
  return *stationaryvehicle_;
}
inline const ::StationaryVehicleContainer& AlacarteContainer::stationaryvehicle() const {
  const ::StationaryVehicleContainer* p = stationaryvehicle_;
  // @@protoc_insertion_point(field_get:AlacarteContainer.stationaryVehicle)
  return p != NULL ? *p : *reinterpret_cast<const ::StationaryVehicleContainer*>(
      &::_StationaryVehicleContainer_default_instance_);
}
inline ::StationaryVehicleContainer* AlacarteContainer::release_stationaryvehicle() {
  // @@protoc_insertion_point(field_release:AlacarteContainer.stationaryVehicle)
  clear_has_stationaryvehicle();
  ::StationaryVehicleContainer* temp = stationaryvehicle_;
  stationaryvehicle_ = NULL;
  return temp;
}
inline ::StationaryVehicleContainer* AlacarteContainer::mutable_stationaryvehicle() {
  set_has_stationaryvehicle();
  if (stationaryvehicle_ == NULL) {
    auto* p = CreateMaybeMessage<::StationaryVehicleContainer>(GetArenaNoVirtual());
    stationaryvehicle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AlacarteContainer.stationaryVehicle)
  return stationaryvehicle_;
}
inline void AlacarteContainer::set_allocated_stationaryvehicle(::StationaryVehicleContainer* stationaryvehicle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stationaryvehicle_;
  }
  if (stationaryvehicle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stationaryvehicle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stationaryvehicle, submessage_arena);
    }
    set_has_stationaryvehicle();
  } else {
    clear_has_stationaryvehicle();
  }
  stationaryvehicle_ = stationaryvehicle;
  // @@protoc_insertion_point(field_set_allocated:AlacarteContainer.stationaryVehicle)
}

// -------------------------------------------------------------------

// ImpactReductionContainer

// required uint32 heightLonCarrLeft = 1;
inline bool ImpactReductionContainer::has_heightloncarrleft() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImpactReductionContainer::set_has_heightloncarrleft() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImpactReductionContainer::clear_has_heightloncarrleft() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImpactReductionContainer::clear_heightloncarrleft() {
  heightloncarrleft_ = 0u;
  clear_has_heightloncarrleft();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::heightloncarrleft() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.heightLonCarrLeft)
  return heightloncarrleft_;
}
inline void ImpactReductionContainer::set_heightloncarrleft(::google::protobuf::uint32 value) {
  set_has_heightloncarrleft();
  heightloncarrleft_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.heightLonCarrLeft)
}

// required uint32 heightLonCarrRight = 2;
inline bool ImpactReductionContainer::has_heightloncarrright() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImpactReductionContainer::set_has_heightloncarrright() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImpactReductionContainer::clear_has_heightloncarrright() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImpactReductionContainer::clear_heightloncarrright() {
  heightloncarrright_ = 0u;
  clear_has_heightloncarrright();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::heightloncarrright() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.heightLonCarrRight)
  return heightloncarrright_;
}
inline void ImpactReductionContainer::set_heightloncarrright(::google::protobuf::uint32 value) {
  set_has_heightloncarrright();
  heightloncarrright_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.heightLonCarrRight)
}

// required uint32 posLonCarrLeft = 3;
inline bool ImpactReductionContainer::has_posloncarrleft() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImpactReductionContainer::set_has_posloncarrleft() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImpactReductionContainer::clear_has_posloncarrleft() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImpactReductionContainer::clear_posloncarrleft() {
  posloncarrleft_ = 0u;
  clear_has_posloncarrleft();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::posloncarrleft() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.posLonCarrLeft)
  return posloncarrleft_;
}
inline void ImpactReductionContainer::set_posloncarrleft(::google::protobuf::uint32 value) {
  set_has_posloncarrleft();
  posloncarrleft_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.posLonCarrLeft)
}

// required uint32 posLonCarrRight = 4;
inline bool ImpactReductionContainer::has_posloncarrright() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImpactReductionContainer::set_has_posloncarrright() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImpactReductionContainer::clear_has_posloncarrright() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImpactReductionContainer::clear_posloncarrright() {
  posloncarrright_ = 0u;
  clear_has_posloncarrright();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::posloncarrright() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.posLonCarrRight)
  return posloncarrright_;
}
inline void ImpactReductionContainer::set_posloncarrright(::google::protobuf::uint32 value) {
  set_has_posloncarrright();
  posloncarrright_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.posLonCarrRight)
}

// repeated uint32 positionOfPillars = 5;
inline int ImpactReductionContainer::positionofpillars_size() const {
  return positionofpillars_.size();
}
inline void ImpactReductionContainer::clear_positionofpillars() {
  positionofpillars_.Clear();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::positionofpillars(int index) const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.positionOfPillars)
  return positionofpillars_.Get(index);
}
inline void ImpactReductionContainer::set_positionofpillars(int index, ::google::protobuf::uint32 value) {
  positionofpillars_.Set(index, value);
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.positionOfPillars)
}
inline void ImpactReductionContainer::add_positionofpillars(::google::protobuf::uint32 value) {
  positionofpillars_.Add(value);
  // @@protoc_insertion_point(field_add:ImpactReductionContainer.positionOfPillars)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ImpactReductionContainer::positionofpillars() const {
  // @@protoc_insertion_point(field_list:ImpactReductionContainer.positionOfPillars)
  return positionofpillars_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ImpactReductionContainer::mutable_positionofpillars() {
  // @@protoc_insertion_point(field_mutable_list:ImpactReductionContainer.positionOfPillars)
  return &positionofpillars_;
}

// required uint32 posCentMass = 6;
inline bool ImpactReductionContainer::has_poscentmass() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImpactReductionContainer::set_has_poscentmass() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImpactReductionContainer::clear_has_poscentmass() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImpactReductionContainer::clear_poscentmass() {
  poscentmass_ = 0u;
  clear_has_poscentmass();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::poscentmass() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.posCentMass)
  return poscentmass_;
}
inline void ImpactReductionContainer::set_poscentmass(::google::protobuf::uint32 value) {
  set_has_poscentmass();
  poscentmass_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.posCentMass)
}

// required uint32 wheelBaseVehicle = 7;
inline bool ImpactReductionContainer::has_wheelbasevehicle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImpactReductionContainer::set_has_wheelbasevehicle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImpactReductionContainer::clear_has_wheelbasevehicle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImpactReductionContainer::clear_wheelbasevehicle() {
  wheelbasevehicle_ = 0u;
  clear_has_wheelbasevehicle();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::wheelbasevehicle() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.wheelBaseVehicle)
  return wheelbasevehicle_;
}
inline void ImpactReductionContainer::set_wheelbasevehicle(::google::protobuf::uint32 value) {
  set_has_wheelbasevehicle();
  wheelbasevehicle_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.wheelBaseVehicle)
}

// required uint32 turningRadius = 8;
inline bool ImpactReductionContainer::has_turningradius() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImpactReductionContainer::set_has_turningradius() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImpactReductionContainer::clear_has_turningradius() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImpactReductionContainer::clear_turningradius() {
  turningradius_ = 0u;
  clear_has_turningradius();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::turningradius() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.turningRadius)
  return turningradius_;
}
inline void ImpactReductionContainer::set_turningradius(::google::protobuf::uint32 value) {
  set_has_turningradius();
  turningradius_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.turningRadius)
}

// required uint32 posFrontAx = 9;
inline bool ImpactReductionContainer::has_posfrontax() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImpactReductionContainer::set_has_posfrontax() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImpactReductionContainer::clear_has_posfrontax() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImpactReductionContainer::clear_posfrontax() {
  posfrontax_ = 0u;
  clear_has_posfrontax();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::posfrontax() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.posFrontAx)
  return posfrontax_;
}
inline void ImpactReductionContainer::set_posfrontax(::google::protobuf::uint32 value) {
  set_has_posfrontax();
  posfrontax_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.posFrontAx)
}

// required .PositionOfOccupants positionOfOccupants = 10;
inline bool ImpactReductionContainer::has_positionofoccupants() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImpactReductionContainer::set_has_positionofoccupants() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImpactReductionContainer::clear_has_positionofoccupants() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImpactReductionContainer::clear_positionofoccupants() {
  positionofoccupants_ = 0;
  clear_has_positionofoccupants();
}
inline ::PositionOfOccupants ImpactReductionContainer::positionofoccupants() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.positionOfOccupants)
  return static_cast< ::PositionOfOccupants >(positionofoccupants_);
}
inline void ImpactReductionContainer::set_positionofoccupants(::PositionOfOccupants value) {
  assert(::PositionOfOccupants_IsValid(value));
  set_has_positionofoccupants();
  positionofoccupants_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.positionOfOccupants)
}

// required uint32 vehicleMass = 11;
inline bool ImpactReductionContainer::has_vehiclemass() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImpactReductionContainer::set_has_vehiclemass() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImpactReductionContainer::clear_has_vehiclemass() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImpactReductionContainer::clear_vehiclemass() {
  vehiclemass_ = 0u;
  clear_has_vehiclemass();
}
inline ::google::protobuf::uint32 ImpactReductionContainer::vehiclemass() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.vehicleMass)
  return vehiclemass_;
}
inline void ImpactReductionContainer::set_vehiclemass(::google::protobuf::uint32 value) {
  set_has_vehiclemass();
  vehiclemass_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.vehicleMass)
}

// required .RequestResponseIndication requestResponseIndication = 12;
inline bool ImpactReductionContainer::has_requestresponseindication() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImpactReductionContainer::set_has_requestresponseindication() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImpactReductionContainer::clear_has_requestresponseindication() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImpactReductionContainer::clear_requestresponseindication() {
  requestresponseindication_ = 0;
  clear_has_requestresponseindication();
}
inline ::RequestResponseIndication ImpactReductionContainer::requestresponseindication() const {
  // @@protoc_insertion_point(field_get:ImpactReductionContainer.requestResponseIndication)
  return static_cast< ::RequestResponseIndication >(requestresponseindication_);
}
inline void ImpactReductionContainer::set_requestresponseindication(::RequestResponseIndication value) {
  assert(::RequestResponseIndication_IsValid(value));
  set_has_requestresponseindication();
  requestresponseindication_ = value;
  // @@protoc_insertion_point(field_set:ImpactReductionContainer.requestResponseIndication)
}

// -------------------------------------------------------------------

// LocationContainer

// optional .Speed eventSpeed = 1;
inline bool LocationContainer::has_eventspeed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationContainer::set_has_eventspeed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationContainer::clear_has_eventspeed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Speed& LocationContainer::_internal_eventspeed() const {
  return *eventspeed_;
}
inline const ::Speed& LocationContainer::eventspeed() const {
  const ::Speed* p = eventspeed_;
  // @@protoc_insertion_point(field_get:LocationContainer.eventSpeed)
  return p != NULL ? *p : *reinterpret_cast<const ::Speed*>(
      &::_Speed_default_instance_);
}
inline ::Speed* LocationContainer::release_eventspeed() {
  // @@protoc_insertion_point(field_release:LocationContainer.eventSpeed)
  clear_has_eventspeed();
  ::Speed* temp = eventspeed_;
  eventspeed_ = NULL;
  return temp;
}
inline ::Speed* LocationContainer::mutable_eventspeed() {
  set_has_eventspeed();
  if (eventspeed_ == NULL) {
    auto* p = CreateMaybeMessage<::Speed>(GetArenaNoVirtual());
    eventspeed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:LocationContainer.eventSpeed)
  return eventspeed_;
}
inline void LocationContainer::set_allocated_eventspeed(::Speed* eventspeed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventspeed_);
  }
  if (eventspeed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eventspeed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventspeed, submessage_arena);
    }
    set_has_eventspeed();
  } else {
    clear_has_eventspeed();
  }
  eventspeed_ = eventspeed;
  // @@protoc_insertion_point(field_set_allocated:LocationContainer.eventSpeed)
}

// optional .Heading eventPositionHeading = 2;
inline bool LocationContainer::has_eventpositionheading() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationContainer::set_has_eventpositionheading() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationContainer::clear_has_eventpositionheading() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Heading& LocationContainer::_internal_eventpositionheading() const {
  return *eventpositionheading_;
}
inline const ::Heading& LocationContainer::eventpositionheading() const {
  const ::Heading* p = eventpositionheading_;
  // @@protoc_insertion_point(field_get:LocationContainer.eventPositionHeading)
  return p != NULL ? *p : *reinterpret_cast<const ::Heading*>(
      &::_Heading_default_instance_);
}
inline ::Heading* LocationContainer::release_eventpositionheading() {
  // @@protoc_insertion_point(field_release:LocationContainer.eventPositionHeading)
  clear_has_eventpositionheading();
  ::Heading* temp = eventpositionheading_;
  eventpositionheading_ = NULL;
  return temp;
}
inline ::Heading* LocationContainer::mutable_eventpositionheading() {
  set_has_eventpositionheading();
  if (eventpositionheading_ == NULL) {
    auto* p = CreateMaybeMessage<::Heading>(GetArenaNoVirtual());
    eventpositionheading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:LocationContainer.eventPositionHeading)
  return eventpositionheading_;
}
inline void LocationContainer::set_allocated_eventpositionheading(::Heading* eventpositionheading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventpositionheading_);
  }
  if (eventpositionheading) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eventpositionheading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventpositionheading, submessage_arena);
    }
    set_has_eventpositionheading();
  } else {
    clear_has_eventpositionheading();
  }
  eventpositionheading_ = eventpositionheading;
  // @@protoc_insertion_point(field_set_allocated:LocationContainer.eventPositionHeading)
}

// required uint32 traces = 3;
inline bool LocationContainer::has_traces() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationContainer::set_has_traces() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationContainer::clear_has_traces() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationContainer::clear_traces() {
  traces_ = 0u;
  clear_has_traces();
}
inline ::google::protobuf::uint32 LocationContainer::traces() const {
  // @@protoc_insertion_point(field_get:LocationContainer.traces)
  return traces_;
}
inline void LocationContainer::set_traces(::google::protobuf::uint32 value) {
  set_has_traces();
  traces_ = value;
  // @@protoc_insertion_point(field_set:LocationContainer.traces)
}

// optional .RoadType roadType = 4;
inline bool LocationContainer::has_roadtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationContainer::set_has_roadtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationContainer::clear_has_roadtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationContainer::clear_roadtype() {
  roadtype_ = 0;
  clear_has_roadtype();
}
inline ::RoadType LocationContainer::roadtype() const {
  // @@protoc_insertion_point(field_get:LocationContainer.roadType)
  return static_cast< ::RoadType >(roadtype_);
}
inline void LocationContainer::set_roadtype(::RoadType value) {
  assert(::RoadType_IsValid(value));
  set_has_roadtype();
  roadtype_ = value;
  // @@protoc_insertion_point(field_set:LocationContainer.roadType)
}

// -------------------------------------------------------------------

// ManagementContainer

// required .ActionID actionID = 1;
inline bool ManagementContainer::has_actionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManagementContainer::set_has_actionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManagementContainer::clear_has_actionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ActionID& ManagementContainer::_internal_actionid() const {
  return *actionid_;
}
inline const ::ActionID& ManagementContainer::actionid() const {
  const ::ActionID* p = actionid_;
  // @@protoc_insertion_point(field_get:ManagementContainer.actionID)
  return p != NULL ? *p : *reinterpret_cast<const ::ActionID*>(
      &::_ActionID_default_instance_);
}
inline ::ActionID* ManagementContainer::release_actionid() {
  // @@protoc_insertion_point(field_release:ManagementContainer.actionID)
  clear_has_actionid();
  ::ActionID* temp = actionid_;
  actionid_ = NULL;
  return temp;
}
inline ::ActionID* ManagementContainer::mutable_actionid() {
  set_has_actionid();
  if (actionid_ == NULL) {
    auto* p = CreateMaybeMessage<::ActionID>(GetArenaNoVirtual());
    actionid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ManagementContainer.actionID)
  return actionid_;
}
inline void ManagementContainer::set_allocated_actionid(::ActionID* actionid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(actionid_);
  }
  if (actionid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actionid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actionid, submessage_arena);
    }
    set_has_actionid();
  } else {
    clear_has_actionid();
  }
  actionid_ = actionid;
  // @@protoc_insertion_point(field_set_allocated:ManagementContainer.actionID)
}

// required uint64 detectionTime = 2;
inline bool ManagementContainer::has_detectiontime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManagementContainer::set_has_detectiontime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManagementContainer::clear_has_detectiontime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManagementContainer::clear_detectiontime() {
  detectiontime_ = GOOGLE_ULONGLONG(0);
  clear_has_detectiontime();
}
inline ::google::protobuf::uint64 ManagementContainer::detectiontime() const {
  // @@protoc_insertion_point(field_get:ManagementContainer.detectionTime)
  return detectiontime_;
}
inline void ManagementContainer::set_detectiontime(::google::protobuf::uint64 value) {
  set_has_detectiontime();
  detectiontime_ = value;
  // @@protoc_insertion_point(field_set:ManagementContainer.detectionTime)
}

// required uint64 referenceTime = 3;
inline bool ManagementContainer::has_referencetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManagementContainer::set_has_referencetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManagementContainer::clear_has_referencetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManagementContainer::clear_referencetime() {
  referencetime_ = GOOGLE_ULONGLONG(0);
  clear_has_referencetime();
}
inline ::google::protobuf::uint64 ManagementContainer::referencetime() const {
  // @@protoc_insertion_point(field_get:ManagementContainer.referenceTime)
  return referencetime_;
}
inline void ManagementContainer::set_referencetime(::google::protobuf::uint64 value) {
  set_has_referencetime();
  referencetime_ = value;
  // @@protoc_insertion_point(field_set:ManagementContainer.referenceTime)
}

// optional .Termination termination = 4;
inline bool ManagementContainer::has_termination() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ManagementContainer::set_has_termination() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ManagementContainer::clear_has_termination() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ManagementContainer::clear_termination() {
  termination_ = 0;
  clear_has_termination();
}
inline ::Termination ManagementContainer::termination() const {
  // @@protoc_insertion_point(field_get:ManagementContainer.termination)
  return static_cast< ::Termination >(termination_);
}
inline void ManagementContainer::set_termination(::Termination value) {
  assert(::Termination_IsValid(value));
  set_has_termination();
  termination_ = value;
  // @@protoc_insertion_point(field_set:ManagementContainer.termination)
}

// required .ReferencePosition eventPosition = 5;
inline bool ManagementContainer::has_eventposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManagementContainer::set_has_eventposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManagementContainer::clear_has_eventposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ReferencePosition& ManagementContainer::_internal_eventposition() const {
  return *eventposition_;
}
inline const ::ReferencePosition& ManagementContainer::eventposition() const {
  const ::ReferencePosition* p = eventposition_;
  // @@protoc_insertion_point(field_get:ManagementContainer.eventPosition)
  return p != NULL ? *p : *reinterpret_cast<const ::ReferencePosition*>(
      &::_ReferencePosition_default_instance_);
}
inline ::ReferencePosition* ManagementContainer::release_eventposition() {
  // @@protoc_insertion_point(field_release:ManagementContainer.eventPosition)
  clear_has_eventposition();
  ::ReferencePosition* temp = eventposition_;
  eventposition_ = NULL;
  return temp;
}
inline ::ReferencePosition* ManagementContainer::mutable_eventposition() {
  set_has_eventposition();
  if (eventposition_ == NULL) {
    auto* p = CreateMaybeMessage<::ReferencePosition>(GetArenaNoVirtual());
    eventposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ManagementContainer.eventPosition)
  return eventposition_;
}
inline void ManagementContainer::set_allocated_eventposition(::ReferencePosition* eventposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventposition_);
  }
  if (eventposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eventposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventposition, submessage_arena);
    }
    set_has_eventposition();
  } else {
    clear_has_eventposition();
  }
  eventposition_ = eventposition;
  // @@protoc_insertion_point(field_set_allocated:ManagementContainer.eventPosition)
}

// optional .RelevanceDistance relevanceDistance = 6;
inline bool ManagementContainer::has_relevancedistance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ManagementContainer::set_has_relevancedistance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ManagementContainer::clear_has_relevancedistance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ManagementContainer::clear_relevancedistance() {
  relevancedistance_ = 0;
  clear_has_relevancedistance();
}
inline ::RelevanceDistance ManagementContainer::relevancedistance() const {
  // @@protoc_insertion_point(field_get:ManagementContainer.relevanceDistance)
  return static_cast< ::RelevanceDistance >(relevancedistance_);
}
inline void ManagementContainer::set_relevancedistance(::RelevanceDistance value) {
  assert(::RelevanceDistance_IsValid(value));
  set_has_relevancedistance();
  relevancedistance_ = value;
  // @@protoc_insertion_point(field_set:ManagementContainer.relevanceDistance)
}

// optional .RelevanceTrafficDirection relevanceTrafficDirection = 7;
inline bool ManagementContainer::has_relevancetrafficdirection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ManagementContainer::set_has_relevancetrafficdirection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ManagementContainer::clear_has_relevancetrafficdirection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ManagementContainer::clear_relevancetrafficdirection() {
  relevancetrafficdirection_ = 0;
  clear_has_relevancetrafficdirection();
}
inline ::RelevanceTrafficDirection ManagementContainer::relevancetrafficdirection() const {
  // @@protoc_insertion_point(field_get:ManagementContainer.relevanceTrafficDirection)
  return static_cast< ::RelevanceTrafficDirection >(relevancetrafficdirection_);
}
inline void ManagementContainer::set_relevancetrafficdirection(::RelevanceTrafficDirection value) {
  assert(::RelevanceTrafficDirection_IsValid(value));
  set_has_relevancetrafficdirection();
  relevancetrafficdirection_ = value;
  // @@protoc_insertion_point(field_set:ManagementContainer.relevanceTrafficDirection)
}

// optional uint32 validityDuration = 8 [default = 600];
inline bool ManagementContainer::has_validityduration() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ManagementContainer::set_has_validityduration() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ManagementContainer::clear_has_validityduration() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ManagementContainer::clear_validityduration() {
  validityduration_ = 600u;
  clear_has_validityduration();
}
inline ::google::protobuf::uint32 ManagementContainer::validityduration() const {
  // @@protoc_insertion_point(field_get:ManagementContainer.validityDuration)
  return validityduration_;
}
inline void ManagementContainer::set_validityduration(::google::protobuf::uint32 value) {
  set_has_validityduration();
  validityduration_ = value;
  // @@protoc_insertion_point(field_set:ManagementContainer.validityDuration)
}

// optional uint32 transmissionInterval = 9;
inline bool ManagementContainer::has_transmissioninterval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ManagementContainer::set_has_transmissioninterval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ManagementContainer::clear_has_transmissioninterval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ManagementContainer::clear_transmissioninterval() {
  transmissioninterval_ = 0u;
  clear_has_transmissioninterval();
}
inline ::google::protobuf::uint32 ManagementContainer::transmissioninterval() const {
  // @@protoc_insertion_point(field_get:ManagementContainer.transmissionInterval)
  return transmissioninterval_;
}
inline void ManagementContainer::set_transmissioninterval(::google::protobuf::uint32 value) {
  set_has_transmissioninterval();
  transmissioninterval_ = value;
  // @@protoc_insertion_point(field_set:ManagementContainer.transmissionInterval)
}

// required .StationType stationType = 10;
inline bool ManagementContainer::has_stationtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ManagementContainer::set_has_stationtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ManagementContainer::clear_has_stationtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ManagementContainer::clear_stationtype() {
  stationtype_ = 0;
  clear_has_stationtype();
}
inline ::StationType ManagementContainer::stationtype() const {
  // @@protoc_insertion_point(field_get:ManagementContainer.stationType)
  return static_cast< ::StationType >(stationtype_);
}
inline void ManagementContainer::set_stationtype(::StationType value) {
  assert(::StationType_IsValid(value));
  set_has_stationtype();
  stationtype_ = value;
  // @@protoc_insertion_point(field_set:ManagementContainer.stationType)
}

// -------------------------------------------------------------------

// RoadWorksContainerExtended

// optional .LightBarSirenInUse lightBarSirenInUse = 1;
inline bool RoadWorksContainerExtended::has_lightbarsireninuse() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoadWorksContainerExtended::set_has_lightbarsireninuse() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoadWorksContainerExtended::clear_has_lightbarsireninuse() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoadWorksContainerExtended::clear_lightbarsireninuse() {
  lightbarsireninuse_ = 0;
  clear_has_lightbarsireninuse();
}
inline ::LightBarSirenInUse RoadWorksContainerExtended::lightbarsireninuse() const {
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.lightBarSirenInUse)
  return static_cast< ::LightBarSirenInUse >(lightbarsireninuse_);
}
inline void RoadWorksContainerExtended::set_lightbarsireninuse(::LightBarSirenInUse value) {
  assert(::LightBarSirenInUse_IsValid(value));
  set_has_lightbarsireninuse();
  lightbarsireninuse_ = value;
  // @@protoc_insertion_point(field_set:RoadWorksContainerExtended.lightBarSirenInUse)
}

// optional .ClosedLanes closedLanes = 2;
inline bool RoadWorksContainerExtended::has_closedlanes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadWorksContainerExtended::set_has_closedlanes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadWorksContainerExtended::clear_has_closedlanes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ClosedLanes& RoadWorksContainerExtended::_internal_closedlanes() const {
  return *closedlanes_;
}
inline const ::ClosedLanes& RoadWorksContainerExtended::closedlanes() const {
  const ::ClosedLanes* p = closedlanes_;
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.closedLanes)
  return p != NULL ? *p : *reinterpret_cast<const ::ClosedLanes*>(
      &::_ClosedLanes_default_instance_);
}
inline ::ClosedLanes* RoadWorksContainerExtended::release_closedlanes() {
  // @@protoc_insertion_point(field_release:RoadWorksContainerExtended.closedLanes)
  clear_has_closedlanes();
  ::ClosedLanes* temp = closedlanes_;
  closedlanes_ = NULL;
  return temp;
}
inline ::ClosedLanes* RoadWorksContainerExtended::mutable_closedlanes() {
  set_has_closedlanes();
  if (closedlanes_ == NULL) {
    auto* p = CreateMaybeMessage<::ClosedLanes>(GetArenaNoVirtual());
    closedlanes_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadWorksContainerExtended.closedLanes)
  return closedlanes_;
}
inline void RoadWorksContainerExtended::set_allocated_closedlanes(::ClosedLanes* closedlanes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(closedlanes_);
  }
  if (closedlanes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      closedlanes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, closedlanes, submessage_arena);
    }
    set_has_closedlanes();
  } else {
    clear_has_closedlanes();
  }
  closedlanes_ = closedlanes;
  // @@protoc_insertion_point(field_set_allocated:RoadWorksContainerExtended.closedLanes)
}

// optional .RestrictedTypes restriction = 3;
inline bool RoadWorksContainerExtended::has_restriction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadWorksContainerExtended::set_has_restriction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadWorksContainerExtended::clear_has_restriction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::RestrictedTypes& RoadWorksContainerExtended::_internal_restriction() const {
  return *restriction_;
}
inline const ::RestrictedTypes& RoadWorksContainerExtended::restriction() const {
  const ::RestrictedTypes* p = restriction_;
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.restriction)
  return p != NULL ? *p : *reinterpret_cast<const ::RestrictedTypes*>(
      &::_RestrictedTypes_default_instance_);
}
inline ::RestrictedTypes* RoadWorksContainerExtended::release_restriction() {
  // @@protoc_insertion_point(field_release:RoadWorksContainerExtended.restriction)
  clear_has_restriction();
  ::RestrictedTypes* temp = restriction_;
  restriction_ = NULL;
  return temp;
}
inline ::RestrictedTypes* RoadWorksContainerExtended::mutable_restriction() {
  set_has_restriction();
  if (restriction_ == NULL) {
    auto* p = CreateMaybeMessage<::RestrictedTypes>(GetArenaNoVirtual());
    restriction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadWorksContainerExtended.restriction)
  return restriction_;
}
inline void RoadWorksContainerExtended::set_allocated_restriction(::RestrictedTypes* restriction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(restriction_);
  }
  if (restriction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      restriction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, restriction, submessage_arena);
    }
    set_has_restriction();
  } else {
    clear_has_restriction();
  }
  restriction_ = restriction;
  // @@protoc_insertion_point(field_set_allocated:RoadWorksContainerExtended.restriction)
}

// optional uint32 speedLimit = 4;
inline bool RoadWorksContainerExtended::has_speedlimit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoadWorksContainerExtended::set_has_speedlimit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoadWorksContainerExtended::clear_has_speedlimit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoadWorksContainerExtended::clear_speedlimit() {
  speedlimit_ = 0u;
  clear_has_speedlimit();
}
inline ::google::protobuf::uint32 RoadWorksContainerExtended::speedlimit() const {
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.speedLimit)
  return speedlimit_;
}
inline void RoadWorksContainerExtended::set_speedlimit(::google::protobuf::uint32 value) {
  set_has_speedlimit();
  speedlimit_ = value;
  // @@protoc_insertion_point(field_set:RoadWorksContainerExtended.speedLimit)
}

// optional .CauseCode incidentIndication = 5;
inline bool RoadWorksContainerExtended::has_incidentindication() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoadWorksContainerExtended::set_has_incidentindication() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoadWorksContainerExtended::clear_has_incidentindication() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CauseCode& RoadWorksContainerExtended::_internal_incidentindication() const {
  return *incidentindication_;
}
inline const ::CauseCode& RoadWorksContainerExtended::incidentindication() const {
  const ::CauseCode* p = incidentindication_;
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.incidentIndication)
  return p != NULL ? *p : *reinterpret_cast<const ::CauseCode*>(
      &::_CauseCode_default_instance_);
}
inline ::CauseCode* RoadWorksContainerExtended::release_incidentindication() {
  // @@protoc_insertion_point(field_release:RoadWorksContainerExtended.incidentIndication)
  clear_has_incidentindication();
  ::CauseCode* temp = incidentindication_;
  incidentindication_ = NULL;
  return temp;
}
inline ::CauseCode* RoadWorksContainerExtended::mutable_incidentindication() {
  set_has_incidentindication();
  if (incidentindication_ == NULL) {
    auto* p = CreateMaybeMessage<::CauseCode>(GetArenaNoVirtual());
    incidentindication_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadWorksContainerExtended.incidentIndication)
  return incidentindication_;
}
inline void RoadWorksContainerExtended::set_allocated_incidentindication(::CauseCode* incidentindication) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(incidentindication_);
  }
  if (incidentindication) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      incidentindication = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, incidentindication, submessage_arena);
    }
    set_has_incidentindication();
  } else {
    clear_has_incidentindication();
  }
  incidentindication_ = incidentindication;
  // @@protoc_insertion_point(field_set_allocated:RoadWorksContainerExtended.incidentIndication)
}

// optional .ItineraryPath recommendedPath = 6;
inline bool RoadWorksContainerExtended::has_recommendedpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoadWorksContainerExtended::set_has_recommendedpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoadWorksContainerExtended::clear_has_recommendedpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ItineraryPath& RoadWorksContainerExtended::_internal_recommendedpath() const {
  return *recommendedpath_;
}
inline const ::ItineraryPath& RoadWorksContainerExtended::recommendedpath() const {
  const ::ItineraryPath* p = recommendedpath_;
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.recommendedPath)
  return p != NULL ? *p : *reinterpret_cast<const ::ItineraryPath*>(
      &::_ItineraryPath_default_instance_);
}
inline ::ItineraryPath* RoadWorksContainerExtended::release_recommendedpath() {
  // @@protoc_insertion_point(field_release:RoadWorksContainerExtended.recommendedPath)
  clear_has_recommendedpath();
  ::ItineraryPath* temp = recommendedpath_;
  recommendedpath_ = NULL;
  return temp;
}
inline ::ItineraryPath* RoadWorksContainerExtended::mutable_recommendedpath() {
  set_has_recommendedpath();
  if (recommendedpath_ == NULL) {
    auto* p = CreateMaybeMessage<::ItineraryPath>(GetArenaNoVirtual());
    recommendedpath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadWorksContainerExtended.recommendedPath)
  return recommendedpath_;
}
inline void RoadWorksContainerExtended::set_allocated_recommendedpath(::ItineraryPath* recommendedpath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(recommendedpath_);
  }
  if (recommendedpath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      recommendedpath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, recommendedpath, submessage_arena);
    }
    set_has_recommendedpath();
  } else {
    clear_has_recommendedpath();
  }
  recommendedpath_ = recommendedpath;
  // @@protoc_insertion_point(field_set_allocated:RoadWorksContainerExtended.recommendedPath)
}

// optional .DeltaReferencePosition startingPointSpeedLimit = 7;
inline bool RoadWorksContainerExtended::has_startingpointspeedlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoadWorksContainerExtended::set_has_startingpointspeedlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoadWorksContainerExtended::clear_has_startingpointspeedlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::DeltaReferencePosition& RoadWorksContainerExtended::_internal_startingpointspeedlimit() const {
  return *startingpointspeedlimit_;
}
inline const ::DeltaReferencePosition& RoadWorksContainerExtended::startingpointspeedlimit() const {
  const ::DeltaReferencePosition* p = startingpointspeedlimit_;
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.startingPointSpeedLimit)
  return p != NULL ? *p : *reinterpret_cast<const ::DeltaReferencePosition*>(
      &::_DeltaReferencePosition_default_instance_);
}
inline ::DeltaReferencePosition* RoadWorksContainerExtended::release_startingpointspeedlimit() {
  // @@protoc_insertion_point(field_release:RoadWorksContainerExtended.startingPointSpeedLimit)
  clear_has_startingpointspeedlimit();
  ::DeltaReferencePosition* temp = startingpointspeedlimit_;
  startingpointspeedlimit_ = NULL;
  return temp;
}
inline ::DeltaReferencePosition* RoadWorksContainerExtended::mutable_startingpointspeedlimit() {
  set_has_startingpointspeedlimit();
  if (startingpointspeedlimit_ == NULL) {
    auto* p = CreateMaybeMessage<::DeltaReferencePosition>(GetArenaNoVirtual());
    startingpointspeedlimit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadWorksContainerExtended.startingPointSpeedLimit)
  return startingpointspeedlimit_;
}
inline void RoadWorksContainerExtended::set_allocated_startingpointspeedlimit(::DeltaReferencePosition* startingpointspeedlimit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(startingpointspeedlimit_);
  }
  if (startingpointspeedlimit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      startingpointspeedlimit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, startingpointspeedlimit, submessage_arena);
    }
    set_has_startingpointspeedlimit();
  } else {
    clear_has_startingpointspeedlimit();
  }
  startingpointspeedlimit_ = startingpointspeedlimit;
  // @@protoc_insertion_point(field_set_allocated:RoadWorksContainerExtended.startingPointSpeedLimit)
}

// optional .TrafficRule trafficFlowRule = 8;
inline bool RoadWorksContainerExtended::has_trafficflowrule() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoadWorksContainerExtended::set_has_trafficflowrule() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoadWorksContainerExtended::clear_has_trafficflowrule() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoadWorksContainerExtended::clear_trafficflowrule() {
  trafficflowrule_ = 0;
  clear_has_trafficflowrule();
}
inline ::TrafficRule RoadWorksContainerExtended::trafficflowrule() const {
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.trafficFlowRule)
  return static_cast< ::TrafficRule >(trafficflowrule_);
}
inline void RoadWorksContainerExtended::set_trafficflowrule(::TrafficRule value) {
  assert(::TrafficRule_IsValid(value));
  set_has_trafficflowrule();
  trafficflowrule_ = value;
  // @@protoc_insertion_point(field_set:RoadWorksContainerExtended.trafficFlowRule)
}

// optional .ReferenceDenms referenceDenms = 9;
inline bool RoadWorksContainerExtended::has_referencedenms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoadWorksContainerExtended::set_has_referencedenms() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoadWorksContainerExtended::clear_has_referencedenms() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ReferenceDenms& RoadWorksContainerExtended::_internal_referencedenms() const {
  return *referencedenms_;
}
inline const ::ReferenceDenms& RoadWorksContainerExtended::referencedenms() const {
  const ::ReferenceDenms* p = referencedenms_;
  // @@protoc_insertion_point(field_get:RoadWorksContainerExtended.referenceDenms)
  return p != NULL ? *p : *reinterpret_cast<const ::ReferenceDenms*>(
      &::_ReferenceDenms_default_instance_);
}
inline ::ReferenceDenms* RoadWorksContainerExtended::release_referencedenms() {
  // @@protoc_insertion_point(field_release:RoadWorksContainerExtended.referenceDenms)
  clear_has_referencedenms();
  ::ReferenceDenms* temp = referencedenms_;
  referencedenms_ = NULL;
  return temp;
}
inline ::ReferenceDenms* RoadWorksContainerExtended::mutable_referencedenms() {
  set_has_referencedenms();
  if (referencedenms_ == NULL) {
    auto* p = CreateMaybeMessage<::ReferenceDenms>(GetArenaNoVirtual());
    referencedenms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RoadWorksContainerExtended.referenceDenms)
  return referencedenms_;
}
inline void RoadWorksContainerExtended::set_allocated_referencedenms(::ReferenceDenms* referencedenms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(referencedenms_);
  }
  if (referencedenms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      referencedenms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, referencedenms, submessage_arena);
    }
    set_has_referencedenms();
  } else {
    clear_has_referencedenms();
  }
  referencedenms_ = referencedenms;
  // @@protoc_insertion_point(field_set_allocated:RoadWorksContainerExtended.referenceDenms)
}

// -------------------------------------------------------------------

// SituationContainer

// required uint32 informationQuality = 1;
inline bool SituationContainer::has_informationquality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SituationContainer::set_has_informationquality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SituationContainer::clear_has_informationquality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SituationContainer::clear_informationquality() {
  informationquality_ = 0u;
  clear_has_informationquality();
}
inline ::google::protobuf::uint32 SituationContainer::informationquality() const {
  // @@protoc_insertion_point(field_get:SituationContainer.informationQuality)
  return informationquality_;
}
inline void SituationContainer::set_informationquality(::google::protobuf::uint32 value) {
  set_has_informationquality();
  informationquality_ = value;
  // @@protoc_insertion_point(field_set:SituationContainer.informationQuality)
}

// required .CauseCode eventType = 2;
inline bool SituationContainer::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SituationContainer::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SituationContainer::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CauseCode& SituationContainer::_internal_eventtype() const {
  return *eventtype_;
}
inline const ::CauseCode& SituationContainer::eventtype() const {
  const ::CauseCode* p = eventtype_;
  // @@protoc_insertion_point(field_get:SituationContainer.eventType)
  return p != NULL ? *p : *reinterpret_cast<const ::CauseCode*>(
      &::_CauseCode_default_instance_);
}
inline ::CauseCode* SituationContainer::release_eventtype() {
  // @@protoc_insertion_point(field_release:SituationContainer.eventType)
  clear_has_eventtype();
  ::CauseCode* temp = eventtype_;
  eventtype_ = NULL;
  return temp;
}
inline ::CauseCode* SituationContainer::mutable_eventtype() {
  set_has_eventtype();
  if (eventtype_ == NULL) {
    auto* p = CreateMaybeMessage<::CauseCode>(GetArenaNoVirtual());
    eventtype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SituationContainer.eventType)
  return eventtype_;
}
inline void SituationContainer::set_allocated_eventtype(::CauseCode* eventtype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventtype_);
  }
  if (eventtype) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eventtype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventtype, submessage_arena);
    }
    set_has_eventtype();
  } else {
    clear_has_eventtype();
  }
  eventtype_ = eventtype;
  // @@protoc_insertion_point(field_set_allocated:SituationContainer.eventType)
}

// optional .CauseCode linkedCause = 3;
inline bool SituationContainer::has_linkedcause() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SituationContainer::set_has_linkedcause() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SituationContainer::clear_has_linkedcause() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::CauseCode& SituationContainer::_internal_linkedcause() const {
  return *linkedcause_;
}
inline const ::CauseCode& SituationContainer::linkedcause() const {
  const ::CauseCode* p = linkedcause_;
  // @@protoc_insertion_point(field_get:SituationContainer.linkedCause)
  return p != NULL ? *p : *reinterpret_cast<const ::CauseCode*>(
      &::_CauseCode_default_instance_);
}
inline ::CauseCode* SituationContainer::release_linkedcause() {
  // @@protoc_insertion_point(field_release:SituationContainer.linkedCause)
  clear_has_linkedcause();
  ::CauseCode* temp = linkedcause_;
  linkedcause_ = NULL;
  return temp;
}
inline ::CauseCode* SituationContainer::mutable_linkedcause() {
  set_has_linkedcause();
  if (linkedcause_ == NULL) {
    auto* p = CreateMaybeMessage<::CauseCode>(GetArenaNoVirtual());
    linkedcause_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SituationContainer.linkedCause)
  return linkedcause_;
}
inline void SituationContainer::set_allocated_linkedcause(::CauseCode* linkedcause) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(linkedcause_);
  }
  if (linkedcause) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linkedcause = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linkedcause, submessage_arena);
    }
    set_has_linkedcause();
  } else {
    clear_has_linkedcause();
  }
  linkedcause_ = linkedcause;
  // @@protoc_insertion_point(field_set_allocated:SituationContainer.linkedCause)
}

// optional .EventHistory eventHistory = 4;
inline bool SituationContainer::has_eventhistory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SituationContainer::set_has_eventhistory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SituationContainer::clear_has_eventhistory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::EventHistory& SituationContainer::_internal_eventhistory() const {
  return *eventhistory_;
}
inline const ::EventHistory& SituationContainer::eventhistory() const {
  const ::EventHistory* p = eventhistory_;
  // @@protoc_insertion_point(field_get:SituationContainer.eventHistory)
  return p != NULL ? *p : *reinterpret_cast<const ::EventHistory*>(
      &::_EventHistory_default_instance_);
}
inline ::EventHistory* SituationContainer::release_eventhistory() {
  // @@protoc_insertion_point(field_release:SituationContainer.eventHistory)
  clear_has_eventhistory();
  ::EventHistory* temp = eventhistory_;
  eventhistory_ = NULL;
  return temp;
}
inline ::EventHistory* SituationContainer::mutable_eventhistory() {
  set_has_eventhistory();
  if (eventhistory_ == NULL) {
    auto* p = CreateMaybeMessage<::EventHistory>(GetArenaNoVirtual());
    eventhistory_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SituationContainer.eventHistory)
  return eventhistory_;
}
inline void SituationContainer::set_allocated_eventhistory(::EventHistory* eventhistory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(eventhistory_);
  }
  if (eventhistory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eventhistory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventhistory, submessage_arena);
    }
    set_has_eventhistory();
  } else {
    clear_has_eventhistory();
  }
  eventhistory_ = eventhistory;
  // @@protoc_insertion_point(field_set_allocated:SituationContainer.eventHistory)
}

// -------------------------------------------------------------------

// StationaryVehicleContainer

// optional .StationarySince stationarySince = 1;
inline bool StationaryVehicleContainer::has_stationarysince() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StationaryVehicleContainer::set_has_stationarysince() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StationaryVehicleContainer::clear_has_stationarysince() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StationaryVehicleContainer::clear_stationarysince() {
  stationarysince_ = 0;
  clear_has_stationarysince();
}
inline ::StationarySince StationaryVehicleContainer::stationarysince() const {
  // @@protoc_insertion_point(field_get:StationaryVehicleContainer.stationarySince)
  return static_cast< ::StationarySince >(stationarysince_);
}
inline void StationaryVehicleContainer::set_stationarysince(::StationarySince value) {
  assert(::StationarySince_IsValid(value));
  set_has_stationarysince();
  stationarysince_ = value;
  // @@protoc_insertion_point(field_set:StationaryVehicleContainer.stationarySince)
}

// optional .CauseCode stationaryCause = 2;
inline bool StationaryVehicleContainer::has_stationarycause() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StationaryVehicleContainer::set_has_stationarycause() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StationaryVehicleContainer::clear_has_stationarycause() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CauseCode& StationaryVehicleContainer::_internal_stationarycause() const {
  return *stationarycause_;
}
inline const ::CauseCode& StationaryVehicleContainer::stationarycause() const {
  const ::CauseCode* p = stationarycause_;
  // @@protoc_insertion_point(field_get:StationaryVehicleContainer.stationaryCause)
  return p != NULL ? *p : *reinterpret_cast<const ::CauseCode*>(
      &::_CauseCode_default_instance_);
}
inline ::CauseCode* StationaryVehicleContainer::release_stationarycause() {
  // @@protoc_insertion_point(field_release:StationaryVehicleContainer.stationaryCause)
  clear_has_stationarycause();
  ::CauseCode* temp = stationarycause_;
  stationarycause_ = NULL;
  return temp;
}
inline ::CauseCode* StationaryVehicleContainer::mutable_stationarycause() {
  set_has_stationarycause();
  if (stationarycause_ == NULL) {
    auto* p = CreateMaybeMessage<::CauseCode>(GetArenaNoVirtual());
    stationarycause_ = p;
  }
  // @@protoc_insertion_point(field_mutable:StationaryVehicleContainer.stationaryCause)
  return stationarycause_;
}
inline void StationaryVehicleContainer::set_allocated_stationarycause(::CauseCode* stationarycause) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(stationarycause_);
  }
  if (stationarycause) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stationarycause = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stationarycause, submessage_arena);
    }
    set_has_stationarycause();
  } else {
    clear_has_stationarycause();
  }
  stationarycause_ = stationarycause;
  // @@protoc_insertion_point(field_set_allocated:StationaryVehicleContainer.stationaryCause)
}

// optional .DangerousGoodsExtended carryingDangerousGoods = 3;
inline bool StationaryVehicleContainer::has_carryingdangerousgoods() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StationaryVehicleContainer::set_has_carryingdangerousgoods() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StationaryVehicleContainer::clear_has_carryingdangerousgoods() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::DangerousGoodsExtended& StationaryVehicleContainer::_internal_carryingdangerousgoods() const {
  return *carryingdangerousgoods_;
}
inline const ::DangerousGoodsExtended& StationaryVehicleContainer::carryingdangerousgoods() const {
  const ::DangerousGoodsExtended* p = carryingdangerousgoods_;
  // @@protoc_insertion_point(field_get:StationaryVehicleContainer.carryingDangerousGoods)
  return p != NULL ? *p : *reinterpret_cast<const ::DangerousGoodsExtended*>(
      &::_DangerousGoodsExtended_default_instance_);
}
inline ::DangerousGoodsExtended* StationaryVehicleContainer::release_carryingdangerousgoods() {
  // @@protoc_insertion_point(field_release:StationaryVehicleContainer.carryingDangerousGoods)
  clear_has_carryingdangerousgoods();
  ::DangerousGoodsExtended* temp = carryingdangerousgoods_;
  carryingdangerousgoods_ = NULL;
  return temp;
}
inline ::DangerousGoodsExtended* StationaryVehicleContainer::mutable_carryingdangerousgoods() {
  set_has_carryingdangerousgoods();
  if (carryingdangerousgoods_ == NULL) {
    auto* p = CreateMaybeMessage<::DangerousGoodsExtended>(GetArenaNoVirtual());
    carryingdangerousgoods_ = p;
  }
  // @@protoc_insertion_point(field_mutable:StationaryVehicleContainer.carryingDangerousGoods)
  return carryingdangerousgoods_;
}
inline void StationaryVehicleContainer::set_allocated_carryingdangerousgoods(::DangerousGoodsExtended* carryingdangerousgoods) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(carryingdangerousgoods_);
  }
  if (carryingdangerousgoods) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      carryingdangerousgoods = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, carryingdangerousgoods, submessage_arena);
    }
    set_has_carryingdangerousgoods();
  } else {
    clear_has_carryingdangerousgoods();
  }
  carryingdangerousgoods_ = carryingdangerousgoods;
  // @@protoc_insertion_point(field_set_allocated:StationaryVehicleContainer.carryingDangerousGoods)
}

// optional uint32 numberOfOccupants = 4;
inline bool StationaryVehicleContainer::has_numberofoccupants() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StationaryVehicleContainer::set_has_numberofoccupants() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StationaryVehicleContainer::clear_has_numberofoccupants() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StationaryVehicleContainer::clear_numberofoccupants() {
  numberofoccupants_ = 0u;
  clear_has_numberofoccupants();
}
inline ::google::protobuf::uint32 StationaryVehicleContainer::numberofoccupants() const {
  // @@protoc_insertion_point(field_get:StationaryVehicleContainer.numberOfOccupants)
  return numberofoccupants_;
}
inline void StationaryVehicleContainer::set_numberofoccupants(::google::protobuf::uint32 value) {
  set_has_numberofoccupants();
  numberofoccupants_ = value;
  // @@protoc_insertion_point(field_set:StationaryVehicleContainer.numberOfOccupants)
}

// optional .VehicleIdentification vehicleIdentification = 5;
inline bool StationaryVehicleContainer::has_vehicleidentification() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StationaryVehicleContainer::set_has_vehicleidentification() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StationaryVehicleContainer::clear_has_vehicleidentification() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::VehicleIdentification& StationaryVehicleContainer::_internal_vehicleidentification() const {
  return *vehicleidentification_;
}
inline const ::VehicleIdentification& StationaryVehicleContainer::vehicleidentification() const {
  const ::VehicleIdentification* p = vehicleidentification_;
  // @@protoc_insertion_point(field_get:StationaryVehicleContainer.vehicleIdentification)
  return p != NULL ? *p : *reinterpret_cast<const ::VehicleIdentification*>(
      &::_VehicleIdentification_default_instance_);
}
inline ::VehicleIdentification* StationaryVehicleContainer::release_vehicleidentification() {
  // @@protoc_insertion_point(field_release:StationaryVehicleContainer.vehicleIdentification)
  clear_has_vehicleidentification();
  ::VehicleIdentification* temp = vehicleidentification_;
  vehicleidentification_ = NULL;
  return temp;
}
inline ::VehicleIdentification* StationaryVehicleContainer::mutable_vehicleidentification() {
  set_has_vehicleidentification();
  if (vehicleidentification_ == NULL) {
    auto* p = CreateMaybeMessage<::VehicleIdentification>(GetArenaNoVirtual());
    vehicleidentification_ = p;
  }
  // @@protoc_insertion_point(field_mutable:StationaryVehicleContainer.vehicleIdentification)
  return vehicleidentification_;
}
inline void StationaryVehicleContainer::set_allocated_vehicleidentification(::VehicleIdentification* vehicleidentification) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(vehicleidentification_);
  }
  if (vehicleidentification) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicleidentification = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicleidentification, submessage_arena);
    }
    set_has_vehicleidentification();
  } else {
    clear_has_vehicleidentification();
  }
  vehicleidentification_ = vehicleidentification;
  // @@protoc_insertion_point(field_set_allocated:StationaryVehicleContainer.vehicleIdentification)
}

// optional .EnergyStorageType energyStorageType = 6;
inline bool StationaryVehicleContainer::has_energystoragetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StationaryVehicleContainer::set_has_energystoragetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StationaryVehicleContainer::clear_has_energystoragetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::EnergyStorageType& StationaryVehicleContainer::_internal_energystoragetype() const {
  return *energystoragetype_;
}
inline const ::EnergyStorageType& StationaryVehicleContainer::energystoragetype() const {
  const ::EnergyStorageType* p = energystoragetype_;
  // @@protoc_insertion_point(field_get:StationaryVehicleContainer.energyStorageType)
  return p != NULL ? *p : *reinterpret_cast<const ::EnergyStorageType*>(
      &::_EnergyStorageType_default_instance_);
}
inline ::EnergyStorageType* StationaryVehicleContainer::release_energystoragetype() {
  // @@protoc_insertion_point(field_release:StationaryVehicleContainer.energyStorageType)
  clear_has_energystoragetype();
  ::EnergyStorageType* temp = energystoragetype_;
  energystoragetype_ = NULL;
  return temp;
}
inline ::EnergyStorageType* StationaryVehicleContainer::mutable_energystoragetype() {
  set_has_energystoragetype();
  if (energystoragetype_ == NULL) {
    auto* p = CreateMaybeMessage<::EnergyStorageType>(GetArenaNoVirtual());
    energystoragetype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:StationaryVehicleContainer.energyStorageType)
  return energystoragetype_;
}
inline void StationaryVehicleContainer::set_allocated_energystoragetype(::EnergyStorageType* energystoragetype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(energystoragetype_);
  }
  if (energystoragetype) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      energystoragetype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, energystoragetype, submessage_arena);
    }
    set_has_energystoragetype();
  } else {
    clear_has_energystoragetype();
  }
  energystoragetype_ = energystoragetype;
  // @@protoc_insertion_point(field_set_allocated:StationaryVehicleContainer.energyStorageType)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Termination> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Termination>() {
  return ::Termination_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_denm_5finterface_2eproto
