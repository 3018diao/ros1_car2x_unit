// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cpm_interface.proto

#ifndef PROTOBUF_INCLUDED_cpm_5finterface_2eproto
#define PROTOBUF_INCLUDED_cpm_5finterface_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "itspduheader_interface.pb.h"  // IWYU pragma: export
#include "etsi_its_cdd.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_cpm_5finterface_2eproto 

namespace protobuf_cpm_5finterface_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_cpm_5finterface_2eproto
class CPMessage;
class CPMessageDefaultTypeInternal;
extern CPMessageDefaultTypeInternal _CPMessage_default_instance_;
class CpmPayload;
class CpmPayloadDefaultTypeInternal;
extern CpmPayloadDefaultTypeInternal _CpmPayload_default_instance_;
class ManagmentContainer;
class ManagmentContainerDefaultTypeInternal;
extern ManagmentContainerDefaultTypeInternal _ManagmentContainer_default_instance_;
class MessageRateRange;
class MessageRateRangeDefaultTypeInternal;
extern MessageRateRangeDefaultTypeInternal _MessageRateRange_default_instance_;
class OriginatingRSUContainer;
class OriginatingRSUContainerDefaultTypeInternal;
extern OriginatingRSUContainerDefaultTypeInternal _OriginatingRSUContainer_default_instance_;
class OriginatingStationsContainer;
class OriginatingStationsContainerDefaultTypeInternal;
extern OriginatingStationsContainerDefaultTypeInternal _OriginatingStationsContainer_default_instance_;
class OriginatingVehicleContainer;
class OriginatingVehicleContainerDefaultTypeInternal;
extern OriginatingVehicleContainerDefaultTypeInternal _OriginatingVehicleContainer_default_instance_;
class PerceivedObject;
class PerceivedObjectDefaultTypeInternal;
extern PerceivedObjectDefaultTypeInternal _PerceivedObject_default_instance_;
class PerceivedObjectContainer;
class PerceivedObjectContainerDefaultTypeInternal;
extern PerceivedObjectContainerDefaultTypeInternal _PerceivedObjectContainer_default_instance_;
class PerceptionRegion;
class PerceptionRegionDefaultTypeInternal;
extern PerceptionRegionDefaultTypeInternal _PerceptionRegion_default_instance_;
class PerceptionRegionContainer;
class PerceptionRegionContainerDefaultTypeInternal;
extern PerceptionRegionContainerDefaultTypeInternal _PerceptionRegionContainer_default_instance_;
class SensorInformation;
class SensorInformationDefaultTypeInternal;
extern SensorInformationDefaultTypeInternal _SensorInformation_default_instance_;
class SensorInformationContainer;
class SensorInformationContainerDefaultTypeInternal;
extern SensorInformationContainerDefaultTypeInternal _SensorInformationContainer_default_instance_;
namespace google {
namespace protobuf {
template<> ::CPMessage* Arena::CreateMaybeMessage<::CPMessage>(Arena*);
template<> ::CpmPayload* Arena::CreateMaybeMessage<::CpmPayload>(Arena*);
template<> ::ManagmentContainer* Arena::CreateMaybeMessage<::ManagmentContainer>(Arena*);
template<> ::MessageRateRange* Arena::CreateMaybeMessage<::MessageRateRange>(Arena*);
template<> ::OriginatingRSUContainer* Arena::CreateMaybeMessage<::OriginatingRSUContainer>(Arena*);
template<> ::OriginatingStationsContainer* Arena::CreateMaybeMessage<::OriginatingStationsContainer>(Arena*);
template<> ::OriginatingVehicleContainer* Arena::CreateMaybeMessage<::OriginatingVehicleContainer>(Arena*);
template<> ::PerceivedObject* Arena::CreateMaybeMessage<::PerceivedObject>(Arena*);
template<> ::PerceivedObjectContainer* Arena::CreateMaybeMessage<::PerceivedObjectContainer>(Arena*);
template<> ::PerceptionRegion* Arena::CreateMaybeMessage<::PerceptionRegion>(Arena*);
template<> ::PerceptionRegionContainer* Arena::CreateMaybeMessage<::PerceptionRegionContainer>(Arena*);
template<> ::SensorInformation* Arena::CreateMaybeMessage<::SensorInformation>(Arena*);
template<> ::SensorInformationContainer* Arena::CreateMaybeMessage<::SensorInformationContainer>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class CPMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CPMessage) */ {
 public:
  CPMessage();
  virtual ~CPMessage();

  CPMessage(const CPMessage& from);

  inline CPMessage& operator=(const CPMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CPMessage(CPMessage&& from) noexcept
    : CPMessage() {
    *this = ::std::move(from);
  }

  inline CPMessage& operator=(CPMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CPMessage* internal_default_instance() {
    return reinterpret_cast<const CPMessage*>(
               &_CPMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CPMessage* other);
  friend void swap(CPMessage& a, CPMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CPMessage* New() const final {
    return CreateMaybeMessage<CPMessage>(NULL);
  }

  CPMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CPMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CPMessage& from);
  void MergeFrom(const CPMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ItsPduHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::ItsPduHeader& _internal_header() const;
  public:
  const ::ItsPduHeader& header() const;
  ::ItsPduHeader* release_header();
  ::ItsPduHeader* mutable_header();
  void set_allocated_header(::ItsPduHeader* header);

  // required .ManagmentContainer mgmt_cntnr = 3;
  bool has_mgmt_cntnr() const;
  void clear_mgmt_cntnr();
  static const int kMgmtCntnrFieldNumber = 3;
  private:
  const ::ManagmentContainer& _internal_mgmt_cntnr() const;
  public:
  const ::ManagmentContainer& mgmt_cntnr() const;
  ::ManagmentContainer* release_mgmt_cntnr();
  ::ManagmentContainer* mutable_mgmt_cntnr();
  void set_allocated_mgmt_cntnr(::ManagmentContainer* mgmt_cntnr);

  // required .CpmPayload cpm_payload = 4;
  bool has_cpm_payload() const;
  void clear_cpm_payload();
  static const int kCpmPayloadFieldNumber = 4;
  private:
  const ::CpmPayload& _internal_cpm_payload() const;
  public:
  const ::CpmPayload& cpm_payload() const;
  ::CpmPayload* release_cpm_payload();
  ::CpmPayload* mutable_cpm_payload();
  void set_allocated_cpm_payload(::CpmPayload* cpm_payload);

  // required uint64 generation_delta_time = 2;
  bool has_generation_delta_time() const;
  void clear_generation_delta_time();
  static const int kGenerationDeltaTimeFieldNumber = 2;
  ::google::protobuf::uint64 generation_delta_time() const;
  void set_generation_delta_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CPMessage)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_generation_delta_time();
  void clear_has_generation_delta_time();
  void set_has_mgmt_cntnr();
  void clear_has_mgmt_cntnr();
  void set_has_cpm_payload();
  void clear_has_cpm_payload();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ItsPduHeader* header_;
  ::ManagmentContainer* mgmt_cntnr_;
  ::CpmPayload* cpm_payload_;
  ::google::protobuf::uint64 generation_delta_time_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CpmPayload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CpmPayload) */ {
 public:
  CpmPayload();
  virtual ~CpmPayload();

  CpmPayload(const CpmPayload& from);

  inline CpmPayload& operator=(const CpmPayload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CpmPayload(CpmPayload&& from) noexcept
    : CpmPayload() {
    *this = ::std::move(from);
  }

  inline CpmPayload& operator=(CpmPayload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpmPayload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CpmPayload* internal_default_instance() {
    return reinterpret_cast<const CpmPayload*>(
               &_CpmPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CpmPayload* other);
  friend void swap(CpmPayload& a, CpmPayload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CpmPayload* New() const final {
    return CreateMaybeMessage<CpmPayload>(NULL);
  }

  CpmPayload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CpmPayload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CpmPayload& from);
  void MergeFrom(const CpmPayload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CpmPayload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .OriginatingStationsContainer org_stn_cntr = 1;
  bool has_org_stn_cntr() const;
  void clear_org_stn_cntr();
  static const int kOrgStnCntrFieldNumber = 1;
  private:
  const ::OriginatingStationsContainer& _internal_org_stn_cntr() const;
  public:
  const ::OriginatingStationsContainer& org_stn_cntr() const;
  ::OriginatingStationsContainer* release_org_stn_cntr();
  ::OriginatingStationsContainer* mutable_org_stn_cntr();
  void set_allocated_org_stn_cntr(::OriginatingStationsContainer* org_stn_cntr);

  // required .SensorInformationContainer snsr_info_cntr = 2;
  bool has_snsr_info_cntr() const;
  void clear_snsr_info_cntr();
  static const int kSnsrInfoCntrFieldNumber = 2;
  private:
  const ::SensorInformationContainer& _internal_snsr_info_cntr() const;
  public:
  const ::SensorInformationContainer& snsr_info_cntr() const;
  ::SensorInformationContainer* release_snsr_info_cntr();
  ::SensorInformationContainer* mutable_snsr_info_cntr();
  void set_allocated_snsr_info_cntr(::SensorInformationContainer* snsr_info_cntr);

  // required .PerceptionRegionContainer prcptn_rgn_cntr = 3;
  bool has_prcptn_rgn_cntr() const;
  void clear_prcptn_rgn_cntr();
  static const int kPrcptnRgnCntrFieldNumber = 3;
  private:
  const ::PerceptionRegionContainer& _internal_prcptn_rgn_cntr() const;
  public:
  const ::PerceptionRegionContainer& prcptn_rgn_cntr() const;
  ::PerceptionRegionContainer* release_prcptn_rgn_cntr();
  ::PerceptionRegionContainer* mutable_prcptn_rgn_cntr();
  void set_allocated_prcptn_rgn_cntr(::PerceptionRegionContainer* prcptn_rgn_cntr);

  // required .PerceivedObjectContainer prcvd_obj_cntr = 4;
  bool has_prcvd_obj_cntr() const;
  void clear_prcvd_obj_cntr();
  static const int kPrcvdObjCntrFieldNumber = 4;
  private:
  const ::PerceivedObjectContainer& _internal_prcvd_obj_cntr() const;
  public:
  const ::PerceivedObjectContainer& prcvd_obj_cntr() const;
  ::PerceivedObjectContainer* release_prcvd_obj_cntr();
  ::PerceivedObjectContainer* mutable_prcvd_obj_cntr();
  void set_allocated_prcvd_obj_cntr(::PerceivedObjectContainer* prcvd_obj_cntr);

  // @@protoc_insertion_point(class_scope:CpmPayload)
 private:
  void set_has_org_stn_cntr();
  void clear_has_org_stn_cntr();
  void set_has_snsr_info_cntr();
  void clear_has_snsr_info_cntr();
  void set_has_prcptn_rgn_cntr();
  void clear_has_prcptn_rgn_cntr();
  void set_has_prcvd_obj_cntr();
  void clear_has_prcvd_obj_cntr();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::OriginatingStationsContainer* org_stn_cntr_;
  ::SensorInformationContainer* snsr_info_cntr_;
  ::PerceptionRegionContainer* prcptn_rgn_cntr_;
  ::PerceivedObjectContainer* prcvd_obj_cntr_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ManagmentContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ManagmentContainer) */ {
 public:
  ManagmentContainer();
  virtual ~ManagmentContainer();

  ManagmentContainer(const ManagmentContainer& from);

  inline ManagmentContainer& operator=(const ManagmentContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ManagmentContainer(ManagmentContainer&& from) noexcept
    : ManagmentContainer() {
    *this = ::std::move(from);
  }

  inline ManagmentContainer& operator=(ManagmentContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManagmentContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ManagmentContainer* internal_default_instance() {
    return reinterpret_cast<const ManagmentContainer*>(
               &_ManagmentContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ManagmentContainer* other);
  friend void swap(ManagmentContainer& a, ManagmentContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ManagmentContainer* New() const final {
    return CreateMaybeMessage<ManagmentContainer>(NULL);
  }

  ManagmentContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ManagmentContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ManagmentContainer& from);
  void MergeFrom(const ManagmentContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManagmentContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReferencePosition referencePosition = 2;
  bool has_referenceposition() const;
  void clear_referenceposition();
  static const int kReferencePositionFieldNumber = 2;
  private:
  const ::ReferencePosition& _internal_referenceposition() const;
  public:
  const ::ReferencePosition& referenceposition() const;
  ::ReferencePosition* release_referenceposition();
  ::ReferencePosition* mutable_referenceposition();
  void set_allocated_referenceposition(::ReferencePosition* referenceposition);

  // optional .MessageSegmentationInfo segmentationInfo = 3;
  bool has_segmentationinfo() const;
  void clear_segmentationinfo();
  static const int kSegmentationInfoFieldNumber = 3;
  private:
  const ::MessageSegmentationInfo& _internal_segmentationinfo() const;
  public:
  const ::MessageSegmentationInfo& segmentationinfo() const;
  ::MessageSegmentationInfo* release_segmentationinfo();
  ::MessageSegmentationInfo* mutable_segmentationinfo();
  void set_allocated_segmentationinfo(::MessageSegmentationInfo* segmentationinfo);

  // optional .MessageRateRange messageRateRange = 4;
  bool has_messageraterange() const;
  void clear_messageraterange();
  static const int kMessageRateRangeFieldNumber = 4;
  private:
  const ::MessageRateRange& _internal_messageraterange() const;
  public:
  const ::MessageRateRange& messageraterange() const;
  ::MessageRateRange* release_messageraterange();
  ::MessageRateRange* mutable_messageraterange();
  void set_allocated_messageraterange(::MessageRateRange* messageraterange);

  // required uint64 referenceTime = 1;
  bool has_referencetime() const;
  void clear_referencetime();
  static const int kReferenceTimeFieldNumber = 1;
  ::google::protobuf::uint64 referencetime() const;
  void set_referencetime(::google::protobuf::uint64 value);

  // optional .StationType stationtype = 5;
  bool has_stationtype() const;
  void clear_stationtype();
  static const int kStationtypeFieldNumber = 5;
  ::StationType stationtype() const;
  void set_stationtype(::StationType value);

  // @@protoc_insertion_point(class_scope:ManagmentContainer)
 private:
  void set_has_referencetime();
  void clear_has_referencetime();
  void set_has_referenceposition();
  void clear_has_referenceposition();
  void set_has_segmentationinfo();
  void clear_has_segmentationinfo();
  void set_has_messageraterange();
  void clear_has_messageraterange();
  void set_has_stationtype();
  void clear_has_stationtype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ReferencePosition* referenceposition_;
  ::MessageSegmentationInfo* segmentationinfo_;
  ::MessageRateRange* messageraterange_;
  ::google::protobuf::uint64 referencetime_;
  int stationtype_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageRateRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageRateRange) */ {
 public:
  MessageRateRange();
  virtual ~MessageRateRange();

  MessageRateRange(const MessageRateRange& from);

  inline MessageRateRange& operator=(const MessageRateRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageRateRange(MessageRateRange&& from) noexcept
    : MessageRateRange() {
    *this = ::std::move(from);
  }

  inline MessageRateRange& operator=(MessageRateRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageRateRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageRateRange* internal_default_instance() {
    return reinterpret_cast<const MessageRateRange*>(
               &_MessageRateRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MessageRateRange* other);
  friend void swap(MessageRateRange& a, MessageRateRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageRateRange* New() const final {
    return CreateMaybeMessage<MessageRateRange>(NULL);
  }

  MessageRateRange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageRateRange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageRateRange& from);
  void MergeFrom(const MessageRateRange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageRateRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MessageRateHz messageRateMin = 1;
  bool has_messageratemin() const;
  void clear_messageratemin();
  static const int kMessageRateMinFieldNumber = 1;
  private:
  const ::MessageRateHz& _internal_messageratemin() const;
  public:
  const ::MessageRateHz& messageratemin() const;
  ::MessageRateHz* release_messageratemin();
  ::MessageRateHz* mutable_messageratemin();
  void set_allocated_messageratemin(::MessageRateHz* messageratemin);

  // required .MessageRateHz messageRateMax = 2;
  bool has_messageratemax() const;
  void clear_messageratemax();
  static const int kMessageRateMaxFieldNumber = 2;
  private:
  const ::MessageRateHz& _internal_messageratemax() const;
  public:
  const ::MessageRateHz& messageratemax() const;
  ::MessageRateHz* release_messageratemax();
  ::MessageRateHz* mutable_messageratemax();
  void set_allocated_messageratemax(::MessageRateHz* messageratemax);

  // @@protoc_insertion_point(class_scope:MessageRateRange)
 private:
  void set_has_messageratemin();
  void clear_has_messageratemin();
  void set_has_messageratemax();
  void clear_has_messageratemax();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MessageRateHz* messageratemin_;
  ::MessageRateHz* messageratemax_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OriginatingStationsContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OriginatingStationsContainer) */ {
 public:
  OriginatingStationsContainer();
  virtual ~OriginatingStationsContainer();

  OriginatingStationsContainer(const OriginatingStationsContainer& from);

  inline OriginatingStationsContainer& operator=(const OriginatingStationsContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OriginatingStationsContainer(OriginatingStationsContainer&& from) noexcept
    : OriginatingStationsContainer() {
    *this = ::std::move(from);
  }

  inline OriginatingStationsContainer& operator=(OriginatingStationsContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OriginatingStationsContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OriginatingStationsContainer* internal_default_instance() {
    return reinterpret_cast<const OriginatingStationsContainer*>(
               &_OriginatingStationsContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OriginatingStationsContainer* other);
  friend void swap(OriginatingStationsContainer& a, OriginatingStationsContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OriginatingStationsContainer* New() const final {
    return CreateMaybeMessage<OriginatingStationsContainer>(NULL);
  }

  OriginatingStationsContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OriginatingStationsContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OriginatingStationsContainer& from);
  void MergeFrom(const OriginatingStationsContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OriginatingStationsContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OriginatingVehicleContainer org_veh_cntr = 1;
  bool has_org_veh_cntr() const;
  void clear_org_veh_cntr();
  static const int kOrgVehCntrFieldNumber = 1;
  private:
  const ::OriginatingVehicleContainer& _internal_org_veh_cntr() const;
  public:
  const ::OriginatingVehicleContainer& org_veh_cntr() const;
  ::OriginatingVehicleContainer* release_org_veh_cntr();
  ::OriginatingVehicleContainer* mutable_org_veh_cntr();
  void set_allocated_org_veh_cntr(::OriginatingVehicleContainer* org_veh_cntr);

  // optional .OriginatingRSUContainer org_rsu_cntr = 2;
  bool has_org_rsu_cntr() const;
  void clear_org_rsu_cntr();
  static const int kOrgRsuCntrFieldNumber = 2;
  private:
  const ::OriginatingRSUContainer& _internal_org_rsu_cntr() const;
  public:
  const ::OriginatingRSUContainer& org_rsu_cntr() const;
  ::OriginatingRSUContainer* release_org_rsu_cntr();
  ::OriginatingRSUContainer* mutable_org_rsu_cntr();
  void set_allocated_org_rsu_cntr(::OriginatingRSUContainer* org_rsu_cntr);

  // @@protoc_insertion_point(class_scope:OriginatingStationsContainer)
 private:
  void set_has_org_veh_cntr();
  void clear_has_org_veh_cntr();
  void set_has_org_rsu_cntr();
  void clear_has_org_rsu_cntr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::OriginatingVehicleContainer* org_veh_cntr_;
  ::OriginatingRSUContainer* org_rsu_cntr_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OriginatingVehicleContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OriginatingVehicleContainer) */ {
 public:
  OriginatingVehicleContainer();
  virtual ~OriginatingVehicleContainer();

  OriginatingVehicleContainer(const OriginatingVehicleContainer& from);

  inline OriginatingVehicleContainer& operator=(const OriginatingVehicleContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OriginatingVehicleContainer(OriginatingVehicleContainer&& from) noexcept
    : OriginatingVehicleContainer() {
    *this = ::std::move(from);
  }

  inline OriginatingVehicleContainer& operator=(OriginatingVehicleContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OriginatingVehicleContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OriginatingVehicleContainer* internal_default_instance() {
    return reinterpret_cast<const OriginatingVehicleContainer*>(
               &_OriginatingVehicleContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OriginatingVehicleContainer* other);
  friend void swap(OriginatingVehicleContainer& a, OriginatingVehicleContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OriginatingVehicleContainer* New() const final {
    return CreateMaybeMessage<OriginatingVehicleContainer>(NULL);
  }

  OriginatingVehicleContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OriginatingVehicleContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OriginatingVehicleContainer& from);
  void MergeFrom(const OriginatingVehicleContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OriginatingVehicleContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Wgs84Angle orientationAngle = 1;
  bool has_orientationangle() const;
  void clear_orientationangle();
  static const int kOrientationAngleFieldNumber = 1;
  private:
  const ::Wgs84Angle& _internal_orientationangle() const;
  public:
  const ::Wgs84Angle& orientationangle() const;
  ::Wgs84Angle* release_orientationangle();
  ::Wgs84Angle* mutable_orientationangle();
  void set_allocated_orientationangle(::Wgs84Angle* orientationangle);

  // optional .CartesianAngle pitchAngle = 2;
  bool has_pitchangle() const;
  void clear_pitchangle();
  static const int kPitchAngleFieldNumber = 2;
  private:
  const ::CartesianAngle& _internal_pitchangle() const;
  public:
  const ::CartesianAngle& pitchangle() const;
  ::CartesianAngle* release_pitchangle();
  ::CartesianAngle* mutable_pitchangle();
  void set_allocated_pitchangle(::CartesianAngle* pitchangle);

  // optional .CartesianAngle rollAngle = 3;
  bool has_rollangle() const;
  void clear_rollangle();
  static const int kRollAngleFieldNumber = 3;
  private:
  const ::CartesianAngle& _internal_rollangle() const;
  public:
  const ::CartesianAngle& rollangle() const;
  ::CartesianAngle* release_rollangle();
  ::CartesianAngle* mutable_rollangle();
  void set_allocated_rollangle(::CartesianAngle* rollangle);

  // optional int64 trailerDataset = 4;
  bool has_trailerdataset() const;
  void clear_trailerdataset();
  static const int kTrailerDatasetFieldNumber = 4;
  ::google::protobuf::int64 trailerdataset() const;
  void set_trailerdataset(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:OriginatingVehicleContainer)
 private:
  void set_has_orientationangle();
  void clear_has_orientationangle();
  void set_has_pitchangle();
  void clear_has_pitchangle();
  void set_has_rollangle();
  void clear_has_rollangle();
  void set_has_trailerdataset();
  void clear_has_trailerdataset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Wgs84Angle* orientationangle_;
  ::CartesianAngle* pitchangle_;
  ::CartesianAngle* rollangle_;
  ::google::protobuf::int64 trailerdataset_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OriginatingRSUContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OriginatingRSUContainer) */ {
 public:
  OriginatingRSUContainer();
  virtual ~OriginatingRSUContainer();

  OriginatingRSUContainer(const OriginatingRSUContainer& from);

  inline OriginatingRSUContainer& operator=(const OriginatingRSUContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OriginatingRSUContainer(OriginatingRSUContainer&& from) noexcept
    : OriginatingRSUContainer() {
    *this = ::std::move(from);
  }

  inline OriginatingRSUContainer& operator=(OriginatingRSUContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OriginatingRSUContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OriginatingRSUContainer* internal_default_instance() {
    return reinterpret_cast<const OriginatingRSUContainer*>(
               &_OriginatingRSUContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(OriginatingRSUContainer* other);
  friend void swap(OriginatingRSUContainer& a, OriginatingRSUContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OriginatingRSUContainer* New() const final {
    return CreateMaybeMessage<OriginatingRSUContainer>(NULL);
  }

  OriginatingRSUContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OriginatingRSUContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OriginatingRSUContainer& from);
  void MergeFrom(const OriginatingRSUContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OriginatingRSUContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RoadSegmentReferenceID roadsegment = 1;
  bool has_roadsegment() const;
  void clear_roadsegment();
  static const int kRoadsegmentFieldNumber = 1;
  private:
  const ::RoadSegmentReferenceID& _internal_roadsegment() const;
  public:
  const ::RoadSegmentReferenceID& roadsegment() const;
  ::RoadSegmentReferenceID* release_roadsegment();
  ::RoadSegmentReferenceID* mutable_roadsegment();
  void set_allocated_roadsegment(::RoadSegmentReferenceID* roadsegment);

  // required .IntersectionReferenceID intersection = 2;
  bool has_intersection() const;
  void clear_intersection();
  static const int kIntersectionFieldNumber = 2;
  private:
  const ::IntersectionReferenceID& _internal_intersection() const;
  public:
  const ::IntersectionReferenceID& intersection() const;
  ::IntersectionReferenceID* release_intersection();
  ::IntersectionReferenceID* mutable_intersection();
  void set_allocated_intersection(::IntersectionReferenceID* intersection);

  // @@protoc_insertion_point(class_scope:OriginatingRSUContainer)
 private:
  void set_has_roadsegment();
  void clear_has_roadsegment();
  void set_has_intersection();
  void clear_has_intersection();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::RoadSegmentReferenceID* roadsegment_;
  ::IntersectionReferenceID* intersection_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorInformationContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SensorInformationContainer) */ {
 public:
  SensorInformationContainer();
  virtual ~SensorInformationContainer();

  SensorInformationContainer(const SensorInformationContainer& from);

  inline SensorInformationContainer& operator=(const SensorInformationContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorInformationContainer(SensorInformationContainer&& from) noexcept
    : SensorInformationContainer() {
    *this = ::std::move(from);
  }

  inline SensorInformationContainer& operator=(SensorInformationContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorInformationContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorInformationContainer* internal_default_instance() {
    return reinterpret_cast<const SensorInformationContainer*>(
               &_SensorInformationContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SensorInformationContainer* other);
  friend void swap(SensorInformationContainer& a, SensorInformationContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorInformationContainer* New() const final {
    return CreateMaybeMessage<SensorInformationContainer>(NULL);
  }

  SensorInformationContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorInformationContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorInformationContainer& from);
  void MergeFrom(const SensorInformationContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorInformationContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SensorInformation snsr_infrmtn = 1;
  int snsr_infrmtn_size() const;
  void clear_snsr_infrmtn();
  static const int kSnsrInfrmtnFieldNumber = 1;
  ::SensorInformation* mutable_snsr_infrmtn(int index);
  ::google::protobuf::RepeatedPtrField< ::SensorInformation >*
      mutable_snsr_infrmtn();
  const ::SensorInformation& snsr_infrmtn(int index) const;
  ::SensorInformation* add_snsr_infrmtn();
  const ::google::protobuf::RepeatedPtrField< ::SensorInformation >&
      snsr_infrmtn() const;

  // @@protoc_insertion_point(class_scope:SensorInformationContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SensorInformation > snsr_infrmtn_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SensorInformation) */ {
 public:
  SensorInformation();
  virtual ~SensorInformation();

  SensorInformation(const SensorInformation& from);

  inline SensorInformation& operator=(const SensorInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorInformation(SensorInformation&& from) noexcept
    : SensorInformation() {
    *this = ::std::move(from);
  }

  inline SensorInformation& operator=(SensorInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorInformation* internal_default_instance() {
    return reinterpret_cast<const SensorInformation*>(
               &_SensorInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SensorInformation* other);
  friend void swap(SensorInformation& a, SensorInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorInformation* New() const final {
    return CreateMaybeMessage<SensorInformation>(NULL);
  }

  SensorInformation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorInformation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorInformation& from);
  void MergeFrom(const SensorInformation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Shape perception_region_shape = 3;
  bool has_perception_region_shape() const;
  void clear_perception_region_shape();
  static const int kPerceptionRegionShapeFieldNumber = 3;
  private:
  const ::Shape& _internal_perception_region_shape() const;
  public:
  const ::Shape& perception_region_shape() const;
  ::Shape* release_perception_region_shape();
  ::Shape* mutable_perception_region_shape();
  void set_allocated_perception_region_shape(::Shape* perception_region_shape);

  // required int64 sensorID = 1;
  bool has_sensorid() const;
  void clear_sensorid();
  static const int kSensorIDFieldNumber = 1;
  ::google::protobuf::int64 sensorid() const;
  void set_sensorid(::google::protobuf::int64 value);

  // required .SensorType sensor_type = 2;
  bool has_sensor_type() const;
  void clear_sensor_type();
  static const int kSensorTypeFieldNumber = 2;
  ::SensorType sensor_type() const;
  void set_sensor_type(::SensorType value);

  // optional uint32 perception_region_conf = 4;
  bool has_perception_region_conf() const;
  void clear_perception_region_conf();
  static const int kPerceptionRegionConfFieldNumber = 4;
  ::google::protobuf::uint32 perception_region_conf() const;
  void set_perception_region_conf(::google::protobuf::uint32 value);

  // required bool shadowingapplies = 5;
  bool has_shadowingapplies() const;
  void clear_shadowingapplies();
  static const int kShadowingappliesFieldNumber = 5;
  bool shadowingapplies() const;
  void set_shadowingapplies(bool value);

  // @@protoc_insertion_point(class_scope:SensorInformation)
 private:
  void set_has_sensorid();
  void clear_has_sensorid();
  void set_has_sensor_type();
  void clear_has_sensor_type();
  void set_has_perception_region_shape();
  void clear_has_perception_region_shape();
  void set_has_perception_region_conf();
  void clear_has_perception_region_conf();
  void set_has_shadowingapplies();
  void clear_has_shadowingapplies();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Shape* perception_region_shape_;
  ::google::protobuf::int64 sensorid_;
  int sensor_type_;
  ::google::protobuf::uint32 perception_region_conf_;
  bool shadowingapplies_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PerceptionRegionContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PerceptionRegionContainer) */ {
 public:
  PerceptionRegionContainer();
  virtual ~PerceptionRegionContainer();

  PerceptionRegionContainer(const PerceptionRegionContainer& from);

  inline PerceptionRegionContainer& operator=(const PerceptionRegionContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceptionRegionContainer(PerceptionRegionContainer&& from) noexcept
    : PerceptionRegionContainer() {
    *this = ::std::move(from);
  }

  inline PerceptionRegionContainer& operator=(PerceptionRegionContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptionRegionContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceptionRegionContainer* internal_default_instance() {
    return reinterpret_cast<const PerceptionRegionContainer*>(
               &_PerceptionRegionContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PerceptionRegionContainer* other);
  friend void swap(PerceptionRegionContainer& a, PerceptionRegionContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceptionRegionContainer* New() const final {
    return CreateMaybeMessage<PerceptionRegionContainer>(NULL);
  }

  PerceptionRegionContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PerceptionRegionContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PerceptionRegionContainer& from);
  void MergeFrom(const PerceptionRegionContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceptionRegionContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PerceptionRegion prcpn_rgn_list = 1;
  int prcpn_rgn_list_size() const;
  void clear_prcpn_rgn_list();
  static const int kPrcpnRgnListFieldNumber = 1;
  ::PerceptionRegion* mutable_prcpn_rgn_list(int index);
  ::google::protobuf::RepeatedPtrField< ::PerceptionRegion >*
      mutable_prcpn_rgn_list();
  const ::PerceptionRegion& prcpn_rgn_list(int index) const;
  ::PerceptionRegion* add_prcpn_rgn_list();
  const ::google::protobuf::RepeatedPtrField< ::PerceptionRegion >&
      prcpn_rgn_list() const;

  // @@protoc_insertion_point(class_scope:PerceptionRegionContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PerceptionRegion > prcpn_rgn_list_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PerceptionRegion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PerceptionRegion) */ {
 public:
  PerceptionRegion();
  virtual ~PerceptionRegion();

  PerceptionRegion(const PerceptionRegion& from);

  inline PerceptionRegion& operator=(const PerceptionRegion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceptionRegion(PerceptionRegion&& from) noexcept
    : PerceptionRegion() {
    *this = ::std::move(from);
  }

  inline PerceptionRegion& operator=(PerceptionRegion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptionRegion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceptionRegion* internal_default_instance() {
    return reinterpret_cast<const PerceptionRegion*>(
               &_PerceptionRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(PerceptionRegion* other);
  friend void swap(PerceptionRegion& a, PerceptionRegion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceptionRegion* New() const final {
    return CreateMaybeMessage<PerceptionRegion>(NULL);
  }

  PerceptionRegion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PerceptionRegion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PerceptionRegion& from);
  void MergeFrom(const PerceptionRegion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceptionRegion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 sensorIdList = 5;
  int sensoridlist_size() const;
  void clear_sensoridlist();
  static const int kSensorIdListFieldNumber = 5;
  ::google::protobuf::uint32 sensoridlist(int index) const;
  void set_sensoridlist(int index, ::google::protobuf::uint32 value);
  void add_sensoridlist(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      sensoridlist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_sensoridlist();

  // required .Shape perceptionRegionShape = 3;
  bool has_perceptionregionshape() const;
  void clear_perceptionregionshape();
  static const int kPerceptionRegionShapeFieldNumber = 3;
  private:
  const ::Shape& _internal_perceptionregionshape() const;
  public:
  const ::Shape& perceptionregionshape() const;
  ::Shape* release_perceptionregionshape();
  ::Shape* mutable_perceptionregionshape();
  void set_allocated_perceptionregionshape(::Shape* perceptionregionshape);

  // required int32 measurementDeltaTime = 1;
  bool has_measurementdeltatime() const;
  void clear_measurementdeltatime();
  static const int kMeasurementDeltaTimeFieldNumber = 1;
  ::google::protobuf::int32 measurementdeltatime() const;
  void set_measurementdeltatime(::google::protobuf::int32 value);

  // required uint32 perceptionRegionConfidence = 2;
  bool has_perceptionregionconfidence() const;
  void clear_perceptionregionconfidence();
  static const int kPerceptionRegionConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 perceptionregionconfidence() const;
  void set_perceptionregionconfidence(::google::protobuf::uint32 value);

  // required bool shadowingApplies = 4;
  bool has_shadowingapplies() const;
  void clear_shadowingapplies();
  static const int kShadowingAppliesFieldNumber = 4;
  bool shadowingapplies() const;
  void set_shadowingapplies(bool value);

  // optional uint32 numberOfPerceivedObjects = 6;
  bool has_numberofperceivedobjects() const;
  void clear_numberofperceivedobjects();
  static const int kNumberOfPerceivedObjectsFieldNumber = 6;
  ::google::protobuf::uint32 numberofperceivedobjects() const;
  void set_numberofperceivedobjects(::google::protobuf::uint32 value);

  // optional uint32 perceivedObjectIds = 7;
  bool has_perceivedobjectids() const;
  void clear_perceivedobjectids();
  static const int kPerceivedObjectIdsFieldNumber = 7;
  ::google::protobuf::uint32 perceivedobjectids() const;
  void set_perceivedobjectids(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PerceptionRegion)
 private:
  void set_has_measurementdeltatime();
  void clear_has_measurementdeltatime();
  void set_has_perceptionregionconfidence();
  void clear_has_perceptionregionconfidence();
  void set_has_perceptionregionshape();
  void clear_has_perceptionregionshape();
  void set_has_shadowingapplies();
  void clear_has_shadowingapplies();
  void set_has_numberofperceivedobjects();
  void clear_has_numberofperceivedobjects();
  void set_has_perceivedobjectids();
  void clear_has_perceivedobjectids();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > sensoridlist_;
  ::Shape* perceptionregionshape_;
  ::google::protobuf::int32 measurementdeltatime_;
  ::google::protobuf::uint32 perceptionregionconfidence_;
  bool shadowingapplies_;
  ::google::protobuf::uint32 numberofperceivedobjects_;
  ::google::protobuf::uint32 perceivedobjectids_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PerceivedObjectContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PerceivedObjectContainer) */ {
 public:
  PerceivedObjectContainer();
  virtual ~PerceivedObjectContainer();

  PerceivedObjectContainer(const PerceivedObjectContainer& from);

  inline PerceivedObjectContainer& operator=(const PerceivedObjectContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceivedObjectContainer(PerceivedObjectContainer&& from) noexcept
    : PerceivedObjectContainer() {
    *this = ::std::move(from);
  }

  inline PerceivedObjectContainer& operator=(PerceivedObjectContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceivedObjectContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceivedObjectContainer* internal_default_instance() {
    return reinterpret_cast<const PerceivedObjectContainer*>(
               &_PerceivedObjectContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(PerceivedObjectContainer* other);
  friend void swap(PerceivedObjectContainer& a, PerceivedObjectContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceivedObjectContainer* New() const final {
    return CreateMaybeMessage<PerceivedObjectContainer>(NULL);
  }

  PerceivedObjectContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PerceivedObjectContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PerceivedObjectContainer& from);
  void MergeFrom(const PerceivedObjectContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceivedObjectContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PerceivedObject perceivedObjects = 2;
  int perceivedobjects_size() const;
  void clear_perceivedobjects();
  static const int kPerceivedObjectsFieldNumber = 2;
  ::PerceivedObject* mutable_perceivedobjects(int index);
  ::google::protobuf::RepeatedPtrField< ::PerceivedObject >*
      mutable_perceivedobjects();
  const ::PerceivedObject& perceivedobjects(int index) const;
  ::PerceivedObject* add_perceivedobjects();
  const ::google::protobuf::RepeatedPtrField< ::PerceivedObject >&
      perceivedobjects() const;

  // required uint32 numberOfPerceivedObjects = 1;
  bool has_numberofperceivedobjects() const;
  void clear_numberofperceivedobjects();
  static const int kNumberOfPerceivedObjectsFieldNumber = 1;
  ::google::protobuf::uint32 numberofperceivedobjects() const;
  void set_numberofperceivedobjects(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PerceivedObjectContainer)
 private:
  void set_has_numberofperceivedobjects();
  void clear_has_numberofperceivedobjects();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PerceivedObject > perceivedobjects_;
  ::google::protobuf::uint32 numberofperceivedobjects_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PerceivedObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PerceivedObject) */ {
 public:
  PerceivedObject();
  virtual ~PerceivedObject();

  PerceivedObject(const PerceivedObject& from);

  inline PerceivedObject& operator=(const PerceivedObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceivedObject(PerceivedObject&& from) noexcept
    : PerceivedObject() {
    *this = ::std::move(from);
  }

  inline PerceivedObject& operator=(PerceivedObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceivedObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceivedObject* internal_default_instance() {
    return reinterpret_cast<const PerceivedObject*>(
               &_PerceivedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PerceivedObject* other);
  friend void swap(PerceivedObject& a, PerceivedObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceivedObject* New() const final {
    return CreateMaybeMessage<PerceivedObject>(NULL);
  }

  PerceivedObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PerceivedObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PerceivedObject& from);
  void MergeFrom(const PerceivedObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceivedObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .LowerTriangularPositiveSemidefiniteMatrix lowerTriangularCorrelationMatrices = 8;
  int lowertriangularcorrelationmatrices_size() const;
  void clear_lowertriangularcorrelationmatrices();
  static const int kLowerTriangularCorrelationMatricesFieldNumber = 8;
  ::LowerTriangularPositiveSemidefiniteMatrix* mutable_lowertriangularcorrelationmatrices(int index);
  ::google::protobuf::RepeatedPtrField< ::LowerTriangularPositiveSemidefiniteMatrix >*
      mutable_lowertriangularcorrelationmatrices();
  const ::LowerTriangularPositiveSemidefiniteMatrix& lowertriangularcorrelationmatrices(int index) const;
  ::LowerTriangularPositiveSemidefiniteMatrix* add_lowertriangularcorrelationmatrices();
  const ::google::protobuf::RepeatedPtrField< ::LowerTriangularPositiveSemidefiniteMatrix >&
      lowertriangularcorrelationmatrices() const;

  // repeated uint32 sensorIdList = 14;
  int sensoridlist_size() const;
  void clear_sensoridlist();
  static const int kSensorIdListFieldNumber = 14;
  ::google::protobuf::uint32 sensoridlist(int index) const;
  void set_sensoridlist(int index, ::google::protobuf::uint32 value);
  void add_sensoridlist(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      sensoridlist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_sensoridlist();

  // repeated .ObjectClassWithConfidence classification = 15;
  int classification_size() const;
  void clear_classification();
  static const int kClassificationFieldNumber = 15;
  ::ObjectClassWithConfidence* mutable_classification(int index);
  ::google::protobuf::RepeatedPtrField< ::ObjectClassWithConfidence >*
      mutable_classification();
  const ::ObjectClassWithConfidence& classification(int index) const;
  ::ObjectClassWithConfidence* add_classification();
  const ::google::protobuf::RepeatedPtrField< ::ObjectClassWithConfidence >&
      classification() const;

  // required .CartesianPosition3dWithConfidence position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  private:
  const ::CartesianPosition3dWithConfidence& _internal_position() const;
  public:
  const ::CartesianPosition3dWithConfidence& position() const;
  ::CartesianPosition3dWithConfidence* release_position();
  ::CartesianPosition3dWithConfidence* mutable_position();
  void set_allocated_position(::CartesianPosition3dWithConfidence* position);

  // optional .Velocity3dWithConfidence velocity = 4;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  private:
  const ::Velocity3dWithConfidence& _internal_velocity() const;
  public:
  const ::Velocity3dWithConfidence& velocity() const;
  ::Velocity3dWithConfidence* release_velocity();
  ::Velocity3dWithConfidence* mutable_velocity();
  void set_allocated_velocity(::Velocity3dWithConfidence* velocity);

  // optional .Acceleration3dWithConfidence acceleration = 5;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 5;
  private:
  const ::Acceleration3dWithConfidence& _internal_acceleration() const;
  public:
  const ::Acceleration3dWithConfidence& acceleration() const;
  ::Acceleration3dWithConfidence* release_acceleration();
  ::Acceleration3dWithConfidence* mutable_acceleration();
  void set_allocated_acceleration(::Acceleration3dWithConfidence* acceleration);

  // optional .EulerAnglesWithConfidence angles = 6;
  bool has_angles() const;
  void clear_angles();
  static const int kAnglesFieldNumber = 6;
  private:
  const ::EulerAnglesWithConfidence& _internal_angles() const;
  public:
  const ::EulerAnglesWithConfidence& angles() const;
  ::EulerAnglesWithConfidence* release_angles();
  ::EulerAnglesWithConfidence* mutable_angles();
  void set_allocated_angles(::EulerAnglesWithConfidence* angles);

  // optional .CartesianAngularVelocityComponent zAngularVelocity = 7;
  bool has_zangularvelocity() const;
  void clear_zangularvelocity();
  static const int kZAngularVelocityFieldNumber = 7;
  private:
  const ::CartesianAngularVelocityComponent& _internal_zangularvelocity() const;
  public:
  const ::CartesianAngularVelocityComponent& zangularvelocity() const;
  ::CartesianAngularVelocityComponent* release_zangularvelocity();
  ::CartesianAngularVelocityComponent* mutable_zangularvelocity();
  void set_allocated_zangularvelocity(::CartesianAngularVelocityComponent* zangularvelocity);

  // optional .ObjectDimension objectDimensionZ = 9;
  bool has_objectdimensionz() const;
  void clear_objectdimensionz();
  static const int kObjectDimensionZFieldNumber = 9;
  private:
  const ::ObjectDimension& _internal_objectdimensionz() const;
  public:
  const ::ObjectDimension& objectdimensionz() const;
  ::ObjectDimension* release_objectdimensionz();
  ::ObjectDimension* mutable_objectdimensionz();
  void set_allocated_objectdimensionz(::ObjectDimension* objectdimensionz);

  // optional .ObjectDimension objectDimensionY = 10;
  bool has_objectdimensiony() const;
  void clear_objectdimensiony();
  static const int kObjectDimensionYFieldNumber = 10;
  private:
  const ::ObjectDimension& _internal_objectdimensiony() const;
  public:
  const ::ObjectDimension& objectdimensiony() const;
  ::ObjectDimension* release_objectdimensiony();
  ::ObjectDimension* mutable_objectdimensiony();
  void set_allocated_objectdimensiony(::ObjectDimension* objectdimensiony);

  // optional .ObjectDimension objectDimensionX = 11;
  bool has_objectdimensionx() const;
  void clear_objectdimensionx();
  static const int kObjectDimensionXFieldNumber = 11;
  private:
  const ::ObjectDimension& _internal_objectdimensionx() const;
  public:
  const ::ObjectDimension& objectdimensionx() const;
  ::ObjectDimension* release_objectdimensionx();
  ::ObjectDimension* mutable_objectdimensionx();
  void set_allocated_objectdimensionx(::ObjectDimension* objectdimensionx);

  // required .MapPosition mapPosition = 16;
  bool has_mapposition() const;
  void clear_mapposition();
  static const int kMapPositionFieldNumber = 16;
  private:
  const ::MapPosition& _internal_mapposition() const;
  public:
  const ::MapPosition& mapposition() const;
  ::MapPosition* release_mapposition();
  ::MapPosition* mutable_mapposition();
  void set_allocated_mapposition(::MapPosition* mapposition);

  // optional uint32 objectID = 1;
  bool has_objectid() const;
  void clear_objectid();
  static const int kObjectIDFieldNumber = 1;
  ::google::protobuf::uint32 objectid() const;
  void set_objectid(::google::protobuf::uint32 value);

  // required int32 measurementDeltaTime = 2;
  bool has_measurementdeltatime() const;
  void clear_measurementdeltatime();
  static const int kMeasurementDeltaTimeFieldNumber = 2;
  ::google::protobuf::int32 measurementdeltatime() const;
  void set_measurementdeltatime(::google::protobuf::int32 value);

  // optional uint32 objectAge = 12;
  bool has_objectage() const;
  void clear_objectage();
  static const int kObjectAgeFieldNumber = 12;
  ::google::protobuf::uint32 objectage() const;
  void set_objectage(::google::protobuf::uint32 value);

  // optional uint32 objectPerceptionQuality = 13;
  bool has_objectperceptionquality() const;
  void clear_objectperceptionquality();
  static const int kObjectPerceptionQualityFieldNumber = 13;
  ::google::protobuf::uint32 objectperceptionquality() const;
  void set_objectperceptionquality(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PerceivedObject)
 private:
  void set_has_objectid();
  void clear_has_objectid();
  void set_has_measurementdeltatime();
  void clear_has_measurementdeltatime();
  void set_has_position();
  void clear_has_position();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_acceleration();
  void clear_has_acceleration();
  void set_has_angles();
  void clear_has_angles();
  void set_has_zangularvelocity();
  void clear_has_zangularvelocity();
  void set_has_objectdimensionz();
  void clear_has_objectdimensionz();
  void set_has_objectdimensiony();
  void clear_has_objectdimensiony();
  void set_has_objectdimensionx();
  void clear_has_objectdimensionx();
  void set_has_objectage();
  void clear_has_objectage();
  void set_has_objectperceptionquality();
  void clear_has_objectperceptionquality();
  void set_has_mapposition();
  void clear_has_mapposition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::LowerTriangularPositiveSemidefiniteMatrix > lowertriangularcorrelationmatrices_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > sensoridlist_;
  ::google::protobuf::RepeatedPtrField< ::ObjectClassWithConfidence > classification_;
  ::CartesianPosition3dWithConfidence* position_;
  ::Velocity3dWithConfidence* velocity_;
  ::Acceleration3dWithConfidence* acceleration_;
  ::EulerAnglesWithConfidence* angles_;
  ::CartesianAngularVelocityComponent* zangularvelocity_;
  ::ObjectDimension* objectdimensionz_;
  ::ObjectDimension* objectdimensiony_;
  ::ObjectDimension* objectdimensionx_;
  ::MapPosition* mapposition_;
  ::google::protobuf::uint32 objectid_;
  ::google::protobuf::int32 measurementdeltatime_;
  ::google::protobuf::uint32 objectage_;
  ::google::protobuf::uint32 objectperceptionquality_;
  friend struct ::protobuf_cpm_5finterface_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CPMessage

// required .ItsPduHeader header = 1;
inline bool CPMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ItsPduHeader& CPMessage::_internal_header() const {
  return *header_;
}
inline const ::ItsPduHeader& CPMessage::header() const {
  const ::ItsPduHeader* p = header_;
  // @@protoc_insertion_point(field_get:CPMessage.header)
  return p != NULL ? *p : *reinterpret_cast<const ::ItsPduHeader*>(
      &::_ItsPduHeader_default_instance_);
}
inline ::ItsPduHeader* CPMessage::release_header() {
  // @@protoc_insertion_point(field_release:CPMessage.header)
  clear_has_header();
  ::ItsPduHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::ItsPduHeader* CPMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::ItsPduHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CPMessage.header)
  return header_;
}
inline void CPMessage::set_allocated_header(::ItsPduHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:CPMessage.header)
}

// required uint64 generation_delta_time = 2;
inline bool CPMessage::has_generation_delta_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CPMessage::set_has_generation_delta_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CPMessage::clear_has_generation_delta_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CPMessage::clear_generation_delta_time() {
  generation_delta_time_ = GOOGLE_ULONGLONG(0);
  clear_has_generation_delta_time();
}
inline ::google::protobuf::uint64 CPMessage::generation_delta_time() const {
  // @@protoc_insertion_point(field_get:CPMessage.generation_delta_time)
  return generation_delta_time_;
}
inline void CPMessage::set_generation_delta_time(::google::protobuf::uint64 value) {
  set_has_generation_delta_time();
  generation_delta_time_ = value;
  // @@protoc_insertion_point(field_set:CPMessage.generation_delta_time)
}

// required .ManagmentContainer mgmt_cntnr = 3;
inline bool CPMessage::has_mgmt_cntnr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPMessage::set_has_mgmt_cntnr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPMessage::clear_has_mgmt_cntnr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPMessage::clear_mgmt_cntnr() {
  if (mgmt_cntnr_ != NULL) mgmt_cntnr_->Clear();
  clear_has_mgmt_cntnr();
}
inline const ::ManagmentContainer& CPMessage::_internal_mgmt_cntnr() const {
  return *mgmt_cntnr_;
}
inline const ::ManagmentContainer& CPMessage::mgmt_cntnr() const {
  const ::ManagmentContainer* p = mgmt_cntnr_;
  // @@protoc_insertion_point(field_get:CPMessage.mgmt_cntnr)
  return p != NULL ? *p : *reinterpret_cast<const ::ManagmentContainer*>(
      &::_ManagmentContainer_default_instance_);
}
inline ::ManagmentContainer* CPMessage::release_mgmt_cntnr() {
  // @@protoc_insertion_point(field_release:CPMessage.mgmt_cntnr)
  clear_has_mgmt_cntnr();
  ::ManagmentContainer* temp = mgmt_cntnr_;
  mgmt_cntnr_ = NULL;
  return temp;
}
inline ::ManagmentContainer* CPMessage::mutable_mgmt_cntnr() {
  set_has_mgmt_cntnr();
  if (mgmt_cntnr_ == NULL) {
    auto* p = CreateMaybeMessage<::ManagmentContainer>(GetArenaNoVirtual());
    mgmt_cntnr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CPMessage.mgmt_cntnr)
  return mgmt_cntnr_;
}
inline void CPMessage::set_allocated_mgmt_cntnr(::ManagmentContainer* mgmt_cntnr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mgmt_cntnr_;
  }
  if (mgmt_cntnr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mgmt_cntnr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mgmt_cntnr, submessage_arena);
    }
    set_has_mgmt_cntnr();
  } else {
    clear_has_mgmt_cntnr();
  }
  mgmt_cntnr_ = mgmt_cntnr;
  // @@protoc_insertion_point(field_set_allocated:CPMessage.mgmt_cntnr)
}

// required .CpmPayload cpm_payload = 4;
inline bool CPMessage::has_cpm_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPMessage::set_has_cpm_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPMessage::clear_has_cpm_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPMessage::clear_cpm_payload() {
  if (cpm_payload_ != NULL) cpm_payload_->Clear();
  clear_has_cpm_payload();
}
inline const ::CpmPayload& CPMessage::_internal_cpm_payload() const {
  return *cpm_payload_;
}
inline const ::CpmPayload& CPMessage::cpm_payload() const {
  const ::CpmPayload* p = cpm_payload_;
  // @@protoc_insertion_point(field_get:CPMessage.cpm_payload)
  return p != NULL ? *p : *reinterpret_cast<const ::CpmPayload*>(
      &::_CpmPayload_default_instance_);
}
inline ::CpmPayload* CPMessage::release_cpm_payload() {
  // @@protoc_insertion_point(field_release:CPMessage.cpm_payload)
  clear_has_cpm_payload();
  ::CpmPayload* temp = cpm_payload_;
  cpm_payload_ = NULL;
  return temp;
}
inline ::CpmPayload* CPMessage::mutable_cpm_payload() {
  set_has_cpm_payload();
  if (cpm_payload_ == NULL) {
    auto* p = CreateMaybeMessage<::CpmPayload>(GetArenaNoVirtual());
    cpm_payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CPMessage.cpm_payload)
  return cpm_payload_;
}
inline void CPMessage::set_allocated_cpm_payload(::CpmPayload* cpm_payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cpm_payload_;
  }
  if (cpm_payload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cpm_payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cpm_payload, submessage_arena);
    }
    set_has_cpm_payload();
  } else {
    clear_has_cpm_payload();
  }
  cpm_payload_ = cpm_payload;
  // @@protoc_insertion_point(field_set_allocated:CPMessage.cpm_payload)
}

// -------------------------------------------------------------------

// CpmPayload

// required .OriginatingStationsContainer org_stn_cntr = 1;
inline bool CpmPayload::has_org_stn_cntr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpmPayload::set_has_org_stn_cntr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CpmPayload::clear_has_org_stn_cntr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CpmPayload::clear_org_stn_cntr() {
  if (org_stn_cntr_ != NULL) org_stn_cntr_->Clear();
  clear_has_org_stn_cntr();
}
inline const ::OriginatingStationsContainer& CpmPayload::_internal_org_stn_cntr() const {
  return *org_stn_cntr_;
}
inline const ::OriginatingStationsContainer& CpmPayload::org_stn_cntr() const {
  const ::OriginatingStationsContainer* p = org_stn_cntr_;
  // @@protoc_insertion_point(field_get:CpmPayload.org_stn_cntr)
  return p != NULL ? *p : *reinterpret_cast<const ::OriginatingStationsContainer*>(
      &::_OriginatingStationsContainer_default_instance_);
}
inline ::OriginatingStationsContainer* CpmPayload::release_org_stn_cntr() {
  // @@protoc_insertion_point(field_release:CpmPayload.org_stn_cntr)
  clear_has_org_stn_cntr();
  ::OriginatingStationsContainer* temp = org_stn_cntr_;
  org_stn_cntr_ = NULL;
  return temp;
}
inline ::OriginatingStationsContainer* CpmPayload::mutable_org_stn_cntr() {
  set_has_org_stn_cntr();
  if (org_stn_cntr_ == NULL) {
    auto* p = CreateMaybeMessage<::OriginatingStationsContainer>(GetArenaNoVirtual());
    org_stn_cntr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CpmPayload.org_stn_cntr)
  return org_stn_cntr_;
}
inline void CpmPayload::set_allocated_org_stn_cntr(::OriginatingStationsContainer* org_stn_cntr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete org_stn_cntr_;
  }
  if (org_stn_cntr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      org_stn_cntr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, org_stn_cntr, submessage_arena);
    }
    set_has_org_stn_cntr();
  } else {
    clear_has_org_stn_cntr();
  }
  org_stn_cntr_ = org_stn_cntr;
  // @@protoc_insertion_point(field_set_allocated:CpmPayload.org_stn_cntr)
}

// required .SensorInformationContainer snsr_info_cntr = 2;
inline bool CpmPayload::has_snsr_info_cntr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CpmPayload::set_has_snsr_info_cntr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CpmPayload::clear_has_snsr_info_cntr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CpmPayload::clear_snsr_info_cntr() {
  if (snsr_info_cntr_ != NULL) snsr_info_cntr_->Clear();
  clear_has_snsr_info_cntr();
}
inline const ::SensorInformationContainer& CpmPayload::_internal_snsr_info_cntr() const {
  return *snsr_info_cntr_;
}
inline const ::SensorInformationContainer& CpmPayload::snsr_info_cntr() const {
  const ::SensorInformationContainer* p = snsr_info_cntr_;
  // @@protoc_insertion_point(field_get:CpmPayload.snsr_info_cntr)
  return p != NULL ? *p : *reinterpret_cast<const ::SensorInformationContainer*>(
      &::_SensorInformationContainer_default_instance_);
}
inline ::SensorInformationContainer* CpmPayload::release_snsr_info_cntr() {
  // @@protoc_insertion_point(field_release:CpmPayload.snsr_info_cntr)
  clear_has_snsr_info_cntr();
  ::SensorInformationContainer* temp = snsr_info_cntr_;
  snsr_info_cntr_ = NULL;
  return temp;
}
inline ::SensorInformationContainer* CpmPayload::mutable_snsr_info_cntr() {
  set_has_snsr_info_cntr();
  if (snsr_info_cntr_ == NULL) {
    auto* p = CreateMaybeMessage<::SensorInformationContainer>(GetArenaNoVirtual());
    snsr_info_cntr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CpmPayload.snsr_info_cntr)
  return snsr_info_cntr_;
}
inline void CpmPayload::set_allocated_snsr_info_cntr(::SensorInformationContainer* snsr_info_cntr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snsr_info_cntr_;
  }
  if (snsr_info_cntr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snsr_info_cntr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snsr_info_cntr, submessage_arena);
    }
    set_has_snsr_info_cntr();
  } else {
    clear_has_snsr_info_cntr();
  }
  snsr_info_cntr_ = snsr_info_cntr;
  // @@protoc_insertion_point(field_set_allocated:CpmPayload.snsr_info_cntr)
}

// required .PerceptionRegionContainer prcptn_rgn_cntr = 3;
inline bool CpmPayload::has_prcptn_rgn_cntr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CpmPayload::set_has_prcptn_rgn_cntr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CpmPayload::clear_has_prcptn_rgn_cntr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CpmPayload::clear_prcptn_rgn_cntr() {
  if (prcptn_rgn_cntr_ != NULL) prcptn_rgn_cntr_->Clear();
  clear_has_prcptn_rgn_cntr();
}
inline const ::PerceptionRegionContainer& CpmPayload::_internal_prcptn_rgn_cntr() const {
  return *prcptn_rgn_cntr_;
}
inline const ::PerceptionRegionContainer& CpmPayload::prcptn_rgn_cntr() const {
  const ::PerceptionRegionContainer* p = prcptn_rgn_cntr_;
  // @@protoc_insertion_point(field_get:CpmPayload.prcptn_rgn_cntr)
  return p != NULL ? *p : *reinterpret_cast<const ::PerceptionRegionContainer*>(
      &::_PerceptionRegionContainer_default_instance_);
}
inline ::PerceptionRegionContainer* CpmPayload::release_prcptn_rgn_cntr() {
  // @@protoc_insertion_point(field_release:CpmPayload.prcptn_rgn_cntr)
  clear_has_prcptn_rgn_cntr();
  ::PerceptionRegionContainer* temp = prcptn_rgn_cntr_;
  prcptn_rgn_cntr_ = NULL;
  return temp;
}
inline ::PerceptionRegionContainer* CpmPayload::mutable_prcptn_rgn_cntr() {
  set_has_prcptn_rgn_cntr();
  if (prcptn_rgn_cntr_ == NULL) {
    auto* p = CreateMaybeMessage<::PerceptionRegionContainer>(GetArenaNoVirtual());
    prcptn_rgn_cntr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CpmPayload.prcptn_rgn_cntr)
  return prcptn_rgn_cntr_;
}
inline void CpmPayload::set_allocated_prcptn_rgn_cntr(::PerceptionRegionContainer* prcptn_rgn_cntr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prcptn_rgn_cntr_;
  }
  if (prcptn_rgn_cntr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prcptn_rgn_cntr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prcptn_rgn_cntr, submessage_arena);
    }
    set_has_prcptn_rgn_cntr();
  } else {
    clear_has_prcptn_rgn_cntr();
  }
  prcptn_rgn_cntr_ = prcptn_rgn_cntr;
  // @@protoc_insertion_point(field_set_allocated:CpmPayload.prcptn_rgn_cntr)
}

// required .PerceivedObjectContainer prcvd_obj_cntr = 4;
inline bool CpmPayload::has_prcvd_obj_cntr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CpmPayload::set_has_prcvd_obj_cntr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CpmPayload::clear_has_prcvd_obj_cntr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CpmPayload::clear_prcvd_obj_cntr() {
  if (prcvd_obj_cntr_ != NULL) prcvd_obj_cntr_->Clear();
  clear_has_prcvd_obj_cntr();
}
inline const ::PerceivedObjectContainer& CpmPayload::_internal_prcvd_obj_cntr() const {
  return *prcvd_obj_cntr_;
}
inline const ::PerceivedObjectContainer& CpmPayload::prcvd_obj_cntr() const {
  const ::PerceivedObjectContainer* p = prcvd_obj_cntr_;
  // @@protoc_insertion_point(field_get:CpmPayload.prcvd_obj_cntr)
  return p != NULL ? *p : *reinterpret_cast<const ::PerceivedObjectContainer*>(
      &::_PerceivedObjectContainer_default_instance_);
}
inline ::PerceivedObjectContainer* CpmPayload::release_prcvd_obj_cntr() {
  // @@protoc_insertion_point(field_release:CpmPayload.prcvd_obj_cntr)
  clear_has_prcvd_obj_cntr();
  ::PerceivedObjectContainer* temp = prcvd_obj_cntr_;
  prcvd_obj_cntr_ = NULL;
  return temp;
}
inline ::PerceivedObjectContainer* CpmPayload::mutable_prcvd_obj_cntr() {
  set_has_prcvd_obj_cntr();
  if (prcvd_obj_cntr_ == NULL) {
    auto* p = CreateMaybeMessage<::PerceivedObjectContainer>(GetArenaNoVirtual());
    prcvd_obj_cntr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CpmPayload.prcvd_obj_cntr)
  return prcvd_obj_cntr_;
}
inline void CpmPayload::set_allocated_prcvd_obj_cntr(::PerceivedObjectContainer* prcvd_obj_cntr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prcvd_obj_cntr_;
  }
  if (prcvd_obj_cntr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prcvd_obj_cntr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prcvd_obj_cntr, submessage_arena);
    }
    set_has_prcvd_obj_cntr();
  } else {
    clear_has_prcvd_obj_cntr();
  }
  prcvd_obj_cntr_ = prcvd_obj_cntr;
  // @@protoc_insertion_point(field_set_allocated:CpmPayload.prcvd_obj_cntr)
}

// -------------------------------------------------------------------

// ManagmentContainer

// required uint64 referenceTime = 1;
inline bool ManagmentContainer::has_referencetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManagmentContainer::set_has_referencetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManagmentContainer::clear_has_referencetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManagmentContainer::clear_referencetime() {
  referencetime_ = GOOGLE_ULONGLONG(0);
  clear_has_referencetime();
}
inline ::google::protobuf::uint64 ManagmentContainer::referencetime() const {
  // @@protoc_insertion_point(field_get:ManagmentContainer.referenceTime)
  return referencetime_;
}
inline void ManagmentContainer::set_referencetime(::google::protobuf::uint64 value) {
  set_has_referencetime();
  referencetime_ = value;
  // @@protoc_insertion_point(field_set:ManagmentContainer.referenceTime)
}

// required .ReferencePosition referencePosition = 2;
inline bool ManagmentContainer::has_referenceposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManagmentContainer::set_has_referenceposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManagmentContainer::clear_has_referenceposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ReferencePosition& ManagmentContainer::_internal_referenceposition() const {
  return *referenceposition_;
}
inline const ::ReferencePosition& ManagmentContainer::referenceposition() const {
  const ::ReferencePosition* p = referenceposition_;
  // @@protoc_insertion_point(field_get:ManagmentContainer.referencePosition)
  return p != NULL ? *p : *reinterpret_cast<const ::ReferencePosition*>(
      &::_ReferencePosition_default_instance_);
}
inline ::ReferencePosition* ManagmentContainer::release_referenceposition() {
  // @@protoc_insertion_point(field_release:ManagmentContainer.referencePosition)
  clear_has_referenceposition();
  ::ReferencePosition* temp = referenceposition_;
  referenceposition_ = NULL;
  return temp;
}
inline ::ReferencePosition* ManagmentContainer::mutable_referenceposition() {
  set_has_referenceposition();
  if (referenceposition_ == NULL) {
    auto* p = CreateMaybeMessage<::ReferencePosition>(GetArenaNoVirtual());
    referenceposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ManagmentContainer.referencePosition)
  return referenceposition_;
}
inline void ManagmentContainer::set_allocated_referenceposition(::ReferencePosition* referenceposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(referenceposition_);
  }
  if (referenceposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      referenceposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, referenceposition, submessage_arena);
    }
    set_has_referenceposition();
  } else {
    clear_has_referenceposition();
  }
  referenceposition_ = referenceposition;
  // @@protoc_insertion_point(field_set_allocated:ManagmentContainer.referencePosition)
}

// optional .MessageSegmentationInfo segmentationInfo = 3;
inline bool ManagmentContainer::has_segmentationinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManagmentContainer::set_has_segmentationinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManagmentContainer::clear_has_segmentationinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::MessageSegmentationInfo& ManagmentContainer::_internal_segmentationinfo() const {
  return *segmentationinfo_;
}
inline const ::MessageSegmentationInfo& ManagmentContainer::segmentationinfo() const {
  const ::MessageSegmentationInfo* p = segmentationinfo_;
  // @@protoc_insertion_point(field_get:ManagmentContainer.segmentationInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MessageSegmentationInfo*>(
      &::_MessageSegmentationInfo_default_instance_);
}
inline ::MessageSegmentationInfo* ManagmentContainer::release_segmentationinfo() {
  // @@protoc_insertion_point(field_release:ManagmentContainer.segmentationInfo)
  clear_has_segmentationinfo();
  ::MessageSegmentationInfo* temp = segmentationinfo_;
  segmentationinfo_ = NULL;
  return temp;
}
inline ::MessageSegmentationInfo* ManagmentContainer::mutable_segmentationinfo() {
  set_has_segmentationinfo();
  if (segmentationinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MessageSegmentationInfo>(GetArenaNoVirtual());
    segmentationinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ManagmentContainer.segmentationInfo)
  return segmentationinfo_;
}
inline void ManagmentContainer::set_allocated_segmentationinfo(::MessageSegmentationInfo* segmentationinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(segmentationinfo_);
  }
  if (segmentationinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      segmentationinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, segmentationinfo, submessage_arena);
    }
    set_has_segmentationinfo();
  } else {
    clear_has_segmentationinfo();
  }
  segmentationinfo_ = segmentationinfo;
  // @@protoc_insertion_point(field_set_allocated:ManagmentContainer.segmentationInfo)
}

// optional .MessageRateRange messageRateRange = 4;
inline bool ManagmentContainer::has_messageraterange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManagmentContainer::set_has_messageraterange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManagmentContainer::clear_has_messageraterange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManagmentContainer::clear_messageraterange() {
  if (messageraterange_ != NULL) messageraterange_->Clear();
  clear_has_messageraterange();
}
inline const ::MessageRateRange& ManagmentContainer::_internal_messageraterange() const {
  return *messageraterange_;
}
inline const ::MessageRateRange& ManagmentContainer::messageraterange() const {
  const ::MessageRateRange* p = messageraterange_;
  // @@protoc_insertion_point(field_get:ManagmentContainer.messageRateRange)
  return p != NULL ? *p : *reinterpret_cast<const ::MessageRateRange*>(
      &::_MessageRateRange_default_instance_);
}
inline ::MessageRateRange* ManagmentContainer::release_messageraterange() {
  // @@protoc_insertion_point(field_release:ManagmentContainer.messageRateRange)
  clear_has_messageraterange();
  ::MessageRateRange* temp = messageraterange_;
  messageraterange_ = NULL;
  return temp;
}
inline ::MessageRateRange* ManagmentContainer::mutable_messageraterange() {
  set_has_messageraterange();
  if (messageraterange_ == NULL) {
    auto* p = CreateMaybeMessage<::MessageRateRange>(GetArenaNoVirtual());
    messageraterange_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ManagmentContainer.messageRateRange)
  return messageraterange_;
}
inline void ManagmentContainer::set_allocated_messageraterange(::MessageRateRange* messageraterange) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete messageraterange_;
  }
  if (messageraterange) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      messageraterange = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messageraterange, submessage_arena);
    }
    set_has_messageraterange();
  } else {
    clear_has_messageraterange();
  }
  messageraterange_ = messageraterange;
  // @@protoc_insertion_point(field_set_allocated:ManagmentContainer.messageRateRange)
}

// optional .StationType stationtype = 5;
inline bool ManagmentContainer::has_stationtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ManagmentContainer::set_has_stationtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ManagmentContainer::clear_has_stationtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ManagmentContainer::clear_stationtype() {
  stationtype_ = 0;
  clear_has_stationtype();
}
inline ::StationType ManagmentContainer::stationtype() const {
  // @@protoc_insertion_point(field_get:ManagmentContainer.stationtype)
  return static_cast< ::StationType >(stationtype_);
}
inline void ManagmentContainer::set_stationtype(::StationType value) {
  assert(::StationType_IsValid(value));
  set_has_stationtype();
  stationtype_ = value;
  // @@protoc_insertion_point(field_set:ManagmentContainer.stationtype)
}

// -------------------------------------------------------------------

// MessageRateRange

// required .MessageRateHz messageRateMin = 1;
inline bool MessageRateRange::has_messageratemin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageRateRange::set_has_messageratemin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageRateRange::clear_has_messageratemin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::MessageRateHz& MessageRateRange::_internal_messageratemin() const {
  return *messageratemin_;
}
inline const ::MessageRateHz& MessageRateRange::messageratemin() const {
  const ::MessageRateHz* p = messageratemin_;
  // @@protoc_insertion_point(field_get:MessageRateRange.messageRateMin)
  return p != NULL ? *p : *reinterpret_cast<const ::MessageRateHz*>(
      &::_MessageRateHz_default_instance_);
}
inline ::MessageRateHz* MessageRateRange::release_messageratemin() {
  // @@protoc_insertion_point(field_release:MessageRateRange.messageRateMin)
  clear_has_messageratemin();
  ::MessageRateHz* temp = messageratemin_;
  messageratemin_ = NULL;
  return temp;
}
inline ::MessageRateHz* MessageRateRange::mutable_messageratemin() {
  set_has_messageratemin();
  if (messageratemin_ == NULL) {
    auto* p = CreateMaybeMessage<::MessageRateHz>(GetArenaNoVirtual());
    messageratemin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MessageRateRange.messageRateMin)
  return messageratemin_;
}
inline void MessageRateRange::set_allocated_messageratemin(::MessageRateHz* messageratemin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(messageratemin_);
  }
  if (messageratemin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      messageratemin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messageratemin, submessage_arena);
    }
    set_has_messageratemin();
  } else {
    clear_has_messageratemin();
  }
  messageratemin_ = messageratemin;
  // @@protoc_insertion_point(field_set_allocated:MessageRateRange.messageRateMin)
}

// required .MessageRateHz messageRateMax = 2;
inline bool MessageRateRange::has_messageratemax() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageRateRange::set_has_messageratemax() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageRateRange::clear_has_messageratemax() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::MessageRateHz& MessageRateRange::_internal_messageratemax() const {
  return *messageratemax_;
}
inline const ::MessageRateHz& MessageRateRange::messageratemax() const {
  const ::MessageRateHz* p = messageratemax_;
  // @@protoc_insertion_point(field_get:MessageRateRange.messageRateMax)
  return p != NULL ? *p : *reinterpret_cast<const ::MessageRateHz*>(
      &::_MessageRateHz_default_instance_);
}
inline ::MessageRateHz* MessageRateRange::release_messageratemax() {
  // @@protoc_insertion_point(field_release:MessageRateRange.messageRateMax)
  clear_has_messageratemax();
  ::MessageRateHz* temp = messageratemax_;
  messageratemax_ = NULL;
  return temp;
}
inline ::MessageRateHz* MessageRateRange::mutable_messageratemax() {
  set_has_messageratemax();
  if (messageratemax_ == NULL) {
    auto* p = CreateMaybeMessage<::MessageRateHz>(GetArenaNoVirtual());
    messageratemax_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MessageRateRange.messageRateMax)
  return messageratemax_;
}
inline void MessageRateRange::set_allocated_messageratemax(::MessageRateHz* messageratemax) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(messageratemax_);
  }
  if (messageratemax) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      messageratemax = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, messageratemax, submessage_arena);
    }
    set_has_messageratemax();
  } else {
    clear_has_messageratemax();
  }
  messageratemax_ = messageratemax;
  // @@protoc_insertion_point(field_set_allocated:MessageRateRange.messageRateMax)
}

// -------------------------------------------------------------------

// OriginatingStationsContainer

// optional .OriginatingVehicleContainer org_veh_cntr = 1;
inline bool OriginatingStationsContainer::has_org_veh_cntr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OriginatingStationsContainer::set_has_org_veh_cntr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OriginatingStationsContainer::clear_has_org_veh_cntr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OriginatingStationsContainer::clear_org_veh_cntr() {
  if (org_veh_cntr_ != NULL) org_veh_cntr_->Clear();
  clear_has_org_veh_cntr();
}
inline const ::OriginatingVehicleContainer& OriginatingStationsContainer::_internal_org_veh_cntr() const {
  return *org_veh_cntr_;
}
inline const ::OriginatingVehicleContainer& OriginatingStationsContainer::org_veh_cntr() const {
  const ::OriginatingVehicleContainer* p = org_veh_cntr_;
  // @@protoc_insertion_point(field_get:OriginatingStationsContainer.org_veh_cntr)
  return p != NULL ? *p : *reinterpret_cast<const ::OriginatingVehicleContainer*>(
      &::_OriginatingVehicleContainer_default_instance_);
}
inline ::OriginatingVehicleContainer* OriginatingStationsContainer::release_org_veh_cntr() {
  // @@protoc_insertion_point(field_release:OriginatingStationsContainer.org_veh_cntr)
  clear_has_org_veh_cntr();
  ::OriginatingVehicleContainer* temp = org_veh_cntr_;
  org_veh_cntr_ = NULL;
  return temp;
}
inline ::OriginatingVehicleContainer* OriginatingStationsContainer::mutable_org_veh_cntr() {
  set_has_org_veh_cntr();
  if (org_veh_cntr_ == NULL) {
    auto* p = CreateMaybeMessage<::OriginatingVehicleContainer>(GetArenaNoVirtual());
    org_veh_cntr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:OriginatingStationsContainer.org_veh_cntr)
  return org_veh_cntr_;
}
inline void OriginatingStationsContainer::set_allocated_org_veh_cntr(::OriginatingVehicleContainer* org_veh_cntr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete org_veh_cntr_;
  }
  if (org_veh_cntr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      org_veh_cntr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, org_veh_cntr, submessage_arena);
    }
    set_has_org_veh_cntr();
  } else {
    clear_has_org_veh_cntr();
  }
  org_veh_cntr_ = org_veh_cntr;
  // @@protoc_insertion_point(field_set_allocated:OriginatingStationsContainer.org_veh_cntr)
}

// optional .OriginatingRSUContainer org_rsu_cntr = 2;
inline bool OriginatingStationsContainer::has_org_rsu_cntr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OriginatingStationsContainer::set_has_org_rsu_cntr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OriginatingStationsContainer::clear_has_org_rsu_cntr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OriginatingStationsContainer::clear_org_rsu_cntr() {
  if (org_rsu_cntr_ != NULL) org_rsu_cntr_->Clear();
  clear_has_org_rsu_cntr();
}
inline const ::OriginatingRSUContainer& OriginatingStationsContainer::_internal_org_rsu_cntr() const {
  return *org_rsu_cntr_;
}
inline const ::OriginatingRSUContainer& OriginatingStationsContainer::org_rsu_cntr() const {
  const ::OriginatingRSUContainer* p = org_rsu_cntr_;
  // @@protoc_insertion_point(field_get:OriginatingStationsContainer.org_rsu_cntr)
  return p != NULL ? *p : *reinterpret_cast<const ::OriginatingRSUContainer*>(
      &::_OriginatingRSUContainer_default_instance_);
}
inline ::OriginatingRSUContainer* OriginatingStationsContainer::release_org_rsu_cntr() {
  // @@protoc_insertion_point(field_release:OriginatingStationsContainer.org_rsu_cntr)
  clear_has_org_rsu_cntr();
  ::OriginatingRSUContainer* temp = org_rsu_cntr_;
  org_rsu_cntr_ = NULL;
  return temp;
}
inline ::OriginatingRSUContainer* OriginatingStationsContainer::mutable_org_rsu_cntr() {
  set_has_org_rsu_cntr();
  if (org_rsu_cntr_ == NULL) {
    auto* p = CreateMaybeMessage<::OriginatingRSUContainer>(GetArenaNoVirtual());
    org_rsu_cntr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:OriginatingStationsContainer.org_rsu_cntr)
  return org_rsu_cntr_;
}
inline void OriginatingStationsContainer::set_allocated_org_rsu_cntr(::OriginatingRSUContainer* org_rsu_cntr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete org_rsu_cntr_;
  }
  if (org_rsu_cntr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      org_rsu_cntr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, org_rsu_cntr, submessage_arena);
    }
    set_has_org_rsu_cntr();
  } else {
    clear_has_org_rsu_cntr();
  }
  org_rsu_cntr_ = org_rsu_cntr;
  // @@protoc_insertion_point(field_set_allocated:OriginatingStationsContainer.org_rsu_cntr)
}

// -------------------------------------------------------------------

// OriginatingVehicleContainer

// required .Wgs84Angle orientationAngle = 1;
inline bool OriginatingVehicleContainer::has_orientationangle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OriginatingVehicleContainer::set_has_orientationangle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OriginatingVehicleContainer::clear_has_orientationangle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Wgs84Angle& OriginatingVehicleContainer::_internal_orientationangle() const {
  return *orientationangle_;
}
inline const ::Wgs84Angle& OriginatingVehicleContainer::orientationangle() const {
  const ::Wgs84Angle* p = orientationangle_;
  // @@protoc_insertion_point(field_get:OriginatingVehicleContainer.orientationAngle)
  return p != NULL ? *p : *reinterpret_cast<const ::Wgs84Angle*>(
      &::_Wgs84Angle_default_instance_);
}
inline ::Wgs84Angle* OriginatingVehicleContainer::release_orientationangle() {
  // @@protoc_insertion_point(field_release:OriginatingVehicleContainer.orientationAngle)
  clear_has_orientationangle();
  ::Wgs84Angle* temp = orientationangle_;
  orientationangle_ = NULL;
  return temp;
}
inline ::Wgs84Angle* OriginatingVehicleContainer::mutable_orientationangle() {
  set_has_orientationangle();
  if (orientationangle_ == NULL) {
    auto* p = CreateMaybeMessage<::Wgs84Angle>(GetArenaNoVirtual());
    orientationangle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:OriginatingVehicleContainer.orientationAngle)
  return orientationangle_;
}
inline void OriginatingVehicleContainer::set_allocated_orientationangle(::Wgs84Angle* orientationangle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(orientationangle_);
  }
  if (orientationangle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientationangle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientationangle, submessage_arena);
    }
    set_has_orientationangle();
  } else {
    clear_has_orientationangle();
  }
  orientationangle_ = orientationangle;
  // @@protoc_insertion_point(field_set_allocated:OriginatingVehicleContainer.orientationAngle)
}

// optional .CartesianAngle pitchAngle = 2;
inline bool OriginatingVehicleContainer::has_pitchangle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OriginatingVehicleContainer::set_has_pitchangle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OriginatingVehicleContainer::clear_has_pitchangle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::CartesianAngle& OriginatingVehicleContainer::_internal_pitchangle() const {
  return *pitchangle_;
}
inline const ::CartesianAngle& OriginatingVehicleContainer::pitchangle() const {
  const ::CartesianAngle* p = pitchangle_;
  // @@protoc_insertion_point(field_get:OriginatingVehicleContainer.pitchAngle)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianAngle*>(
      &::_CartesianAngle_default_instance_);
}
inline ::CartesianAngle* OriginatingVehicleContainer::release_pitchangle() {
  // @@protoc_insertion_point(field_release:OriginatingVehicleContainer.pitchAngle)
  clear_has_pitchangle();
  ::CartesianAngle* temp = pitchangle_;
  pitchangle_ = NULL;
  return temp;
}
inline ::CartesianAngle* OriginatingVehicleContainer::mutable_pitchangle() {
  set_has_pitchangle();
  if (pitchangle_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianAngle>(GetArenaNoVirtual());
    pitchangle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:OriginatingVehicleContainer.pitchAngle)
  return pitchangle_;
}
inline void OriginatingVehicleContainer::set_allocated_pitchangle(::CartesianAngle* pitchangle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitchangle_);
  }
  if (pitchangle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pitchangle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitchangle, submessage_arena);
    }
    set_has_pitchangle();
  } else {
    clear_has_pitchangle();
  }
  pitchangle_ = pitchangle;
  // @@protoc_insertion_point(field_set_allocated:OriginatingVehicleContainer.pitchAngle)
}

// optional .CartesianAngle rollAngle = 3;
inline bool OriginatingVehicleContainer::has_rollangle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OriginatingVehicleContainer::set_has_rollangle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OriginatingVehicleContainer::clear_has_rollangle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CartesianAngle& OriginatingVehicleContainer::_internal_rollangle() const {
  return *rollangle_;
}
inline const ::CartesianAngle& OriginatingVehicleContainer::rollangle() const {
  const ::CartesianAngle* p = rollangle_;
  // @@protoc_insertion_point(field_get:OriginatingVehicleContainer.rollAngle)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianAngle*>(
      &::_CartesianAngle_default_instance_);
}
inline ::CartesianAngle* OriginatingVehicleContainer::release_rollangle() {
  // @@protoc_insertion_point(field_release:OriginatingVehicleContainer.rollAngle)
  clear_has_rollangle();
  ::CartesianAngle* temp = rollangle_;
  rollangle_ = NULL;
  return temp;
}
inline ::CartesianAngle* OriginatingVehicleContainer::mutable_rollangle() {
  set_has_rollangle();
  if (rollangle_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianAngle>(GetArenaNoVirtual());
    rollangle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:OriginatingVehicleContainer.rollAngle)
  return rollangle_;
}
inline void OriginatingVehicleContainer::set_allocated_rollangle(::CartesianAngle* rollangle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rollangle_);
  }
  if (rollangle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rollangle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rollangle, submessage_arena);
    }
    set_has_rollangle();
  } else {
    clear_has_rollangle();
  }
  rollangle_ = rollangle;
  // @@protoc_insertion_point(field_set_allocated:OriginatingVehicleContainer.rollAngle)
}

// optional int64 trailerDataset = 4;
inline bool OriginatingVehicleContainer::has_trailerdataset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OriginatingVehicleContainer::set_has_trailerdataset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OriginatingVehicleContainer::clear_has_trailerdataset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OriginatingVehicleContainer::clear_trailerdataset() {
  trailerdataset_ = GOOGLE_LONGLONG(0);
  clear_has_trailerdataset();
}
inline ::google::protobuf::int64 OriginatingVehicleContainer::trailerdataset() const {
  // @@protoc_insertion_point(field_get:OriginatingVehicleContainer.trailerDataset)
  return trailerdataset_;
}
inline void OriginatingVehicleContainer::set_trailerdataset(::google::protobuf::int64 value) {
  set_has_trailerdataset();
  trailerdataset_ = value;
  // @@protoc_insertion_point(field_set:OriginatingVehicleContainer.trailerDataset)
}

// -------------------------------------------------------------------

// OriginatingRSUContainer

// required .RoadSegmentReferenceID roadsegment = 1;
inline bool OriginatingRSUContainer::has_roadsegment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OriginatingRSUContainer::set_has_roadsegment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OriginatingRSUContainer::clear_has_roadsegment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::RoadSegmentReferenceID& OriginatingRSUContainer::_internal_roadsegment() const {
  return *roadsegment_;
}
inline const ::RoadSegmentReferenceID& OriginatingRSUContainer::roadsegment() const {
  const ::RoadSegmentReferenceID* p = roadsegment_;
  // @@protoc_insertion_point(field_get:OriginatingRSUContainer.roadsegment)
  return p != NULL ? *p : *reinterpret_cast<const ::RoadSegmentReferenceID*>(
      &::_RoadSegmentReferenceID_default_instance_);
}
inline ::RoadSegmentReferenceID* OriginatingRSUContainer::release_roadsegment() {
  // @@protoc_insertion_point(field_release:OriginatingRSUContainer.roadsegment)
  clear_has_roadsegment();
  ::RoadSegmentReferenceID* temp = roadsegment_;
  roadsegment_ = NULL;
  return temp;
}
inline ::RoadSegmentReferenceID* OriginatingRSUContainer::mutable_roadsegment() {
  set_has_roadsegment();
  if (roadsegment_ == NULL) {
    auto* p = CreateMaybeMessage<::RoadSegmentReferenceID>(GetArenaNoVirtual());
    roadsegment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:OriginatingRSUContainer.roadsegment)
  return roadsegment_;
}
inline void OriginatingRSUContainer::set_allocated_roadsegment(::RoadSegmentReferenceID* roadsegment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roadsegment_);
  }
  if (roadsegment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roadsegment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roadsegment, submessage_arena);
    }
    set_has_roadsegment();
  } else {
    clear_has_roadsegment();
  }
  roadsegment_ = roadsegment;
  // @@protoc_insertion_point(field_set_allocated:OriginatingRSUContainer.roadsegment)
}

// required .IntersectionReferenceID intersection = 2;
inline bool OriginatingRSUContainer::has_intersection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OriginatingRSUContainer::set_has_intersection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OriginatingRSUContainer::clear_has_intersection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::IntersectionReferenceID& OriginatingRSUContainer::_internal_intersection() const {
  return *intersection_;
}
inline const ::IntersectionReferenceID& OriginatingRSUContainer::intersection() const {
  const ::IntersectionReferenceID* p = intersection_;
  // @@protoc_insertion_point(field_get:OriginatingRSUContainer.intersection)
  return p != NULL ? *p : *reinterpret_cast<const ::IntersectionReferenceID*>(
      &::_IntersectionReferenceID_default_instance_);
}
inline ::IntersectionReferenceID* OriginatingRSUContainer::release_intersection() {
  // @@protoc_insertion_point(field_release:OriginatingRSUContainer.intersection)
  clear_has_intersection();
  ::IntersectionReferenceID* temp = intersection_;
  intersection_ = NULL;
  return temp;
}
inline ::IntersectionReferenceID* OriginatingRSUContainer::mutable_intersection() {
  set_has_intersection();
  if (intersection_ == NULL) {
    auto* p = CreateMaybeMessage<::IntersectionReferenceID>(GetArenaNoVirtual());
    intersection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:OriginatingRSUContainer.intersection)
  return intersection_;
}
inline void OriginatingRSUContainer::set_allocated_intersection(::IntersectionReferenceID* intersection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(intersection_);
  }
  if (intersection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intersection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intersection, submessage_arena);
    }
    set_has_intersection();
  } else {
    clear_has_intersection();
  }
  intersection_ = intersection;
  // @@protoc_insertion_point(field_set_allocated:OriginatingRSUContainer.intersection)
}

// -------------------------------------------------------------------

// SensorInformationContainer

// repeated .SensorInformation snsr_infrmtn = 1;
inline int SensorInformationContainer::snsr_infrmtn_size() const {
  return snsr_infrmtn_.size();
}
inline void SensorInformationContainer::clear_snsr_infrmtn() {
  snsr_infrmtn_.Clear();
}
inline ::SensorInformation* SensorInformationContainer::mutable_snsr_infrmtn(int index) {
  // @@protoc_insertion_point(field_mutable:SensorInformationContainer.snsr_infrmtn)
  return snsr_infrmtn_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SensorInformation >*
SensorInformationContainer::mutable_snsr_infrmtn() {
  // @@protoc_insertion_point(field_mutable_list:SensorInformationContainer.snsr_infrmtn)
  return &snsr_infrmtn_;
}
inline const ::SensorInformation& SensorInformationContainer::snsr_infrmtn(int index) const {
  // @@protoc_insertion_point(field_get:SensorInformationContainer.snsr_infrmtn)
  return snsr_infrmtn_.Get(index);
}
inline ::SensorInformation* SensorInformationContainer::add_snsr_infrmtn() {
  // @@protoc_insertion_point(field_add:SensorInformationContainer.snsr_infrmtn)
  return snsr_infrmtn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SensorInformation >&
SensorInformationContainer::snsr_infrmtn() const {
  // @@protoc_insertion_point(field_list:SensorInformationContainer.snsr_infrmtn)
  return snsr_infrmtn_;
}

// -------------------------------------------------------------------

// SensorInformation

// required int64 sensorID = 1;
inline bool SensorInformation::has_sensorid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorInformation::set_has_sensorid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorInformation::clear_has_sensorid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorInformation::clear_sensorid() {
  sensorid_ = GOOGLE_LONGLONG(0);
  clear_has_sensorid();
}
inline ::google::protobuf::int64 SensorInformation::sensorid() const {
  // @@protoc_insertion_point(field_get:SensorInformation.sensorID)
  return sensorid_;
}
inline void SensorInformation::set_sensorid(::google::protobuf::int64 value) {
  set_has_sensorid();
  sensorid_ = value;
  // @@protoc_insertion_point(field_set:SensorInformation.sensorID)
}

// required .SensorType sensor_type = 2;
inline bool SensorInformation::has_sensor_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorInformation::set_has_sensor_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorInformation::clear_has_sensor_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorInformation::clear_sensor_type() {
  sensor_type_ = 0;
  clear_has_sensor_type();
}
inline ::SensorType SensorInformation::sensor_type() const {
  // @@protoc_insertion_point(field_get:SensorInformation.sensor_type)
  return static_cast< ::SensorType >(sensor_type_);
}
inline void SensorInformation::set_sensor_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  set_has_sensor_type();
  sensor_type_ = value;
  // @@protoc_insertion_point(field_set:SensorInformation.sensor_type)
}

// required .Shape perception_region_shape = 3;
inline bool SensorInformation::has_perception_region_shape() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorInformation::set_has_perception_region_shape() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorInformation::clear_has_perception_region_shape() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Shape& SensorInformation::_internal_perception_region_shape() const {
  return *perception_region_shape_;
}
inline const ::Shape& SensorInformation::perception_region_shape() const {
  const ::Shape* p = perception_region_shape_;
  // @@protoc_insertion_point(field_get:SensorInformation.perception_region_shape)
  return p != NULL ? *p : *reinterpret_cast<const ::Shape*>(
      &::_Shape_default_instance_);
}
inline ::Shape* SensorInformation::release_perception_region_shape() {
  // @@protoc_insertion_point(field_release:SensorInformation.perception_region_shape)
  clear_has_perception_region_shape();
  ::Shape* temp = perception_region_shape_;
  perception_region_shape_ = NULL;
  return temp;
}
inline ::Shape* SensorInformation::mutable_perception_region_shape() {
  set_has_perception_region_shape();
  if (perception_region_shape_ == NULL) {
    auto* p = CreateMaybeMessage<::Shape>(GetArenaNoVirtual());
    perception_region_shape_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SensorInformation.perception_region_shape)
  return perception_region_shape_;
}
inline void SensorInformation::set_allocated_perception_region_shape(::Shape* perception_region_shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(perception_region_shape_);
  }
  if (perception_region_shape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      perception_region_shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, perception_region_shape, submessage_arena);
    }
    set_has_perception_region_shape();
  } else {
    clear_has_perception_region_shape();
  }
  perception_region_shape_ = perception_region_shape;
  // @@protoc_insertion_point(field_set_allocated:SensorInformation.perception_region_shape)
}

// optional uint32 perception_region_conf = 4;
inline bool SensorInformation::has_perception_region_conf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorInformation::set_has_perception_region_conf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorInformation::clear_has_perception_region_conf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorInformation::clear_perception_region_conf() {
  perception_region_conf_ = 0u;
  clear_has_perception_region_conf();
}
inline ::google::protobuf::uint32 SensorInformation::perception_region_conf() const {
  // @@protoc_insertion_point(field_get:SensorInformation.perception_region_conf)
  return perception_region_conf_;
}
inline void SensorInformation::set_perception_region_conf(::google::protobuf::uint32 value) {
  set_has_perception_region_conf();
  perception_region_conf_ = value;
  // @@protoc_insertion_point(field_set:SensorInformation.perception_region_conf)
}

// required bool shadowingapplies = 5;
inline bool SensorInformation::has_shadowingapplies() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorInformation::set_has_shadowingapplies() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorInformation::clear_has_shadowingapplies() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorInformation::clear_shadowingapplies() {
  shadowingapplies_ = false;
  clear_has_shadowingapplies();
}
inline bool SensorInformation::shadowingapplies() const {
  // @@protoc_insertion_point(field_get:SensorInformation.shadowingapplies)
  return shadowingapplies_;
}
inline void SensorInformation::set_shadowingapplies(bool value) {
  set_has_shadowingapplies();
  shadowingapplies_ = value;
  // @@protoc_insertion_point(field_set:SensorInformation.shadowingapplies)
}

// -------------------------------------------------------------------

// PerceptionRegionContainer

// repeated .PerceptionRegion prcpn_rgn_list = 1;
inline int PerceptionRegionContainer::prcpn_rgn_list_size() const {
  return prcpn_rgn_list_.size();
}
inline void PerceptionRegionContainer::clear_prcpn_rgn_list() {
  prcpn_rgn_list_.Clear();
}
inline ::PerceptionRegion* PerceptionRegionContainer::mutable_prcpn_rgn_list(int index) {
  // @@protoc_insertion_point(field_mutable:PerceptionRegionContainer.prcpn_rgn_list)
  return prcpn_rgn_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PerceptionRegion >*
PerceptionRegionContainer::mutable_prcpn_rgn_list() {
  // @@protoc_insertion_point(field_mutable_list:PerceptionRegionContainer.prcpn_rgn_list)
  return &prcpn_rgn_list_;
}
inline const ::PerceptionRegion& PerceptionRegionContainer::prcpn_rgn_list(int index) const {
  // @@protoc_insertion_point(field_get:PerceptionRegionContainer.prcpn_rgn_list)
  return prcpn_rgn_list_.Get(index);
}
inline ::PerceptionRegion* PerceptionRegionContainer::add_prcpn_rgn_list() {
  // @@protoc_insertion_point(field_add:PerceptionRegionContainer.prcpn_rgn_list)
  return prcpn_rgn_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PerceptionRegion >&
PerceptionRegionContainer::prcpn_rgn_list() const {
  // @@protoc_insertion_point(field_list:PerceptionRegionContainer.prcpn_rgn_list)
  return prcpn_rgn_list_;
}

// -------------------------------------------------------------------

// PerceptionRegion

// required int32 measurementDeltaTime = 1;
inline bool PerceptionRegion::has_measurementdeltatime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerceptionRegion::set_has_measurementdeltatime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerceptionRegion::clear_has_measurementdeltatime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerceptionRegion::clear_measurementdeltatime() {
  measurementdeltatime_ = 0;
  clear_has_measurementdeltatime();
}
inline ::google::protobuf::int32 PerceptionRegion::measurementdeltatime() const {
  // @@protoc_insertion_point(field_get:PerceptionRegion.measurementDeltaTime)
  return measurementdeltatime_;
}
inline void PerceptionRegion::set_measurementdeltatime(::google::protobuf::int32 value) {
  set_has_measurementdeltatime();
  measurementdeltatime_ = value;
  // @@protoc_insertion_point(field_set:PerceptionRegion.measurementDeltaTime)
}

// required uint32 perceptionRegionConfidence = 2;
inline bool PerceptionRegion::has_perceptionregionconfidence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerceptionRegion::set_has_perceptionregionconfidence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerceptionRegion::clear_has_perceptionregionconfidence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerceptionRegion::clear_perceptionregionconfidence() {
  perceptionregionconfidence_ = 0u;
  clear_has_perceptionregionconfidence();
}
inline ::google::protobuf::uint32 PerceptionRegion::perceptionregionconfidence() const {
  // @@protoc_insertion_point(field_get:PerceptionRegion.perceptionRegionConfidence)
  return perceptionregionconfidence_;
}
inline void PerceptionRegion::set_perceptionregionconfidence(::google::protobuf::uint32 value) {
  set_has_perceptionregionconfidence();
  perceptionregionconfidence_ = value;
  // @@protoc_insertion_point(field_set:PerceptionRegion.perceptionRegionConfidence)
}

// required .Shape perceptionRegionShape = 3;
inline bool PerceptionRegion::has_perceptionregionshape() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerceptionRegion::set_has_perceptionregionshape() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerceptionRegion::clear_has_perceptionregionshape() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Shape& PerceptionRegion::_internal_perceptionregionshape() const {
  return *perceptionregionshape_;
}
inline const ::Shape& PerceptionRegion::perceptionregionshape() const {
  const ::Shape* p = perceptionregionshape_;
  // @@protoc_insertion_point(field_get:PerceptionRegion.perceptionRegionShape)
  return p != NULL ? *p : *reinterpret_cast<const ::Shape*>(
      &::_Shape_default_instance_);
}
inline ::Shape* PerceptionRegion::release_perceptionregionshape() {
  // @@protoc_insertion_point(field_release:PerceptionRegion.perceptionRegionShape)
  clear_has_perceptionregionshape();
  ::Shape* temp = perceptionregionshape_;
  perceptionregionshape_ = NULL;
  return temp;
}
inline ::Shape* PerceptionRegion::mutable_perceptionregionshape() {
  set_has_perceptionregionshape();
  if (perceptionregionshape_ == NULL) {
    auto* p = CreateMaybeMessage<::Shape>(GetArenaNoVirtual());
    perceptionregionshape_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceptionRegion.perceptionRegionShape)
  return perceptionregionshape_;
}
inline void PerceptionRegion::set_allocated_perceptionregionshape(::Shape* perceptionregionshape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(perceptionregionshape_);
  }
  if (perceptionregionshape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      perceptionregionshape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, perceptionregionshape, submessage_arena);
    }
    set_has_perceptionregionshape();
  } else {
    clear_has_perceptionregionshape();
  }
  perceptionregionshape_ = perceptionregionshape;
  // @@protoc_insertion_point(field_set_allocated:PerceptionRegion.perceptionRegionShape)
}

// required bool shadowingApplies = 4;
inline bool PerceptionRegion::has_shadowingapplies() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerceptionRegion::set_has_shadowingapplies() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerceptionRegion::clear_has_shadowingapplies() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerceptionRegion::clear_shadowingapplies() {
  shadowingapplies_ = false;
  clear_has_shadowingapplies();
}
inline bool PerceptionRegion::shadowingapplies() const {
  // @@protoc_insertion_point(field_get:PerceptionRegion.shadowingApplies)
  return shadowingapplies_;
}
inline void PerceptionRegion::set_shadowingapplies(bool value) {
  set_has_shadowingapplies();
  shadowingapplies_ = value;
  // @@protoc_insertion_point(field_set:PerceptionRegion.shadowingApplies)
}

// repeated uint32 sensorIdList = 5;
inline int PerceptionRegion::sensoridlist_size() const {
  return sensoridlist_.size();
}
inline void PerceptionRegion::clear_sensoridlist() {
  sensoridlist_.Clear();
}
inline ::google::protobuf::uint32 PerceptionRegion::sensoridlist(int index) const {
  // @@protoc_insertion_point(field_get:PerceptionRegion.sensorIdList)
  return sensoridlist_.Get(index);
}
inline void PerceptionRegion::set_sensoridlist(int index, ::google::protobuf::uint32 value) {
  sensoridlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:PerceptionRegion.sensorIdList)
}
inline void PerceptionRegion::add_sensoridlist(::google::protobuf::uint32 value) {
  sensoridlist_.Add(value);
  // @@protoc_insertion_point(field_add:PerceptionRegion.sensorIdList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PerceptionRegion::sensoridlist() const {
  // @@protoc_insertion_point(field_list:PerceptionRegion.sensorIdList)
  return sensoridlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PerceptionRegion::mutable_sensoridlist() {
  // @@protoc_insertion_point(field_mutable_list:PerceptionRegion.sensorIdList)
  return &sensoridlist_;
}

// optional uint32 numberOfPerceivedObjects = 6;
inline bool PerceptionRegion::has_numberofperceivedobjects() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerceptionRegion::set_has_numberofperceivedobjects() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerceptionRegion::clear_has_numberofperceivedobjects() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerceptionRegion::clear_numberofperceivedobjects() {
  numberofperceivedobjects_ = 0u;
  clear_has_numberofperceivedobjects();
}
inline ::google::protobuf::uint32 PerceptionRegion::numberofperceivedobjects() const {
  // @@protoc_insertion_point(field_get:PerceptionRegion.numberOfPerceivedObjects)
  return numberofperceivedobjects_;
}
inline void PerceptionRegion::set_numberofperceivedobjects(::google::protobuf::uint32 value) {
  set_has_numberofperceivedobjects();
  numberofperceivedobjects_ = value;
  // @@protoc_insertion_point(field_set:PerceptionRegion.numberOfPerceivedObjects)
}

// optional uint32 perceivedObjectIds = 7;
inline bool PerceptionRegion::has_perceivedobjectids() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PerceptionRegion::set_has_perceivedobjectids() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PerceptionRegion::clear_has_perceivedobjectids() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PerceptionRegion::clear_perceivedobjectids() {
  perceivedobjectids_ = 0u;
  clear_has_perceivedobjectids();
}
inline ::google::protobuf::uint32 PerceptionRegion::perceivedobjectids() const {
  // @@protoc_insertion_point(field_get:PerceptionRegion.perceivedObjectIds)
  return perceivedobjectids_;
}
inline void PerceptionRegion::set_perceivedobjectids(::google::protobuf::uint32 value) {
  set_has_perceivedobjectids();
  perceivedobjectids_ = value;
  // @@protoc_insertion_point(field_set:PerceptionRegion.perceivedObjectIds)
}

// -------------------------------------------------------------------

// PerceivedObjectContainer

// required uint32 numberOfPerceivedObjects = 1;
inline bool PerceivedObjectContainer::has_numberofperceivedobjects() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerceivedObjectContainer::set_has_numberofperceivedobjects() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerceivedObjectContainer::clear_has_numberofperceivedobjects() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerceivedObjectContainer::clear_numberofperceivedobjects() {
  numberofperceivedobjects_ = 0u;
  clear_has_numberofperceivedobjects();
}
inline ::google::protobuf::uint32 PerceivedObjectContainer::numberofperceivedobjects() const {
  // @@protoc_insertion_point(field_get:PerceivedObjectContainer.numberOfPerceivedObjects)
  return numberofperceivedobjects_;
}
inline void PerceivedObjectContainer::set_numberofperceivedobjects(::google::protobuf::uint32 value) {
  set_has_numberofperceivedobjects();
  numberofperceivedobjects_ = value;
  // @@protoc_insertion_point(field_set:PerceivedObjectContainer.numberOfPerceivedObjects)
}

// repeated .PerceivedObject perceivedObjects = 2;
inline int PerceivedObjectContainer::perceivedobjects_size() const {
  return perceivedobjects_.size();
}
inline void PerceivedObjectContainer::clear_perceivedobjects() {
  perceivedobjects_.Clear();
}
inline ::PerceivedObject* PerceivedObjectContainer::mutable_perceivedobjects(int index) {
  // @@protoc_insertion_point(field_mutable:PerceivedObjectContainer.perceivedObjects)
  return perceivedobjects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PerceivedObject >*
PerceivedObjectContainer::mutable_perceivedobjects() {
  // @@protoc_insertion_point(field_mutable_list:PerceivedObjectContainer.perceivedObjects)
  return &perceivedobjects_;
}
inline const ::PerceivedObject& PerceivedObjectContainer::perceivedobjects(int index) const {
  // @@protoc_insertion_point(field_get:PerceivedObjectContainer.perceivedObjects)
  return perceivedobjects_.Get(index);
}
inline ::PerceivedObject* PerceivedObjectContainer::add_perceivedobjects() {
  // @@protoc_insertion_point(field_add:PerceivedObjectContainer.perceivedObjects)
  return perceivedobjects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PerceivedObject >&
PerceivedObjectContainer::perceivedobjects() const {
  // @@protoc_insertion_point(field_list:PerceivedObjectContainer.perceivedObjects)
  return perceivedobjects_;
}

// -------------------------------------------------------------------

// PerceivedObject

// optional uint32 objectID = 1;
inline bool PerceivedObject::has_objectid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PerceivedObject::set_has_objectid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PerceivedObject::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PerceivedObject::clear_objectid() {
  objectid_ = 0u;
  clear_has_objectid();
}
inline ::google::protobuf::uint32 PerceivedObject::objectid() const {
  // @@protoc_insertion_point(field_get:PerceivedObject.objectID)
  return objectid_;
}
inline void PerceivedObject::set_objectid(::google::protobuf::uint32 value) {
  set_has_objectid();
  objectid_ = value;
  // @@protoc_insertion_point(field_set:PerceivedObject.objectID)
}

// required int32 measurementDeltaTime = 2;
inline bool PerceivedObject::has_measurementdeltatime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PerceivedObject::set_has_measurementdeltatime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PerceivedObject::clear_has_measurementdeltatime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PerceivedObject::clear_measurementdeltatime() {
  measurementdeltatime_ = 0;
  clear_has_measurementdeltatime();
}
inline ::google::protobuf::int32 PerceivedObject::measurementdeltatime() const {
  // @@protoc_insertion_point(field_get:PerceivedObject.measurementDeltaTime)
  return measurementdeltatime_;
}
inline void PerceivedObject::set_measurementdeltatime(::google::protobuf::int32 value) {
  set_has_measurementdeltatime();
  measurementdeltatime_ = value;
  // @@protoc_insertion_point(field_set:PerceivedObject.measurementDeltaTime)
}

// required .CartesianPosition3dWithConfidence position = 3;
inline bool PerceivedObject::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerceivedObject::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerceivedObject::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CartesianPosition3dWithConfidence& PerceivedObject::_internal_position() const {
  return *position_;
}
inline const ::CartesianPosition3dWithConfidence& PerceivedObject::position() const {
  const ::CartesianPosition3dWithConfidence* p = position_;
  // @@protoc_insertion_point(field_get:PerceivedObject.position)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianPosition3dWithConfidence*>(
      &::_CartesianPosition3dWithConfidence_default_instance_);
}
inline ::CartesianPosition3dWithConfidence* PerceivedObject::release_position() {
  // @@protoc_insertion_point(field_release:PerceivedObject.position)
  clear_has_position();
  ::CartesianPosition3dWithConfidence* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::CartesianPosition3dWithConfidence* PerceivedObject::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianPosition3dWithConfidence>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.position)
  return position_;
}
inline void PerceivedObject::set_allocated_position(::CartesianPosition3dWithConfidence* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.position)
}

// optional .Velocity3dWithConfidence velocity = 4;
inline bool PerceivedObject::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerceivedObject::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerceivedObject::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Velocity3dWithConfidence& PerceivedObject::_internal_velocity() const {
  return *velocity_;
}
inline const ::Velocity3dWithConfidence& PerceivedObject::velocity() const {
  const ::Velocity3dWithConfidence* p = velocity_;
  // @@protoc_insertion_point(field_get:PerceivedObject.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::Velocity3dWithConfidence*>(
      &::_Velocity3dWithConfidence_default_instance_);
}
inline ::Velocity3dWithConfidence* PerceivedObject::release_velocity() {
  // @@protoc_insertion_point(field_release:PerceivedObject.velocity)
  clear_has_velocity();
  ::Velocity3dWithConfidence* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::Velocity3dWithConfidence* PerceivedObject::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::Velocity3dWithConfidence>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.velocity)
  return velocity_;
}
inline void PerceivedObject::set_allocated_velocity(::Velocity3dWithConfidence* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.velocity)
}

// optional .Acceleration3dWithConfidence acceleration = 5;
inline bool PerceivedObject::has_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerceivedObject::set_has_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerceivedObject::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Acceleration3dWithConfidence& PerceivedObject::_internal_acceleration() const {
  return *acceleration_;
}
inline const ::Acceleration3dWithConfidence& PerceivedObject::acceleration() const {
  const ::Acceleration3dWithConfidence* p = acceleration_;
  // @@protoc_insertion_point(field_get:PerceivedObject.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::Acceleration3dWithConfidence*>(
      &::_Acceleration3dWithConfidence_default_instance_);
}
inline ::Acceleration3dWithConfidence* PerceivedObject::release_acceleration() {
  // @@protoc_insertion_point(field_release:PerceivedObject.acceleration)
  clear_has_acceleration();
  ::Acceleration3dWithConfidence* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline ::Acceleration3dWithConfidence* PerceivedObject::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::Acceleration3dWithConfidence>(GetArenaNoVirtual());
    acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.acceleration)
  return acceleration_;
}
inline void PerceivedObject::set_allocated_acceleration(::Acceleration3dWithConfidence* acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acceleration_);
  }
  if (acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.acceleration)
}

// optional .EulerAnglesWithConfidence angles = 6;
inline bool PerceivedObject::has_angles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerceivedObject::set_has_angles() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerceivedObject::clear_has_angles() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::EulerAnglesWithConfidence& PerceivedObject::_internal_angles() const {
  return *angles_;
}
inline const ::EulerAnglesWithConfidence& PerceivedObject::angles() const {
  const ::EulerAnglesWithConfidence* p = angles_;
  // @@protoc_insertion_point(field_get:PerceivedObject.angles)
  return p != NULL ? *p : *reinterpret_cast<const ::EulerAnglesWithConfidence*>(
      &::_EulerAnglesWithConfidence_default_instance_);
}
inline ::EulerAnglesWithConfidence* PerceivedObject::release_angles() {
  // @@protoc_insertion_point(field_release:PerceivedObject.angles)
  clear_has_angles();
  ::EulerAnglesWithConfidence* temp = angles_;
  angles_ = NULL;
  return temp;
}
inline ::EulerAnglesWithConfidence* PerceivedObject::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) {
    auto* p = CreateMaybeMessage<::EulerAnglesWithConfidence>(GetArenaNoVirtual());
    angles_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.angles)
  return angles_;
}
inline void PerceivedObject::set_allocated_angles(::EulerAnglesWithConfidence* angles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(angles_);
  }
  if (angles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angles, submessage_arena);
    }
    set_has_angles();
  } else {
    clear_has_angles();
  }
  angles_ = angles;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.angles)
}

// optional .CartesianAngularVelocityComponent zAngularVelocity = 7;
inline bool PerceivedObject::has_zangularvelocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerceivedObject::set_has_zangularvelocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerceivedObject::clear_has_zangularvelocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::CartesianAngularVelocityComponent& PerceivedObject::_internal_zangularvelocity() const {
  return *zangularvelocity_;
}
inline const ::CartesianAngularVelocityComponent& PerceivedObject::zangularvelocity() const {
  const ::CartesianAngularVelocityComponent* p = zangularvelocity_;
  // @@protoc_insertion_point(field_get:PerceivedObject.zAngularVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianAngularVelocityComponent*>(
      &::_CartesianAngularVelocityComponent_default_instance_);
}
inline ::CartesianAngularVelocityComponent* PerceivedObject::release_zangularvelocity() {
  // @@protoc_insertion_point(field_release:PerceivedObject.zAngularVelocity)
  clear_has_zangularvelocity();
  ::CartesianAngularVelocityComponent* temp = zangularvelocity_;
  zangularvelocity_ = NULL;
  return temp;
}
inline ::CartesianAngularVelocityComponent* PerceivedObject::mutable_zangularvelocity() {
  set_has_zangularvelocity();
  if (zangularvelocity_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianAngularVelocityComponent>(GetArenaNoVirtual());
    zangularvelocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.zAngularVelocity)
  return zangularvelocity_;
}
inline void PerceivedObject::set_allocated_zangularvelocity(::CartesianAngularVelocityComponent* zangularvelocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(zangularvelocity_);
  }
  if (zangularvelocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zangularvelocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zangularvelocity, submessage_arena);
    }
    set_has_zangularvelocity();
  } else {
    clear_has_zangularvelocity();
  }
  zangularvelocity_ = zangularvelocity;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.zAngularVelocity)
}

// repeated .LowerTriangularPositiveSemidefiniteMatrix lowerTriangularCorrelationMatrices = 8;
inline int PerceivedObject::lowertriangularcorrelationmatrices_size() const {
  return lowertriangularcorrelationmatrices_.size();
}
inline ::LowerTriangularPositiveSemidefiniteMatrix* PerceivedObject::mutable_lowertriangularcorrelationmatrices(int index) {
  // @@protoc_insertion_point(field_mutable:PerceivedObject.lowerTriangularCorrelationMatrices)
  return lowertriangularcorrelationmatrices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::LowerTriangularPositiveSemidefiniteMatrix >*
PerceivedObject::mutable_lowertriangularcorrelationmatrices() {
  // @@protoc_insertion_point(field_mutable_list:PerceivedObject.lowerTriangularCorrelationMatrices)
  return &lowertriangularcorrelationmatrices_;
}
inline const ::LowerTriangularPositiveSemidefiniteMatrix& PerceivedObject::lowertriangularcorrelationmatrices(int index) const {
  // @@protoc_insertion_point(field_get:PerceivedObject.lowerTriangularCorrelationMatrices)
  return lowertriangularcorrelationmatrices_.Get(index);
}
inline ::LowerTriangularPositiveSemidefiniteMatrix* PerceivedObject::add_lowertriangularcorrelationmatrices() {
  // @@protoc_insertion_point(field_add:PerceivedObject.lowerTriangularCorrelationMatrices)
  return lowertriangularcorrelationmatrices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LowerTriangularPositiveSemidefiniteMatrix >&
PerceivedObject::lowertriangularcorrelationmatrices() const {
  // @@protoc_insertion_point(field_list:PerceivedObject.lowerTriangularCorrelationMatrices)
  return lowertriangularcorrelationmatrices_;
}

// optional .ObjectDimension objectDimensionZ = 9;
inline bool PerceivedObject::has_objectdimensionz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PerceivedObject::set_has_objectdimensionz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PerceivedObject::clear_has_objectdimensionz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::ObjectDimension& PerceivedObject::_internal_objectdimensionz() const {
  return *objectdimensionz_;
}
inline const ::ObjectDimension& PerceivedObject::objectdimensionz() const {
  const ::ObjectDimension* p = objectdimensionz_;
  // @@protoc_insertion_point(field_get:PerceivedObject.objectDimensionZ)
  return p != NULL ? *p : *reinterpret_cast<const ::ObjectDimension*>(
      &::_ObjectDimension_default_instance_);
}
inline ::ObjectDimension* PerceivedObject::release_objectdimensionz() {
  // @@protoc_insertion_point(field_release:PerceivedObject.objectDimensionZ)
  clear_has_objectdimensionz();
  ::ObjectDimension* temp = objectdimensionz_;
  objectdimensionz_ = NULL;
  return temp;
}
inline ::ObjectDimension* PerceivedObject::mutable_objectdimensionz() {
  set_has_objectdimensionz();
  if (objectdimensionz_ == NULL) {
    auto* p = CreateMaybeMessage<::ObjectDimension>(GetArenaNoVirtual());
    objectdimensionz_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.objectDimensionZ)
  return objectdimensionz_;
}
inline void PerceivedObject::set_allocated_objectdimensionz(::ObjectDimension* objectdimensionz) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(objectdimensionz_);
  }
  if (objectdimensionz) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      objectdimensionz = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, objectdimensionz, submessage_arena);
    }
    set_has_objectdimensionz();
  } else {
    clear_has_objectdimensionz();
  }
  objectdimensionz_ = objectdimensionz;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.objectDimensionZ)
}

// optional .ObjectDimension objectDimensionY = 10;
inline bool PerceivedObject::has_objectdimensiony() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PerceivedObject::set_has_objectdimensiony() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PerceivedObject::clear_has_objectdimensiony() {
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::ObjectDimension& PerceivedObject::_internal_objectdimensiony() const {
  return *objectdimensiony_;
}
inline const ::ObjectDimension& PerceivedObject::objectdimensiony() const {
  const ::ObjectDimension* p = objectdimensiony_;
  // @@protoc_insertion_point(field_get:PerceivedObject.objectDimensionY)
  return p != NULL ? *p : *reinterpret_cast<const ::ObjectDimension*>(
      &::_ObjectDimension_default_instance_);
}
inline ::ObjectDimension* PerceivedObject::release_objectdimensiony() {
  // @@protoc_insertion_point(field_release:PerceivedObject.objectDimensionY)
  clear_has_objectdimensiony();
  ::ObjectDimension* temp = objectdimensiony_;
  objectdimensiony_ = NULL;
  return temp;
}
inline ::ObjectDimension* PerceivedObject::mutable_objectdimensiony() {
  set_has_objectdimensiony();
  if (objectdimensiony_ == NULL) {
    auto* p = CreateMaybeMessage<::ObjectDimension>(GetArenaNoVirtual());
    objectdimensiony_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.objectDimensionY)
  return objectdimensiony_;
}
inline void PerceivedObject::set_allocated_objectdimensiony(::ObjectDimension* objectdimensiony) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(objectdimensiony_);
  }
  if (objectdimensiony) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      objectdimensiony = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, objectdimensiony, submessage_arena);
    }
    set_has_objectdimensiony();
  } else {
    clear_has_objectdimensiony();
  }
  objectdimensiony_ = objectdimensiony;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.objectDimensionY)
}

// optional .ObjectDimension objectDimensionX = 11;
inline bool PerceivedObject::has_objectdimensionx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PerceivedObject::set_has_objectdimensionx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PerceivedObject::clear_has_objectdimensionx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::ObjectDimension& PerceivedObject::_internal_objectdimensionx() const {
  return *objectdimensionx_;
}
inline const ::ObjectDimension& PerceivedObject::objectdimensionx() const {
  const ::ObjectDimension* p = objectdimensionx_;
  // @@protoc_insertion_point(field_get:PerceivedObject.objectDimensionX)
  return p != NULL ? *p : *reinterpret_cast<const ::ObjectDimension*>(
      &::_ObjectDimension_default_instance_);
}
inline ::ObjectDimension* PerceivedObject::release_objectdimensionx() {
  // @@protoc_insertion_point(field_release:PerceivedObject.objectDimensionX)
  clear_has_objectdimensionx();
  ::ObjectDimension* temp = objectdimensionx_;
  objectdimensionx_ = NULL;
  return temp;
}
inline ::ObjectDimension* PerceivedObject::mutable_objectdimensionx() {
  set_has_objectdimensionx();
  if (objectdimensionx_ == NULL) {
    auto* p = CreateMaybeMessage<::ObjectDimension>(GetArenaNoVirtual());
    objectdimensionx_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.objectDimensionX)
  return objectdimensionx_;
}
inline void PerceivedObject::set_allocated_objectdimensionx(::ObjectDimension* objectdimensionx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(objectdimensionx_);
  }
  if (objectdimensionx) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      objectdimensionx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, objectdimensionx, submessage_arena);
    }
    set_has_objectdimensionx();
  } else {
    clear_has_objectdimensionx();
  }
  objectdimensionx_ = objectdimensionx;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.objectDimensionX)
}

// optional uint32 objectAge = 12;
inline bool PerceivedObject::has_objectage() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PerceivedObject::set_has_objectage() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PerceivedObject::clear_has_objectage() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PerceivedObject::clear_objectage() {
  objectage_ = 0u;
  clear_has_objectage();
}
inline ::google::protobuf::uint32 PerceivedObject::objectage() const {
  // @@protoc_insertion_point(field_get:PerceivedObject.objectAge)
  return objectage_;
}
inline void PerceivedObject::set_objectage(::google::protobuf::uint32 value) {
  set_has_objectage();
  objectage_ = value;
  // @@protoc_insertion_point(field_set:PerceivedObject.objectAge)
}

// optional uint32 objectPerceptionQuality = 13;
inline bool PerceivedObject::has_objectperceptionquality() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PerceivedObject::set_has_objectperceptionquality() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PerceivedObject::clear_has_objectperceptionquality() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PerceivedObject::clear_objectperceptionquality() {
  objectperceptionquality_ = 0u;
  clear_has_objectperceptionquality();
}
inline ::google::protobuf::uint32 PerceivedObject::objectperceptionquality() const {
  // @@protoc_insertion_point(field_get:PerceivedObject.objectPerceptionQuality)
  return objectperceptionquality_;
}
inline void PerceivedObject::set_objectperceptionquality(::google::protobuf::uint32 value) {
  set_has_objectperceptionquality();
  objectperceptionquality_ = value;
  // @@protoc_insertion_point(field_set:PerceivedObject.objectPerceptionQuality)
}

// repeated uint32 sensorIdList = 14;
inline int PerceivedObject::sensoridlist_size() const {
  return sensoridlist_.size();
}
inline void PerceivedObject::clear_sensoridlist() {
  sensoridlist_.Clear();
}
inline ::google::protobuf::uint32 PerceivedObject::sensoridlist(int index) const {
  // @@protoc_insertion_point(field_get:PerceivedObject.sensorIdList)
  return sensoridlist_.Get(index);
}
inline void PerceivedObject::set_sensoridlist(int index, ::google::protobuf::uint32 value) {
  sensoridlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:PerceivedObject.sensorIdList)
}
inline void PerceivedObject::add_sensoridlist(::google::protobuf::uint32 value) {
  sensoridlist_.Add(value);
  // @@protoc_insertion_point(field_add:PerceivedObject.sensorIdList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PerceivedObject::sensoridlist() const {
  // @@protoc_insertion_point(field_list:PerceivedObject.sensorIdList)
  return sensoridlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PerceivedObject::mutable_sensoridlist() {
  // @@protoc_insertion_point(field_mutable_list:PerceivedObject.sensorIdList)
  return &sensoridlist_;
}

// repeated .ObjectClassWithConfidence classification = 15;
inline int PerceivedObject::classification_size() const {
  return classification_.size();
}
inline ::ObjectClassWithConfidence* PerceivedObject::mutable_classification(int index) {
  // @@protoc_insertion_point(field_mutable:PerceivedObject.classification)
  return classification_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ObjectClassWithConfidence >*
PerceivedObject::mutable_classification() {
  // @@protoc_insertion_point(field_mutable_list:PerceivedObject.classification)
  return &classification_;
}
inline const ::ObjectClassWithConfidence& PerceivedObject::classification(int index) const {
  // @@protoc_insertion_point(field_get:PerceivedObject.classification)
  return classification_.Get(index);
}
inline ::ObjectClassWithConfidence* PerceivedObject::add_classification() {
  // @@protoc_insertion_point(field_add:PerceivedObject.classification)
  return classification_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ObjectClassWithConfidence >&
PerceivedObject::classification() const {
  // @@protoc_insertion_point(field_list:PerceivedObject.classification)
  return classification_;
}

// required .MapPosition mapPosition = 16;
inline bool PerceivedObject::has_mapposition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PerceivedObject::set_has_mapposition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PerceivedObject::clear_has_mapposition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::MapPosition& PerceivedObject::_internal_mapposition() const {
  return *mapposition_;
}
inline const ::MapPosition& PerceivedObject::mapposition() const {
  const ::MapPosition* p = mapposition_;
  // @@protoc_insertion_point(field_get:PerceivedObject.mapPosition)
  return p != NULL ? *p : *reinterpret_cast<const ::MapPosition*>(
      &::_MapPosition_default_instance_);
}
inline ::MapPosition* PerceivedObject::release_mapposition() {
  // @@protoc_insertion_point(field_release:PerceivedObject.mapPosition)
  clear_has_mapposition();
  ::MapPosition* temp = mapposition_;
  mapposition_ = NULL;
  return temp;
}
inline ::MapPosition* PerceivedObject::mutable_mapposition() {
  set_has_mapposition();
  if (mapposition_ == NULL) {
    auto* p = CreateMaybeMessage<::MapPosition>(GetArenaNoVirtual());
    mapposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PerceivedObject.mapPosition)
  return mapposition_;
}
inline void PerceivedObject::set_allocated_mapposition(::MapPosition* mapposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mapposition_);
  }
  if (mapposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mapposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mapposition, submessage_arena);
    }
    set_has_mapposition();
  } else {
    clear_has_mapposition();
  }
  mapposition_ = mapposition;
  // @@protoc_insertion_point(field_set_allocated:PerceivedObject.mapPosition)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_cpm_5finterface_2eproto
