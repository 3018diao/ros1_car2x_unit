// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ETSIITSCDD_H_
#define FLATBUFFERS_GENERATED_ETSIITSCDD_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

struct Acceleration3dWithConfidence;
struct Acceleration3dWithConfidenceBuilder;

namespace Acceleration3dWithConfidence_ {

struct Anonymous0;
struct Anonymous0Builder;

}  // namespace Acceleration3dWithConfidence_

struct AccelerationCartesian;
struct AccelerationCartesianBuilder;

struct AccelerationComponent;
struct AccelerationComponentBuilder;

struct AccelerationMagnitude;
struct AccelerationMagnitudeBuilder;

struct AccelerationPolarWithZ;
struct AccelerationPolarWithZBuilder;

struct ActionID;
struct ActionIDBuilder;

struct Altitude;
struct AltitudeBuilder;

struct CartesianAngle;
struct CartesianAngleBuilder;

struct CartesianAngularVelocityComponent;
struct CartesianAngularVelocityComponentBuilder;

struct CartesianPosition3d;
struct CartesianPosition3dBuilder;

struct CartesianCoordinateWithConfidence;
struct CartesianCoordinateWithConfidenceBuilder;

struct CartesianPosition3dWithConfidence;
struct CartesianPosition3dWithConfidenceBuilder;

struct CircularShape;
struct CircularShapeBuilder;

struct ClosedLanes;
struct ClosedLanesBuilder;

struct CorrelationColumn;
struct CorrelationColumnBuilder;

struct Curvature;
struct CurvatureBuilder;

struct CauseCode;
struct CauseCodeBuilder;

struct DangerousGoodsExtended;
struct DangerousGoodsExtendedBuilder;

struct DeltaReferencePosition;
struct DeltaReferencePositionBuilder;

struct EnergyStorageType;
struct EnergyStorageTypeBuilder;

struct EllipticalShape;
struct EllipticalShapeBuilder;

struct EulerAnglesWithConfidence;
struct EulerAnglesWithConfidenceBuilder;

struct EventHistory;
struct EventHistoryBuilder;

struct EventPoint;
struct EventPointBuilder;

struct Heading;
struct HeadingBuilder;

struct IntersectionReferenceID;
struct IntersectionReferenceIDBuilder;

struct ItineraryPath;
struct ItineraryPathBuilder;

struct LongitudinalAcceleration;
struct LongitudinalAccelerationBuilder;

struct LongitudinalLanePosition;
struct LongitudinalLanePositionBuilder;

struct LowerTriangularPositiveSemidefiniteMatrix;
struct LowerTriangularPositiveSemidefiniteMatrixBuilder;

struct LowerTriangularPositiveSemidefiniteMatrixColumns;
struct LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder;

struct MapPosition;
struct MapPositionBuilder;

struct MapReference;
struct MapReferenceBuilder;

namespace MapReference_ {

struct Anonymous1;
struct Anonymous1Builder;

}  // namespace MapReference_

struct MatrixIncludedComponents;
struct MatrixIncludedComponentsBuilder;

struct MessageRateHz;
struct MessageRateHzBuilder;

struct MessageSegmentationInfo;
struct MessageSegmentationInfoBuilder;

struct ObjectClass;
struct ObjectClassBuilder;

namespace ObjectClass_ {

struct Anonymous2;
struct Anonymous2Builder;

}  // namespace ObjectClass_

struct ObjectClassWithConfidence;
struct ObjectClassWithConfidenceBuilder;

struct ObjectDimension;
struct ObjectDimensionBuilder;

struct OtherSubClass;
struct OtherSubClassBuilder;

struct PolygonalShape;
struct PolygonalShapeBuilder;

struct PositionConfidenceEllipse;
struct PositionConfidenceEllipseBuilder;

struct RadialShape;
struct RadialShapeBuilder;

struct RadialShapes;
struct RadialShapesBuilder;

struct RadialShapeDetails;
struct RadialShapeDetailsBuilder;

struct RectangularShape;
struct RectangularShapeBuilder;

struct ReferenceDenms;
struct ReferenceDenmsBuilder;

struct ReferencePosition;
struct ReferencePositionBuilder;

struct RestrictedTypes;
struct RestrictedTypesBuilder;

struct RoadSegmentReferenceID;
struct RoadSegmentReferenceIDBuilder;

struct Shape;
struct ShapeBuilder;

namespace Shape_ {

struct Anonymous3;
struct Anonymous3Builder;

}  // namespace Shape_

struct Speed;
struct SpeedBuilder;

struct VehicleIdentification;
struct VehicleIdentificationBuilder;

struct VehicleLength;
struct VehicleLengthBuilder;

struct VehicleWidth;
struct VehicleWidthBuilder;

struct VelocityCartesian;
struct VelocityCartesianBuilder;

struct VelocityComponent;
struct VelocityComponentBuilder;

struct VelocityPolarWithZ;
struct VelocityPolarWithZBuilder;

struct Velocity3dWithConfidence;
struct Velocity3dWithConfidenceBuilder;

namespace Velocity3dWithConfidence_ {

struct Anonymous4;
struct Anonymous4Builder;

}  // namespace Velocity3dWithConfidence_

struct VruClusterInformation;
struct VruClusterInformationBuilder;

struct VruClusterProfiles;
struct VruClusterProfilesBuilder;

struct VruProfileAndSubprofile;
struct VruProfileAndSubprofileBuilder;

namespace VruProfileAndSubprofile_ {

struct Anonymous5;
struct Anonymous5Builder;

}  // namespace VruProfileAndSubprofile_

struct Wgs84Angle;
struct Wgs84AngleBuilder;

struct YawRate;
struct YawRateBuilder;

enum AngularSpeedConfidence : int32_t {
  AngularSpeedConfidence_ASC_DEGSEC_01 = 0,
  AngularSpeedConfidence_ASC_DEGSEC_02 = 1,
  AngularSpeedConfidence_ASC_DEGSEC_05 = 2,
  AngularSpeedConfidence_ASC_DEGSEC_10 = 3,
  AngularSpeedConfidence_ASC_DEGSEC_20 = 4,
  AngularSpeedConfidence_ASC_DEGSEC_50 = 5,
  AngularSpeedConfidence_ASC_OUTOFRANGE = 6,
  AngularSpeedConfidence_ASC_UNAVAILABLE = 7,
  AngularSpeedConfidence_MIN = AngularSpeedConfidence_ASC_DEGSEC_01,
  AngularSpeedConfidence_MAX = AngularSpeedConfidence_ASC_UNAVAILABLE
};

inline const AngularSpeedConfidence (&EnumValuesAngularSpeedConfidence())[8] {
  static const AngularSpeedConfidence values[] = {
    AngularSpeedConfidence_ASC_DEGSEC_01,
    AngularSpeedConfidence_ASC_DEGSEC_02,
    AngularSpeedConfidence_ASC_DEGSEC_05,
    AngularSpeedConfidence_ASC_DEGSEC_10,
    AngularSpeedConfidence_ASC_DEGSEC_20,
    AngularSpeedConfidence_ASC_DEGSEC_50,
    AngularSpeedConfidence_ASC_OUTOFRANGE,
    AngularSpeedConfidence_ASC_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesAngularSpeedConfidence() {
  static const char * const names[9] = {
    "ASC_DEGSEC_01",
    "ASC_DEGSEC_02",
    "ASC_DEGSEC_05",
    "ASC_DEGSEC_10",
    "ASC_DEGSEC_20",
    "ASC_DEGSEC_50",
    "ASC_OUTOFRANGE",
    "ASC_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAngularSpeedConfidence(AngularSpeedConfidence e) {
  if (::flatbuffers::IsOutRange(e, AngularSpeedConfidence_ASC_DEGSEC_01, AngularSpeedConfidence_ASC_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAngularSpeedConfidence()[index];
}

enum CurvatureCalculationMode : int32_t {
  CurvatureCalculationMode_CCM_YAWRATEUSED = 0,
  CurvatureCalculationMode_CCM_YAWRATENOTUSED = 1,
  CurvatureCalculationMode_CCM_UNAVAILABLE = 2,
  CurvatureCalculationMode_MIN = CurvatureCalculationMode_CCM_YAWRATEUSED,
  CurvatureCalculationMode_MAX = CurvatureCalculationMode_CCM_UNAVAILABLE
};

inline const CurvatureCalculationMode (&EnumValuesCurvatureCalculationMode())[3] {
  static const CurvatureCalculationMode values[] = {
    CurvatureCalculationMode_CCM_YAWRATEUSED,
    CurvatureCalculationMode_CCM_YAWRATENOTUSED,
    CurvatureCalculationMode_CCM_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesCurvatureCalculationMode() {
  static const char * const names[4] = {
    "CCM_YAWRATEUSED",
    "CCM_YAWRATENOTUSED",
    "CCM_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurvatureCalculationMode(CurvatureCalculationMode e) {
  if (::flatbuffers::IsOutRange(e, CurvatureCalculationMode_CCM_YAWRATEUSED, CurvatureCalculationMode_CCM_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurvatureCalculationMode()[index];
}

enum CauseCodeType : int32_t {
  CauseCodeType_CC_TYPE_UNAVAILABLE = 0,
  CauseCodeType_CCT_TRAFFICCONDITION = 1,
  CauseCodeType_CCT_ACCIDENT = 2,
  CauseCodeType_CCT_ROADWORKS = 3,
  CauseCodeType_CCT_IMPASSABILITY = 5,
  CauseCodeType_CCT_ADVERSEWEATHERCONDITION_ADHESION = 6,
  CauseCodeType_CCT_AQUAPLANING = 7,
  CauseCodeType_CCT_HAZARDOUSLOCATION_SURFACECONDITION = 9,
  CauseCodeType_CCT_HAZARDOUSLOCATION_OBSTACLEONTHEROAD = 10,
  CauseCodeType_CCT_HAZARDOUSLOCATION_ANIMALONTHEROAD = 11,
  CauseCodeType_CCT_HUMANPRESENCEONTHEROAD = 12,
  CauseCodeType_CCT_WRONGWAYDRIVING = 14,
  CauseCodeType_CCT_RESCUEANDRECOVERYWORKINPROGRESS = 15,
  CauseCodeType_CCT_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITION = 17,
  CauseCodeType_CCT_ADVERSEWEATHERCONDITION_VISIBILITY = 18,
  CauseCodeType_CCT_ADVERSEWEATHERCONDITION_PRECIPITATION = 19,
  CauseCodeType_CCT_VIOLENCE = 20,
  CauseCodeType_CCT_SLOWVEHICLE = 26,
  CauseCodeType_CCT_DANGEROUSENDOFQUEUE = 27,
  CauseCodeType_CCT_VEHICLEBREAKDOWN = 91,
  CauseCodeType_CCT_POSTCRASH = 92,
  CauseCodeType_CCT_HUMANPROBLEM = 93,
  CauseCodeType_CCT_STATIONARYVEHICLE = 94,
  CauseCodeType_CCT_EMERGENCYVEHICLEAPPROACHING = 95,
  CauseCodeType_CCT_HAZARDOUSLOCATION_DANGEROUSCURVE = 96,
  CauseCodeType_CCT_COLLISIONRISK = 97,
  CauseCodeType_CCT_SIGNALVIOLATION = 98,
  CauseCodeType_CCT_DANGEROUSSITUATION = 99,
  CauseCodeType_CCT_RAILWAYLEVELCROSSING = 100,
  CauseCodeType_MIN = CauseCodeType_CC_TYPE_UNAVAILABLE,
  CauseCodeType_MAX = CauseCodeType_CCT_RAILWAYLEVELCROSSING
};

inline const CauseCodeType (&EnumValuesCauseCodeType())[29] {
  static const CauseCodeType values[] = {
    CauseCodeType_CC_TYPE_UNAVAILABLE,
    CauseCodeType_CCT_TRAFFICCONDITION,
    CauseCodeType_CCT_ACCIDENT,
    CauseCodeType_CCT_ROADWORKS,
    CauseCodeType_CCT_IMPASSABILITY,
    CauseCodeType_CCT_ADVERSEWEATHERCONDITION_ADHESION,
    CauseCodeType_CCT_AQUAPLANING,
    CauseCodeType_CCT_HAZARDOUSLOCATION_SURFACECONDITION,
    CauseCodeType_CCT_HAZARDOUSLOCATION_OBSTACLEONTHEROAD,
    CauseCodeType_CCT_HAZARDOUSLOCATION_ANIMALONTHEROAD,
    CauseCodeType_CCT_HUMANPRESENCEONTHEROAD,
    CauseCodeType_CCT_WRONGWAYDRIVING,
    CauseCodeType_CCT_RESCUEANDRECOVERYWORKINPROGRESS,
    CauseCodeType_CCT_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITION,
    CauseCodeType_CCT_ADVERSEWEATHERCONDITION_VISIBILITY,
    CauseCodeType_CCT_ADVERSEWEATHERCONDITION_PRECIPITATION,
    CauseCodeType_CCT_VIOLENCE,
    CauseCodeType_CCT_SLOWVEHICLE,
    CauseCodeType_CCT_DANGEROUSENDOFQUEUE,
    CauseCodeType_CCT_VEHICLEBREAKDOWN,
    CauseCodeType_CCT_POSTCRASH,
    CauseCodeType_CCT_HUMANPROBLEM,
    CauseCodeType_CCT_STATIONARYVEHICLE,
    CauseCodeType_CCT_EMERGENCYVEHICLEAPPROACHING,
    CauseCodeType_CCT_HAZARDOUSLOCATION_DANGEROUSCURVE,
    CauseCodeType_CCT_COLLISIONRISK,
    CauseCodeType_CCT_SIGNALVIOLATION,
    CauseCodeType_CCT_DANGEROUSSITUATION,
    CauseCodeType_CCT_RAILWAYLEVELCROSSING
  };
  return values;
}

inline const char * const *EnumNamesCauseCodeType() {
  static const char * const names[102] = {
    "CC_TYPE_UNAVAILABLE",
    "CCT_TRAFFICCONDITION",
    "CCT_ACCIDENT",
    "CCT_ROADWORKS",
    "",
    "CCT_IMPASSABILITY",
    "CCT_ADVERSEWEATHERCONDITION_ADHESION",
    "CCT_AQUAPLANING",
    "",
    "CCT_HAZARDOUSLOCATION_SURFACECONDITION",
    "CCT_HAZARDOUSLOCATION_OBSTACLEONTHEROAD",
    "CCT_HAZARDOUSLOCATION_ANIMALONTHEROAD",
    "CCT_HUMANPRESENCEONTHEROAD",
    "",
    "CCT_WRONGWAYDRIVING",
    "CCT_RESCUEANDRECOVERYWORKINPROGRESS",
    "",
    "CCT_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITION",
    "CCT_ADVERSEWEATHERCONDITION_VISIBILITY",
    "CCT_ADVERSEWEATHERCONDITION_PRECIPITATION",
    "CCT_VIOLENCE",
    "",
    "",
    "",
    "",
    "",
    "CCT_SLOWVEHICLE",
    "CCT_DANGEROUSENDOFQUEUE",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "CCT_VEHICLEBREAKDOWN",
    "CCT_POSTCRASH",
    "CCT_HUMANPROBLEM",
    "CCT_STATIONARYVEHICLE",
    "CCT_EMERGENCYVEHICLEAPPROACHING",
    "CCT_HAZARDOUSLOCATION_DANGEROUSCURVE",
    "CCT_COLLISIONRISK",
    "CCT_SIGNALVIOLATION",
    "CCT_DANGEROUSSITUATION",
    "CCT_RAILWAYLEVELCROSSING",
    nullptr
  };
  return names;
}

inline const char *EnumNameCauseCodeType(CauseCodeType e) {
  if (::flatbuffers::IsOutRange(e, CauseCodeType_CC_TYPE_UNAVAILABLE, CauseCodeType_CCT_RAILWAYLEVELCROSSING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCauseCodeType()[index];
}

enum DangerousGoodsBasic : int32_t {
  DangerousGoodsBasic_DGB_EXPLOSIVES1 = 0,
  DangerousGoodsBasic_DGB_EXPLOSIVES2 = 1,
  DangerousGoodsBasic_DGB_EXPLOSIVES3 = 2,
  DangerousGoodsBasic_DGB_EXPLOSIVES4 = 3,
  DangerousGoodsBasic_DGB_EXPLOSIVES5 = 4,
  DangerousGoodsBasic_DGB_EXPLOSIVES6 = 5,
  DangerousGoodsBasic_DGB_FLAMMABLEGASES = 6,
  DangerousGoodsBasic_DGB_NONFLAMMABLEGASES = 7,
  DangerousGoodsBasic_DGB_TOXICGASES = 8,
  DangerousGoodsBasic_DGB_FLAMMABLELIQUIDS = 9,
  DangerousGoodsBasic_DGB_FLAMMABLESOLIDS = 10,
  DangerousGoodsBasic_DGB_SUBSTANCESLIABLETOSPONTANEOUSCOMBUSTION = 11,
  DangerousGoodsBasic_DGB_SUBSTANCESEMITTINGFLAMMABLEGASESUPONCONTACTWITHWATER = 12,
  DangerousGoodsBasic_DGB_OXIDIZINGSUBSTANCES = 13,
  DangerousGoodsBasic_DGB_ORGANICPEROXIDES = 14,
  DangerousGoodsBasic_DGB_TOXICSUBSTANCES = 15,
  DangerousGoodsBasic_DGB_INFECTIOUSSUBSTANCES = 16,
  DangerousGoodsBasic_DGB_RADIOACTIVEMATERIAL = 17,
  DangerousGoodsBasic_DGB_CORROSIVESUBSTANCES = 18,
  DangerousGoodsBasic_DGB_MISCELLANEOUSDANGEROUSSUBSTANCES = 19,
  DangerousGoodsBasic_MIN = DangerousGoodsBasic_DGB_EXPLOSIVES1,
  DangerousGoodsBasic_MAX = DangerousGoodsBasic_DGB_MISCELLANEOUSDANGEROUSSUBSTANCES
};

inline const DangerousGoodsBasic (&EnumValuesDangerousGoodsBasic())[20] {
  static const DangerousGoodsBasic values[] = {
    DangerousGoodsBasic_DGB_EXPLOSIVES1,
    DangerousGoodsBasic_DGB_EXPLOSIVES2,
    DangerousGoodsBasic_DGB_EXPLOSIVES3,
    DangerousGoodsBasic_DGB_EXPLOSIVES4,
    DangerousGoodsBasic_DGB_EXPLOSIVES5,
    DangerousGoodsBasic_DGB_EXPLOSIVES6,
    DangerousGoodsBasic_DGB_FLAMMABLEGASES,
    DangerousGoodsBasic_DGB_NONFLAMMABLEGASES,
    DangerousGoodsBasic_DGB_TOXICGASES,
    DangerousGoodsBasic_DGB_FLAMMABLELIQUIDS,
    DangerousGoodsBasic_DGB_FLAMMABLESOLIDS,
    DangerousGoodsBasic_DGB_SUBSTANCESLIABLETOSPONTANEOUSCOMBUSTION,
    DangerousGoodsBasic_DGB_SUBSTANCESEMITTINGFLAMMABLEGASESUPONCONTACTWITHWATER,
    DangerousGoodsBasic_DGB_OXIDIZINGSUBSTANCES,
    DangerousGoodsBasic_DGB_ORGANICPEROXIDES,
    DangerousGoodsBasic_DGB_TOXICSUBSTANCES,
    DangerousGoodsBasic_DGB_INFECTIOUSSUBSTANCES,
    DangerousGoodsBasic_DGB_RADIOACTIVEMATERIAL,
    DangerousGoodsBasic_DGB_CORROSIVESUBSTANCES,
    DangerousGoodsBasic_DGB_MISCELLANEOUSDANGEROUSSUBSTANCES
  };
  return values;
}

inline const char * const *EnumNamesDangerousGoodsBasic() {
  static const char * const names[21] = {
    "DGB_EXPLOSIVES1",
    "DGB_EXPLOSIVES2",
    "DGB_EXPLOSIVES3",
    "DGB_EXPLOSIVES4",
    "DGB_EXPLOSIVES5",
    "DGB_EXPLOSIVES6",
    "DGB_FLAMMABLEGASES",
    "DGB_NONFLAMMABLEGASES",
    "DGB_TOXICGASES",
    "DGB_FLAMMABLELIQUIDS",
    "DGB_FLAMMABLESOLIDS",
    "DGB_SUBSTANCESLIABLETOSPONTANEOUSCOMBUSTION",
    "DGB_SUBSTANCESEMITTINGFLAMMABLEGASESUPONCONTACTWITHWATER",
    "DGB_OXIDIZINGSUBSTANCES",
    "DGB_ORGANICPEROXIDES",
    "DGB_TOXICSUBSTANCES",
    "DGB_INFECTIOUSSUBSTANCES",
    "DGB_RADIOACTIVEMATERIAL",
    "DGB_CORROSIVESUBSTANCES",
    "DGB_MISCELLANEOUSDANGEROUSSUBSTANCES",
    nullptr
  };
  return names;
}

inline const char *EnumNameDangerousGoodsBasic(DangerousGoodsBasic e) {
  if (::flatbuffers::IsOutRange(e, DangerousGoodsBasic_DGB_EXPLOSIVES1, DangerousGoodsBasic_DGB_MISCELLANEOUSDANGEROUSSUBSTANCES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDangerousGoodsBasic()[index];
}

enum DriveDirection : int32_t {
  DriveDirection_DD_FORWARD = 0,
  DriveDirection_DD_BACKWARD = 1,
  DriveDirection_DD_UNAVAILABLE = 2,
  DriveDirection_MIN = DriveDirection_DD_FORWARD,
  DriveDirection_MAX = DriveDirection_DD_UNAVAILABLE
};

inline const DriveDirection (&EnumValuesDriveDirection())[3] {
  static const DriveDirection values[] = {
    DriveDirection_DD_FORWARD,
    DriveDirection_DD_BACKWARD,
    DriveDirection_DD_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesDriveDirection() {
  static const char * const names[4] = {
    "DD_FORWARD",
    "DD_BACKWARD",
    "DD_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDriveDirection(DriveDirection e) {
  if (::flatbuffers::IsOutRange(e, DriveDirection_DD_FORWARD, DriveDirection_DD_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDriveDirection()[index];
}

enum HardShoulderStatus : int32_t {
  HardShoulderStatus_HSS_AVAILABLEFORSTOPPING = 0,
  HardShoulderStatus_HSS_CLOSED = 1,
  HardShoulderStatus_HSS_AVAILABLEFORDRIVING = 2,
  HardShoulderStatus_MIN = HardShoulderStatus_HSS_AVAILABLEFORSTOPPING,
  HardShoulderStatus_MAX = HardShoulderStatus_HSS_AVAILABLEFORDRIVING
};

inline const HardShoulderStatus (&EnumValuesHardShoulderStatus())[3] {
  static const HardShoulderStatus values[] = {
    HardShoulderStatus_HSS_AVAILABLEFORSTOPPING,
    HardShoulderStatus_HSS_CLOSED,
    HardShoulderStatus_HSS_AVAILABLEFORDRIVING
  };
  return values;
}

inline const char * const *EnumNamesHardShoulderStatus() {
  static const char * const names[4] = {
    "HSS_AVAILABLEFORSTOPPING",
    "HSS_CLOSED",
    "HSS_AVAILABLEFORDRIVING",
    nullptr
  };
  return names;
}

inline const char *EnumNameHardShoulderStatus(HardShoulderStatus e) {
  if (::flatbuffers::IsOutRange(e, HardShoulderStatus_HSS_AVAILABLEFORSTOPPING, HardShoulderStatus_HSS_AVAILABLEFORDRIVING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHardShoulderStatus()[index];
}

enum LightBarSirenInUse : int32_t {
  LightBarSirenInUse_LS_LIGHTBARACTIVATED = 0,
  LightBarSirenInUse_LS_SIRENACTIVATED = 1,
  LightBarSirenInUse_MIN = LightBarSirenInUse_LS_LIGHTBARACTIVATED,
  LightBarSirenInUse_MAX = LightBarSirenInUse_LS_SIRENACTIVATED
};

inline const LightBarSirenInUse (&EnumValuesLightBarSirenInUse())[2] {
  static const LightBarSirenInUse values[] = {
    LightBarSirenInUse_LS_LIGHTBARACTIVATED,
    LightBarSirenInUse_LS_SIRENACTIVATED
  };
  return values;
}

inline const char * const *EnumNamesLightBarSirenInUse() {
  static const char * const names[3] = {
    "LS_LIGHTBARACTIVATED",
    "LS_SIRENACTIVATED",
    nullptr
  };
  return names;
}

inline const char *EnumNameLightBarSirenInUse(LightBarSirenInUse e) {
  if (::flatbuffers::IsOutRange(e, LightBarSirenInUse_LS_LIGHTBARACTIVATED, LightBarSirenInUse_LS_SIRENACTIVATED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLightBarSirenInUse()[index];
}

enum PositioningSolutionType : int32_t {
  PositioningSolutionType_PST_NOPOSITIONINGSOLUTION = 0,
  PositioningSolutionType_PST_SGNSS = 1,
  PositioningSolutionType_PST_DGNSS = 2,
  PositioningSolutionType_PST_SGNSSPLUSDR = 3,
  PositioningSolutionType_PST_DGNSSPLUSDR = 4,
  PositioningSolutionType_PST_DR = 5,
  PositioningSolutionType_MIN = PositioningSolutionType_PST_NOPOSITIONINGSOLUTION,
  PositioningSolutionType_MAX = PositioningSolutionType_PST_DR
};

inline const PositioningSolutionType (&EnumValuesPositioningSolutionType())[6] {
  static const PositioningSolutionType values[] = {
    PositioningSolutionType_PST_NOPOSITIONINGSOLUTION,
    PositioningSolutionType_PST_SGNSS,
    PositioningSolutionType_PST_DGNSS,
    PositioningSolutionType_PST_SGNSSPLUSDR,
    PositioningSolutionType_PST_DGNSSPLUSDR,
    PositioningSolutionType_PST_DR
  };
  return values;
}

inline const char * const *EnumNamesPositioningSolutionType() {
  static const char * const names[7] = {
    "PST_NOPOSITIONINGSOLUTION",
    "PST_SGNSS",
    "PST_DGNSS",
    "PST_SGNSSPLUSDR",
    "PST_DGNSSPLUSDR",
    "PST_DR",
    nullptr
  };
  return names;
}

inline const char *EnumNamePositioningSolutionType(PositioningSolutionType e) {
  if (::flatbuffers::IsOutRange(e, PositioningSolutionType_PST_NOPOSITIONINGSOLUTION, PositioningSolutionType_PST_DR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPositioningSolutionType()[index];
}

enum PositionOfOccupants : int32_t {
  PositionOfOccupants_POS_OCC_ROW1LEFTOCCUPIED = 0,
  PositionOfOccupants_POS_OCC_ROW1RIGHTOCCUPIED = 1,
  PositionOfOccupants_POS_OCC_ROW1MIDOCCUPIED = 2,
  PositionOfOccupants_POS_OCC_ROW1NOTDETECTABLE = 3,
  PositionOfOccupants_POS_OCC_ROW1NOTPRESENT = 4,
  PositionOfOccupants_POS_OCC_ROW2LEFTOCCUPIED = 5,
  PositionOfOccupants_POS_OCC_ROW2RIGHTOCCUPIED = 6,
  PositionOfOccupants_POS_OCC_ROW2MIDOCCUPIED = 7,
  PositionOfOccupants_POS_OCC_ROW2NOTDETECTABLE = 8,
  PositionOfOccupants_POS_OCC_ROW2NOTPRESENT = 9,
  PositionOfOccupants_POS_OCC_ROW3LEFTOCCUPIED = 10,
  PositionOfOccupants_POS_OCC_ROW3RIGHTOCCUPIED = 11,
  PositionOfOccupants_POS_OCC_ROW3MIDOCCUPIED = 12,
  PositionOfOccupants_POS_OCC_ROW3NOTDETECTABLE = 13,
  PositionOfOccupants_POS_OCC_ROW3NOTPRESENT = 14,
  PositionOfOccupants_POS_OCC_ROW4LEFTOCCUPIED = 15,
  PositionOfOccupants_POS_OCC_ROW4RIGHTOCCUPIED = 16,
  PositionOfOccupants_POS_OCC_ROW4MIDOCCUPIED = 17,
  PositionOfOccupants_POS_OCC_ROW4NOTDETECTABLE = 18,
  PositionOfOccupants_POS_OCC_ROW4NOTPRESENT = 19,
  PositionOfOccupants_MIN = PositionOfOccupants_POS_OCC_ROW1LEFTOCCUPIED,
  PositionOfOccupants_MAX = PositionOfOccupants_POS_OCC_ROW4NOTPRESENT
};

inline const PositionOfOccupants (&EnumValuesPositionOfOccupants())[20] {
  static const PositionOfOccupants values[] = {
    PositionOfOccupants_POS_OCC_ROW1LEFTOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW1RIGHTOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW1MIDOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW1NOTDETECTABLE,
    PositionOfOccupants_POS_OCC_ROW1NOTPRESENT,
    PositionOfOccupants_POS_OCC_ROW2LEFTOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW2RIGHTOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW2MIDOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW2NOTDETECTABLE,
    PositionOfOccupants_POS_OCC_ROW2NOTPRESENT,
    PositionOfOccupants_POS_OCC_ROW3LEFTOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW3RIGHTOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW3MIDOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW3NOTDETECTABLE,
    PositionOfOccupants_POS_OCC_ROW3NOTPRESENT,
    PositionOfOccupants_POS_OCC_ROW4LEFTOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW4RIGHTOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW4MIDOCCUPIED,
    PositionOfOccupants_POS_OCC_ROW4NOTDETECTABLE,
    PositionOfOccupants_POS_OCC_ROW4NOTPRESENT
  };
  return values;
}

inline const char * const *EnumNamesPositionOfOccupants() {
  static const char * const names[21] = {
    "POS_OCC_ROW1LEFTOCCUPIED",
    "POS_OCC_ROW1RIGHTOCCUPIED",
    "POS_OCC_ROW1MIDOCCUPIED",
    "POS_OCC_ROW1NOTDETECTABLE",
    "POS_OCC_ROW1NOTPRESENT",
    "POS_OCC_ROW2LEFTOCCUPIED",
    "POS_OCC_ROW2RIGHTOCCUPIED",
    "POS_OCC_ROW2MIDOCCUPIED",
    "POS_OCC_ROW2NOTDETECTABLE",
    "POS_OCC_ROW2NOTPRESENT",
    "POS_OCC_ROW3LEFTOCCUPIED",
    "POS_OCC_ROW3RIGHTOCCUPIED",
    "POS_OCC_ROW3MIDOCCUPIED",
    "POS_OCC_ROW3NOTDETECTABLE",
    "POS_OCC_ROW3NOTPRESENT",
    "POS_OCC_ROW4LEFTOCCUPIED",
    "POS_OCC_ROW4RIGHTOCCUPIED",
    "POS_OCC_ROW4MIDOCCUPIED",
    "POS_OCC_ROW4NOTDETECTABLE",
    "POS_OCC_ROW4NOTPRESENT",
    nullptr
  };
  return names;
}

inline const char *EnumNamePositionOfOccupants(PositionOfOccupants e) {
  if (::flatbuffers::IsOutRange(e, PositionOfOccupants_POS_OCC_ROW1LEFTOCCUPIED, PositionOfOccupants_POS_OCC_ROW4NOTPRESENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPositionOfOccupants()[index];
}

enum RelevanceDistance : int32_t {
  RelevanceDistance_REL_DIST_LESSTHAN50M = 0,
  RelevanceDistance_REL_DIST_LESSTHAN100M = 1,
  RelevanceDistance_REL_DIST_LESSTHAN200M = 2,
  RelevanceDistance_REL_DIST_LESSTHAN500M = 3,
  RelevanceDistance_REL_DIST_LESSTHAN1000M = 4,
  RelevanceDistance_REL_DIST_LESSTHAN5KM = 5,
  RelevanceDistance_REL_DIST_LESSTHAN10KM = 6,
  RelevanceDistance_REL_DIST_OVER10KM = 7,
  RelevanceDistance_MIN = RelevanceDistance_REL_DIST_LESSTHAN50M,
  RelevanceDistance_MAX = RelevanceDistance_REL_DIST_OVER10KM
};

inline const RelevanceDistance (&EnumValuesRelevanceDistance())[8] {
  static const RelevanceDistance values[] = {
    RelevanceDistance_REL_DIST_LESSTHAN50M,
    RelevanceDistance_REL_DIST_LESSTHAN100M,
    RelevanceDistance_REL_DIST_LESSTHAN200M,
    RelevanceDistance_REL_DIST_LESSTHAN500M,
    RelevanceDistance_REL_DIST_LESSTHAN1000M,
    RelevanceDistance_REL_DIST_LESSTHAN5KM,
    RelevanceDistance_REL_DIST_LESSTHAN10KM,
    RelevanceDistance_REL_DIST_OVER10KM
  };
  return values;
}

inline const char * const *EnumNamesRelevanceDistance() {
  static const char * const names[9] = {
    "REL_DIST_LESSTHAN50M",
    "REL_DIST_LESSTHAN100M",
    "REL_DIST_LESSTHAN200M",
    "REL_DIST_LESSTHAN500M",
    "REL_DIST_LESSTHAN1000M",
    "REL_DIST_LESSTHAN5KM",
    "REL_DIST_LESSTHAN10KM",
    "REL_DIST_OVER10KM",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelevanceDistance(RelevanceDistance e) {
  if (::flatbuffers::IsOutRange(e, RelevanceDistance_REL_DIST_LESSTHAN50M, RelevanceDistance_REL_DIST_OVER10KM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelevanceDistance()[index];
}

enum RelevanceTrafficDirection : int32_t {
  RelevanceTrafficDirection_REL_TD_ALLTRAFFICDIRECTIONS = 0,
  RelevanceTrafficDirection_REL_TD_UPSTREAMTRAFFIC = 1,
  RelevanceTrafficDirection_REL_TD_DOWNSTREAMTRAFFIC = 2,
  RelevanceTrafficDirection_REL_TD_OPPOSITETRAFFIC = 3,
  RelevanceTrafficDirection_MIN = RelevanceTrafficDirection_REL_TD_ALLTRAFFICDIRECTIONS,
  RelevanceTrafficDirection_MAX = RelevanceTrafficDirection_REL_TD_OPPOSITETRAFFIC
};

inline const RelevanceTrafficDirection (&EnumValuesRelevanceTrafficDirection())[4] {
  static const RelevanceTrafficDirection values[] = {
    RelevanceTrafficDirection_REL_TD_ALLTRAFFICDIRECTIONS,
    RelevanceTrafficDirection_REL_TD_UPSTREAMTRAFFIC,
    RelevanceTrafficDirection_REL_TD_DOWNSTREAMTRAFFIC,
    RelevanceTrafficDirection_REL_TD_OPPOSITETRAFFIC
  };
  return values;
}

inline const char * const *EnumNamesRelevanceTrafficDirection() {
  static const char * const names[5] = {
    "REL_TD_ALLTRAFFICDIRECTIONS",
    "REL_TD_UPSTREAMTRAFFIC",
    "REL_TD_DOWNSTREAMTRAFFIC",
    "REL_TD_OPPOSITETRAFFIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelevanceTrafficDirection(RelevanceTrafficDirection e) {
  if (::flatbuffers::IsOutRange(e, RelevanceTrafficDirection_REL_TD_ALLTRAFFICDIRECTIONS, RelevanceTrafficDirection_REL_TD_OPPOSITETRAFFIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelevanceTrafficDirection()[index];
}

enum RequestResponseIndication : int32_t {
  RequestResponseIndication_RRI_REQUEST = 0,
  RequestResponseIndication_RRI_RESPONSE = 1,
  RequestResponseIndication_MIN = RequestResponseIndication_RRI_REQUEST,
  RequestResponseIndication_MAX = RequestResponseIndication_RRI_RESPONSE
};

inline const RequestResponseIndication (&EnumValuesRequestResponseIndication())[2] {
  static const RequestResponseIndication values[] = {
    RequestResponseIndication_RRI_REQUEST,
    RequestResponseIndication_RRI_RESPONSE
  };
  return values;
}

inline const char * const *EnumNamesRequestResponseIndication() {
  static const char * const names[3] = {
    "RRI_REQUEST",
    "RRI_RESPONSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestResponseIndication(RequestResponseIndication e) {
  if (::flatbuffers::IsOutRange(e, RequestResponseIndication_RRI_REQUEST, RequestResponseIndication_RRI_RESPONSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestResponseIndication()[index];
}

enum RoadType : int32_t {
  RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES = 0,
  RoadType_RT_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES = 1,
  RoadType_RT_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES = 2,
  RoadType_RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES = 3,
  RoadType_MIN = RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES,
  RoadType_MAX = RoadType_RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES
};

inline const RoadType (&EnumValuesRoadType())[4] {
  static const RoadType values[] = {
    RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES,
    RoadType_RT_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES,
    RoadType_RT_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES,
    RoadType_RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES
  };
  return values;
}

inline const char * const *EnumNamesRoadType() {
  static const char * const names[5] = {
    "RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES",
    "RT_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES",
    "RT_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES",
    "RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoadType(RoadType e) {
  if (::flatbuffers::IsOutRange(e, RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES, RoadType_RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoadType()[index];
}

enum SensorType : int32_t {
  SensorType_SNSR_UNDEFINED = 0,
  SensorType_SNSR_RADAR = 1,
  SensorType_SNSR_LIDAR = 2,
  SensorType_SNSR_MONOVIDEO = 3,
  SensorType_SNSR_STEROVISION = 4,
  SensorType_SNSR_NIGHTVISION = 5,
  SensorType_SNSR_ULTRASONIC = 6,
  SensorType_SNSR_PMD = 7,
  SensorType_SNSR_INDUCTIONLOOP = 8,
  SensorType_SNSR_SPHERICALCAMERA = 9,
  SensorType_SNSR_UWB = 10,
  SensorType_SNSR_ACOUSTIC = 11,
  SensorType_SNSR_LOCALAGGREGATION = 12,
  SensorType_SNSR_ITSAGGREGATION = 13,
  SensorType_MIN = SensorType_SNSR_UNDEFINED,
  SensorType_MAX = SensorType_SNSR_ITSAGGREGATION
};

inline const SensorType (&EnumValuesSensorType())[14] {
  static const SensorType values[] = {
    SensorType_SNSR_UNDEFINED,
    SensorType_SNSR_RADAR,
    SensorType_SNSR_LIDAR,
    SensorType_SNSR_MONOVIDEO,
    SensorType_SNSR_STEROVISION,
    SensorType_SNSR_NIGHTVISION,
    SensorType_SNSR_ULTRASONIC,
    SensorType_SNSR_PMD,
    SensorType_SNSR_INDUCTIONLOOP,
    SensorType_SNSR_SPHERICALCAMERA,
    SensorType_SNSR_UWB,
    SensorType_SNSR_ACOUSTIC,
    SensorType_SNSR_LOCALAGGREGATION,
    SensorType_SNSR_ITSAGGREGATION
  };
  return values;
}

inline const char * const *EnumNamesSensorType() {
  static const char * const names[15] = {
    "SNSR_UNDEFINED",
    "SNSR_RADAR",
    "SNSR_LIDAR",
    "SNSR_MONOVIDEO",
    "SNSR_STEROVISION",
    "SNSR_NIGHTVISION",
    "SNSR_ULTRASONIC",
    "SNSR_PMD",
    "SNSR_INDUCTIONLOOP",
    "SNSR_SPHERICALCAMERA",
    "SNSR_UWB",
    "SNSR_ACOUSTIC",
    "SNSR_LOCALAGGREGATION",
    "SNSR_ITSAGGREGATION",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorType(SensorType e) {
  if (::flatbuffers::IsOutRange(e, SensorType_SNSR_UNDEFINED, SensorType_SNSR_ITSAGGREGATION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorType()[index];
}

enum StationarySince : int32_t {
  StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE = 0,
  StationarySince_STATIONARY_SINCE_LESSTHAN2MINUTES = 1,
  StationarySince_STATIONARY_SINCE_LESSTHAN15MINUTES = 2,
  StationarySince_STATIONARY_SINCE_EQUALORGREATER15MINUTES = 3,
  StationarySince_MIN = StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE,
  StationarySince_MAX = StationarySince_STATIONARY_SINCE_EQUALORGREATER15MINUTES
};

inline const StationarySince (&EnumValuesStationarySince())[4] {
  static const StationarySince values[] = {
    StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE,
    StationarySince_STATIONARY_SINCE_LESSTHAN2MINUTES,
    StationarySince_STATIONARY_SINCE_LESSTHAN15MINUTES,
    StationarySince_STATIONARY_SINCE_EQUALORGREATER15MINUTES
  };
  return values;
}

inline const char * const *EnumNamesStationarySince() {
  static const char * const names[5] = {
    "STATIONARY_SINCE_LESSTHAN1MINUTE",
    "STATIONARY_SINCE_LESSTHAN2MINUTES",
    "STATIONARY_SINCE_LESSTHAN15MINUTES",
    "STATIONARY_SINCE_EQUALORGREATER15MINUTES",
    nullptr
  };
  return names;
}

inline const char *EnumNameStationarySince(StationarySince e) {
  if (::flatbuffers::IsOutRange(e, StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE, StationarySince_STATIONARY_SINCE_EQUALORGREATER15MINUTES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStationarySince()[index];
}

enum StationType : int32_t {
  StationType_STN_TYPE_UNKNOWN = 0,
  StationType_STN_TYPE_PEDESTRIAN = 1,
  StationType_STN_TYPE_CYCLIST = 2,
  StationType_STN_TYPE_MOPED = 3,
  StationType_STN_TYPE_MOTORCYCLE = 4,
  StationType_STN_TYPE_PASSENGER_CAR = 5,
  StationType_STN_TYPE_BUS = 6,
  StationType_STN_TYPE_LIGHT_TRUCK = 7,
  StationType_STN_TYPE_HEAVY_TRUCK = 8,
  StationType_STN_TYPE_TRAILER = 9,
  StationType_STN_TYPE_SPECIAL_VEHICLE = 10,
  StationType_STN_TYPE_TRAM = 11,
  StationType_STN_TYPE_ROAD_SIDE_UNIT = 15,
  StationType_MIN = StationType_STN_TYPE_UNKNOWN,
  StationType_MAX = StationType_STN_TYPE_ROAD_SIDE_UNIT
};

inline const StationType (&EnumValuesStationType())[13] {
  static const StationType values[] = {
    StationType_STN_TYPE_UNKNOWN,
    StationType_STN_TYPE_PEDESTRIAN,
    StationType_STN_TYPE_CYCLIST,
    StationType_STN_TYPE_MOPED,
    StationType_STN_TYPE_MOTORCYCLE,
    StationType_STN_TYPE_PASSENGER_CAR,
    StationType_STN_TYPE_BUS,
    StationType_STN_TYPE_LIGHT_TRUCK,
    StationType_STN_TYPE_HEAVY_TRUCK,
    StationType_STN_TYPE_TRAILER,
    StationType_STN_TYPE_SPECIAL_VEHICLE,
    StationType_STN_TYPE_TRAM,
    StationType_STN_TYPE_ROAD_SIDE_UNIT
  };
  return values;
}

inline const char * const *EnumNamesStationType() {
  static const char * const names[17] = {
    "STN_TYPE_UNKNOWN",
    "STN_TYPE_PEDESTRIAN",
    "STN_TYPE_CYCLIST",
    "STN_TYPE_MOPED",
    "STN_TYPE_MOTORCYCLE",
    "STN_TYPE_PASSENGER_CAR",
    "STN_TYPE_BUS",
    "STN_TYPE_LIGHT_TRUCK",
    "STN_TYPE_HEAVY_TRUCK",
    "STN_TYPE_TRAILER",
    "STN_TYPE_SPECIAL_VEHICLE",
    "STN_TYPE_TRAM",
    "",
    "",
    "",
    "STN_TYPE_ROAD_SIDE_UNIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameStationType(StationType e) {
  if (::flatbuffers::IsOutRange(e, StationType_STN_TYPE_UNKNOWN, StationType_STN_TYPE_ROAD_SIDE_UNIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStationType()[index];
}

enum TrafficParticipantType : int32_t {
  TrafficParticipantType_TP_TYPE_UNKNOWN = 0,
  TrafficParticipantType_TP_TYPE_PEDESTRIAN = 1,
  TrafficParticipantType_TP_TYPE_CYCLIST = 2,
  TrafficParticipantType_TP_TYPE_MOPED = 3,
  TrafficParticipantType_TP_TYPE_MOTORCYCLE = 4,
  TrafficParticipantType_TP_TYPE_PASSENGERCAR = 5,
  TrafficParticipantType_TP_TYPE_BUS = 6,
  TrafficParticipantType_TP_TYPE_LIGHTTRUCK = 7,
  TrafficParticipantType_TP_TYPE_HEAVYTRUCK = 8,
  TrafficParticipantType_TP_TYPE_TRAILER = 9,
  TrafficParticipantType_TP_TYPE_SPECIALVEHICLE = 10,
  TrafficParticipantType_TP_TYPE_TRAM = 11,
  TrafficParticipantType_TP_TYPE_LIGHTVRUVEHICLE = 12,
  TrafficParticipantType_TP_TYPE_ANIMAL = 13,
  TrafficParticipantType_TP_TYPE_AGRICULTURAL = 14,
  TrafficParticipantType_TP_TYPE_ROADSIDEUNIT = 15,
  TrafficParticipantType_MIN = TrafficParticipantType_TP_TYPE_UNKNOWN,
  TrafficParticipantType_MAX = TrafficParticipantType_TP_TYPE_ROADSIDEUNIT
};

inline const TrafficParticipantType (&EnumValuesTrafficParticipantType())[16] {
  static const TrafficParticipantType values[] = {
    TrafficParticipantType_TP_TYPE_UNKNOWN,
    TrafficParticipantType_TP_TYPE_PEDESTRIAN,
    TrafficParticipantType_TP_TYPE_CYCLIST,
    TrafficParticipantType_TP_TYPE_MOPED,
    TrafficParticipantType_TP_TYPE_MOTORCYCLE,
    TrafficParticipantType_TP_TYPE_PASSENGERCAR,
    TrafficParticipantType_TP_TYPE_BUS,
    TrafficParticipantType_TP_TYPE_LIGHTTRUCK,
    TrafficParticipantType_TP_TYPE_HEAVYTRUCK,
    TrafficParticipantType_TP_TYPE_TRAILER,
    TrafficParticipantType_TP_TYPE_SPECIALVEHICLE,
    TrafficParticipantType_TP_TYPE_TRAM,
    TrafficParticipantType_TP_TYPE_LIGHTVRUVEHICLE,
    TrafficParticipantType_TP_TYPE_ANIMAL,
    TrafficParticipantType_TP_TYPE_AGRICULTURAL,
    TrafficParticipantType_TP_TYPE_ROADSIDEUNIT
  };
  return values;
}

inline const char * const *EnumNamesTrafficParticipantType() {
  static const char * const names[17] = {
    "TP_TYPE_UNKNOWN",
    "TP_TYPE_PEDESTRIAN",
    "TP_TYPE_CYCLIST",
    "TP_TYPE_MOPED",
    "TP_TYPE_MOTORCYCLE",
    "TP_TYPE_PASSENGERCAR",
    "TP_TYPE_BUS",
    "TP_TYPE_LIGHTTRUCK",
    "TP_TYPE_HEAVYTRUCK",
    "TP_TYPE_TRAILER",
    "TP_TYPE_SPECIALVEHICLE",
    "TP_TYPE_TRAM",
    "TP_TYPE_LIGHTVRUVEHICLE",
    "TP_TYPE_ANIMAL",
    "TP_TYPE_AGRICULTURAL",
    "TP_TYPE_ROADSIDEUNIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrafficParticipantType(TrafficParticipantType e) {
  if (::flatbuffers::IsOutRange(e, TrafficParticipantType_TP_TYPE_UNKNOWN, TrafficParticipantType_TP_TYPE_ROADSIDEUNIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrafficParticipantType()[index];
}

enum TrafficRule : int32_t {
  TrafficRule_TR_NOPASSING = 0,
  TrafficRule_TR_NOPASSINGFORTRUCKS = 1,
  TrafficRule_TR_PASSTORIGHT = 2,
  TrafficRule_TR_PASSTOLEFT = 3,
  TrafficRule_MIN = TrafficRule_TR_NOPASSING,
  TrafficRule_MAX = TrafficRule_TR_PASSTOLEFT
};

inline const TrafficRule (&EnumValuesTrafficRule())[4] {
  static const TrafficRule values[] = {
    TrafficRule_TR_NOPASSING,
    TrafficRule_TR_NOPASSINGFORTRUCKS,
    TrafficRule_TR_PASSTORIGHT,
    TrafficRule_TR_PASSTOLEFT
  };
  return values;
}

inline const char * const *EnumNamesTrafficRule() {
  static const char * const names[5] = {
    "TR_NOPASSING",
    "TR_NOPASSINGFORTRUCKS",
    "TR_PASSTORIGHT",
    "TR_PASSTOLEFT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrafficRule(TrafficRule e) {
  if (::flatbuffers::IsOutRange(e, TrafficRule_TR_NOPASSING, TrafficRule_TR_PASSTOLEFT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrafficRule()[index];
}

enum VehicleLengthConfidenceIndication : int32_t {
  VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT = 0,
  VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENT_WITH_KNOWN_LENGTH = 1,
  VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENT_WITH_UNKNOWN_LENGTH = 2,
  VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENCE_IS_UNKNOWN = 3,
  VehicleLengthConfidenceIndication_VLCI_UNAVAILABLE = 4,
  VehicleLengthConfidenceIndication_MIN = VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT,
  VehicleLengthConfidenceIndication_MAX = VehicleLengthConfidenceIndication_VLCI_UNAVAILABLE
};

inline const VehicleLengthConfidenceIndication (&EnumValuesVehicleLengthConfidenceIndication())[5] {
  static const VehicleLengthConfidenceIndication values[] = {
    VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT,
    VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENT_WITH_KNOWN_LENGTH,
    VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENT_WITH_UNKNOWN_LENGTH,
    VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENCE_IS_UNKNOWN,
    VehicleLengthConfidenceIndication_VLCI_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesVehicleLengthConfidenceIndication() {
  static const char * const names[6] = {
    "VLCI_NO_TRAILER_PRESENT",
    "VLCI_TRAILER_PRESENT_WITH_KNOWN_LENGTH",
    "VLCI_TRAILER_PRESENT_WITH_UNKNOWN_LENGTH",
    "VLCI_TRAILER_PRESENCE_IS_UNKNOWN",
    "VLCI_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameVehicleLengthConfidenceIndication(VehicleLengthConfidenceIndication e) {
  if (::flatbuffers::IsOutRange(e, VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT, VehicleLengthConfidenceIndication_VLCI_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVehicleLengthConfidenceIndication()[index];
}

enum VruSubProfilePedestrian : int32_t {
  VruSubProfilePedestrian_PED_UNAVAILABLE = 0,
  VruSubProfilePedestrian_PED_ORDINARY_PEDESTRIAN = 1,
  VruSubProfilePedestrian_PED_ROAD_WORKER = 2,
  VruSubProfilePedestrian_PED_FIRST_RESPONDER = 3,
  VruSubProfilePedestrian_PED_MAX = 15,
  VruSubProfilePedestrian_MIN = VruSubProfilePedestrian_PED_UNAVAILABLE,
  VruSubProfilePedestrian_MAX = VruSubProfilePedestrian_PED_MAX
};

inline const VruSubProfilePedestrian (&EnumValuesVruSubProfilePedestrian())[5] {
  static const VruSubProfilePedestrian values[] = {
    VruSubProfilePedestrian_PED_UNAVAILABLE,
    VruSubProfilePedestrian_PED_ORDINARY_PEDESTRIAN,
    VruSubProfilePedestrian_PED_ROAD_WORKER,
    VruSubProfilePedestrian_PED_FIRST_RESPONDER,
    VruSubProfilePedestrian_PED_MAX
  };
  return values;
}

inline const char * const *EnumNamesVruSubProfilePedestrian() {
  static const char * const names[17] = {
    "PED_UNAVAILABLE",
    "PED_ORDINARY_PEDESTRIAN",
    "PED_ROAD_WORKER",
    "PED_FIRST_RESPONDER",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "PED_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameVruSubProfilePedestrian(VruSubProfilePedestrian e) {
  if (::flatbuffers::IsOutRange(e, VruSubProfilePedestrian_PED_UNAVAILABLE, VruSubProfilePedestrian_PED_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVruSubProfilePedestrian()[index];
}

enum VruSubProfileBicyclist : int32_t {
  VruSubProfileBicyclist_BC_UNAVAILABLE = 0,
  VruSubProfileBicyclist_BC_BICYCLIST = 1,
  VruSubProfileBicyclist_BC_WHEELCHAIR_USER = 2,
  VruSubProfileBicyclist_BC_HORSE_AND_RIDER = 3,
  VruSubProfileBicyclist_BC_ROLLERSKATER = 4,
  VruSubProfileBicyclist_BC_E_SCOOTER = 5,
  VruSubProfileBicyclist_BC_PERSONAL_TRANSPORTER = 6,
  VruSubProfileBicyclist_BC_PEDELEC = 7,
  VruSubProfileBicyclist_BC_SPEED_PEDELEC = 8,
  VruSubProfileBicyclist_BC_MAX = 15,
  VruSubProfileBicyclist_MIN = VruSubProfileBicyclist_BC_UNAVAILABLE,
  VruSubProfileBicyclist_MAX = VruSubProfileBicyclist_BC_MAX
};

inline const VruSubProfileBicyclist (&EnumValuesVruSubProfileBicyclist())[10] {
  static const VruSubProfileBicyclist values[] = {
    VruSubProfileBicyclist_BC_UNAVAILABLE,
    VruSubProfileBicyclist_BC_BICYCLIST,
    VruSubProfileBicyclist_BC_WHEELCHAIR_USER,
    VruSubProfileBicyclist_BC_HORSE_AND_RIDER,
    VruSubProfileBicyclist_BC_ROLLERSKATER,
    VruSubProfileBicyclist_BC_E_SCOOTER,
    VruSubProfileBicyclist_BC_PERSONAL_TRANSPORTER,
    VruSubProfileBicyclist_BC_PEDELEC,
    VruSubProfileBicyclist_BC_SPEED_PEDELEC,
    VruSubProfileBicyclist_BC_MAX
  };
  return values;
}

inline const char * const *EnumNamesVruSubProfileBicyclist() {
  static const char * const names[17] = {
    "BC_UNAVAILABLE",
    "BC_BICYCLIST",
    "BC_WHEELCHAIR_USER",
    "BC_HORSE_AND_RIDER",
    "BC_ROLLERSKATER",
    "BC_E_SCOOTER",
    "BC_PERSONAL_TRANSPORTER",
    "BC_PEDELEC",
    "BC_SPEED_PEDELEC",
    "",
    "",
    "",
    "",
    "",
    "",
    "BC_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameVruSubProfileBicyclist(VruSubProfileBicyclist e) {
  if (::flatbuffers::IsOutRange(e, VruSubProfileBicyclist_BC_UNAVAILABLE, VruSubProfileBicyclist_BC_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVruSubProfileBicyclist()[index];
}

enum VruSubProfileMotorcyclist : int32_t {
  VruSubProfileMotorcyclist_MC_UNAVAILABLE = 0,
  VruSubProfileMotorcyclist_MC_MOPED = 1,
  VruSubProfileMotorcyclist_MC_MOTORCYCLE = 2,
  VruSubProfileMotorcyclist_MC_MOTORCYCLE_AND_SIDECAR_RIGHT = 3,
  VruSubProfileMotorcyclist_MC_MOTORCYCLE_AND_SIDECAR_LEFT = 4,
  VruSubProfileMotorcyclist_MC_MAX = 15,
  VruSubProfileMotorcyclist_MIN = VruSubProfileMotorcyclist_MC_UNAVAILABLE,
  VruSubProfileMotorcyclist_MAX = VruSubProfileMotorcyclist_MC_MAX
};

inline const VruSubProfileMotorcyclist (&EnumValuesVruSubProfileMotorcyclist())[6] {
  static const VruSubProfileMotorcyclist values[] = {
    VruSubProfileMotorcyclist_MC_UNAVAILABLE,
    VruSubProfileMotorcyclist_MC_MOPED,
    VruSubProfileMotorcyclist_MC_MOTORCYCLE,
    VruSubProfileMotorcyclist_MC_MOTORCYCLE_AND_SIDECAR_RIGHT,
    VruSubProfileMotorcyclist_MC_MOTORCYCLE_AND_SIDECAR_LEFT,
    VruSubProfileMotorcyclist_MC_MAX
  };
  return values;
}

inline const char * const *EnumNamesVruSubProfileMotorcyclist() {
  static const char * const names[17] = {
    "MC_UNAVAILABLE",
    "MC_MOPED",
    "MC_MOTORCYCLE",
    "MC_MOTORCYCLE_AND_SIDECAR_RIGHT",
    "MC_MOTORCYCLE_AND_SIDECAR_LEFT",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "MC_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameVruSubProfileMotorcyclist(VruSubProfileMotorcyclist e) {
  if (::flatbuffers::IsOutRange(e, VruSubProfileMotorcyclist_MC_UNAVAILABLE, VruSubProfileMotorcyclist_MC_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVruSubProfileMotorcyclist()[index];
}

enum VruSubProfileAnimal : int32_t {
  VruSubProfileAnimal_AN_UNAVAILABLE = 0,
  VruSubProfileAnimal_AN_WILD_ANIMAL = 1,
  VruSubProfileAnimal_AN_FARM_ANIMAL = 2,
  VruSubProfileAnimal_AN_SERVICE_ANIMAL = 3,
  VruSubProfileAnimal_AN_MAX = 15,
  VruSubProfileAnimal_MIN = VruSubProfileAnimal_AN_UNAVAILABLE,
  VruSubProfileAnimal_MAX = VruSubProfileAnimal_AN_MAX
};

inline const VruSubProfileAnimal (&EnumValuesVruSubProfileAnimal())[5] {
  static const VruSubProfileAnimal values[] = {
    VruSubProfileAnimal_AN_UNAVAILABLE,
    VruSubProfileAnimal_AN_WILD_ANIMAL,
    VruSubProfileAnimal_AN_FARM_ANIMAL,
    VruSubProfileAnimal_AN_SERVICE_ANIMAL,
    VruSubProfileAnimal_AN_MAX
  };
  return values;
}

inline const char * const *EnumNamesVruSubProfileAnimal() {
  static const char * const names[17] = {
    "AN_UNAVAILABLE",
    "AN_WILD_ANIMAL",
    "AN_FARM_ANIMAL",
    "AN_SERVICE_ANIMAL",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "AN_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameVruSubProfileAnimal(VruSubProfileAnimal e) {
  if (::flatbuffers::IsOutRange(e, VruSubProfileAnimal_AN_UNAVAILABLE, VruSubProfileAnimal_AN_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVruSubProfileAnimal()[index];
}

enum YawRateConfidence : int32_t {
  YawRateConfidence_YRC_degSec_000_01 = 0,
  YawRateConfidence_YRC_degSec_000_05 = 1,
  YawRateConfidence_YRC_degSec_000_10 = 2,
  YawRateConfidence_YRC_degSec_001_00 = 3,
  YawRateConfidence_YRC_degSec_005_00 = 4,
  YawRateConfidence_YRC_degSec_010_00 = 5,
  YawRateConfidence_YRC_degSec_100_00 = 6,
  YawRateConfidence_YRC_OutOfRange = 7,
  YawRateConfidence_YRC_UNAVAILABLE = 8,
  YawRateConfidence_MIN = YawRateConfidence_YRC_degSec_000_01,
  YawRateConfidence_MAX = YawRateConfidence_YRC_UNAVAILABLE
};

inline const YawRateConfidence (&EnumValuesYawRateConfidence())[9] {
  static const YawRateConfidence values[] = {
    YawRateConfidence_YRC_degSec_000_01,
    YawRateConfidence_YRC_degSec_000_05,
    YawRateConfidence_YRC_degSec_000_10,
    YawRateConfidence_YRC_degSec_001_00,
    YawRateConfidence_YRC_degSec_005_00,
    YawRateConfidence_YRC_degSec_010_00,
    YawRateConfidence_YRC_degSec_100_00,
    YawRateConfidence_YRC_OutOfRange,
    YawRateConfidence_YRC_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesYawRateConfidence() {
  static const char * const names[10] = {
    "YRC_degSec_000_01",
    "YRC_degSec_000_05",
    "YRC_degSec_000_10",
    "YRC_degSec_001_00",
    "YRC_degSec_005_00",
    "YRC_degSec_010_00",
    "YRC_degSec_100_00",
    "YRC_OutOfRange",
    "YRC_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameYawRateConfidence(YawRateConfidence e) {
  if (::flatbuffers::IsOutRange(e, YawRateConfidence_YRC_degSec_000_01, YawRateConfidence_YRC_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesYawRateConfidence()[index];
}

struct Acceleration3dWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Acceleration3dWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCELARATION = 4
  };
  const Acceleration3dWithConfidence_::Anonymous0 *accelaration() const {
    return GetPointer<const Acceleration3dWithConfidence_::Anonymous0 *>(VT_ACCELARATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCELARATION) &&
           verifier.VerifyTable(accelaration()) &&
           verifier.EndTable();
  }
};

struct Acceleration3dWithConfidenceBuilder {
  typedef Acceleration3dWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_accelaration(::flatbuffers::Offset<Acceleration3dWithConfidence_::Anonymous0> accelaration) {
    fbb_.AddOffset(Acceleration3dWithConfidence::VT_ACCELARATION, accelaration);
  }
  explicit Acceleration3dWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Acceleration3dWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Acceleration3dWithConfidence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Acceleration3dWithConfidence> CreateAcceleration3dWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Acceleration3dWithConfidence_::Anonymous0> accelaration = 0) {
  Acceleration3dWithConfidenceBuilder builder_(_fbb);
  builder_.add_accelaration(accelaration);
  return builder_.Finish();
}

namespace Acceleration3dWithConfidence_ {

struct Anonymous0 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous0Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POLARACCELERATION = 4,
    VT_CARTESIANACCELERATION = 6
  };
  const AccelerationPolarWithZ *polarAcceleration() const {
    return GetPointer<const AccelerationPolarWithZ *>(VT_POLARACCELERATION);
  }
  const AccelerationCartesian *cartesianAcceleration() const {
    return GetPointer<const AccelerationCartesian *>(VT_CARTESIANACCELERATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POLARACCELERATION) &&
           verifier.VerifyTable(polarAcceleration()) &&
           VerifyOffset(verifier, VT_CARTESIANACCELERATION) &&
           verifier.VerifyTable(cartesianAcceleration()) &&
           verifier.EndTable();
  }
};

struct Anonymous0Builder {
  typedef Anonymous0 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_polarAcceleration(::flatbuffers::Offset<AccelerationPolarWithZ> polarAcceleration) {
    fbb_.AddOffset(Anonymous0::VT_POLARACCELERATION, polarAcceleration);
  }
  void add_cartesianAcceleration(::flatbuffers::Offset<AccelerationCartesian> cartesianAcceleration) {
    fbb_.AddOffset(Anonymous0::VT_CARTESIANACCELERATION, cartesianAcceleration);
  }
  explicit Anonymous0Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous0> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous0>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous0> CreateAnonymous0(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<AccelerationPolarWithZ> polarAcceleration = 0,
    ::flatbuffers::Offset<AccelerationCartesian> cartesianAcceleration = 0) {
  Anonymous0Builder builder_(_fbb);
  builder_.add_cartesianAcceleration(cartesianAcceleration);
  builder_.add_polarAcceleration(polarAcceleration);
  return builder_.Finish();
}

}  // namespace Acceleration3dWithConfidence_

struct AccelerationCartesian FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerationCartesianBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XACCELERATION = 4,
    VT_YACCELERATION = 6,
    VT_ZACCELERATION = 8
  };
  const AccelerationComponent *xAcceleration() const {
    return GetPointer<const AccelerationComponent *>(VT_XACCELERATION);
  }
  const AccelerationComponent *yAcceleration() const {
    return GetPointer<const AccelerationComponent *>(VT_YACCELERATION);
  }
  const AccelerationComponent *zAcceleration() const {
    return GetPointer<const AccelerationComponent *>(VT_ZACCELERATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_XACCELERATION) &&
           verifier.VerifyTable(xAcceleration()) &&
           VerifyOffsetRequired(verifier, VT_YACCELERATION) &&
           verifier.VerifyTable(yAcceleration()) &&
           VerifyOffset(verifier, VT_ZACCELERATION) &&
           verifier.VerifyTable(zAcceleration()) &&
           verifier.EndTable();
  }
};

struct AccelerationCartesianBuilder {
  typedef AccelerationCartesian Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xAcceleration(::flatbuffers::Offset<AccelerationComponent> xAcceleration) {
    fbb_.AddOffset(AccelerationCartesian::VT_XACCELERATION, xAcceleration);
  }
  void add_yAcceleration(::flatbuffers::Offset<AccelerationComponent> yAcceleration) {
    fbb_.AddOffset(AccelerationCartesian::VT_YACCELERATION, yAcceleration);
  }
  void add_zAcceleration(::flatbuffers::Offset<AccelerationComponent> zAcceleration) {
    fbb_.AddOffset(AccelerationCartesian::VT_ZACCELERATION, zAcceleration);
  }
  explicit AccelerationCartesianBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerationCartesian> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerationCartesian>(end);
    fbb_.Required(o, AccelerationCartesian::VT_XACCELERATION);
    fbb_.Required(o, AccelerationCartesian::VT_YACCELERATION);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerationCartesian> CreateAccelerationCartesian(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<AccelerationComponent> xAcceleration = 0,
    ::flatbuffers::Offset<AccelerationComponent> yAcceleration = 0,
    ::flatbuffers::Offset<AccelerationComponent> zAcceleration = 0) {
  AccelerationCartesianBuilder builder_(_fbb);
  builder_.add_zAcceleration(zAcceleration);
  builder_.add_yAcceleration(yAcceleration);
  builder_.add_xAcceleration(xAcceleration);
  return builder_.Finish();
}

struct AccelerationComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerationComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct AccelerationComponentBuilder {
  typedef AccelerationComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(AccelerationComponent::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(AccelerationComponent::VT_CONFIDENCE, confidence, 0);
  }
  explicit AccelerationComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerationComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerationComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerationComponent> CreateAccelerationComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  AccelerationComponentBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct AccelerationMagnitude FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerationMagnitudeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCELERATIONMAGNITUDEVALUE = 4,
    VT_ACCELERATIONCONFIDENCE = 6
  };
  uint32_t accelerationMagnitudeValue() const {
    return GetField<uint32_t>(VT_ACCELERATIONMAGNITUDEVALUE, 0);
  }
  uint32_t accelerationConfidence() const {
    return GetField<uint32_t>(VT_ACCELERATIONCONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACCELERATIONMAGNITUDEVALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACCELERATIONCONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct AccelerationMagnitudeBuilder {
  typedef AccelerationMagnitude Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_accelerationMagnitudeValue(uint32_t accelerationMagnitudeValue) {
    fbb_.AddElement<uint32_t>(AccelerationMagnitude::VT_ACCELERATIONMAGNITUDEVALUE, accelerationMagnitudeValue, 0);
  }
  void add_accelerationConfidence(uint32_t accelerationConfidence) {
    fbb_.AddElement<uint32_t>(AccelerationMagnitude::VT_ACCELERATIONCONFIDENCE, accelerationConfidence, 0);
  }
  explicit AccelerationMagnitudeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerationMagnitude> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerationMagnitude>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerationMagnitude> CreateAccelerationMagnitude(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t accelerationMagnitudeValue = 0,
    uint32_t accelerationConfidence = 0) {
  AccelerationMagnitudeBuilder builder_(_fbb);
  builder_.add_accelerationConfidence(accelerationConfidence);
  builder_.add_accelerationMagnitudeValue(accelerationMagnitudeValue);
  return builder_.Finish();
}

struct AccelerationPolarWithZ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerationPolarWithZBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCELERATIONMAGNITUDE = 4,
    VT_ACCELERATIONDIRECTION = 6,
    VT_ZACCELERATION = 8
  };
  const AccelerationMagnitude *accelerationMagnitude() const {
    return GetPointer<const AccelerationMagnitude *>(VT_ACCELERATIONMAGNITUDE);
  }
  const CartesianAngle *accelerationDirection() const {
    return GetPointer<const CartesianAngle *>(VT_ACCELERATIONDIRECTION);
  }
  const AccelerationComponent *zAcceleration() const {
    return GetPointer<const AccelerationComponent *>(VT_ZACCELERATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ACCELERATIONMAGNITUDE) &&
           verifier.VerifyTable(accelerationMagnitude()) &&
           VerifyOffsetRequired(verifier, VT_ACCELERATIONDIRECTION) &&
           verifier.VerifyTable(accelerationDirection()) &&
           VerifyOffset(verifier, VT_ZACCELERATION) &&
           verifier.VerifyTable(zAcceleration()) &&
           verifier.EndTable();
  }
};

struct AccelerationPolarWithZBuilder {
  typedef AccelerationPolarWithZ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_accelerationMagnitude(::flatbuffers::Offset<AccelerationMagnitude> accelerationMagnitude) {
    fbb_.AddOffset(AccelerationPolarWithZ::VT_ACCELERATIONMAGNITUDE, accelerationMagnitude);
  }
  void add_accelerationDirection(::flatbuffers::Offset<CartesianAngle> accelerationDirection) {
    fbb_.AddOffset(AccelerationPolarWithZ::VT_ACCELERATIONDIRECTION, accelerationDirection);
  }
  void add_zAcceleration(::flatbuffers::Offset<AccelerationComponent> zAcceleration) {
    fbb_.AddOffset(AccelerationPolarWithZ::VT_ZACCELERATION, zAcceleration);
  }
  explicit AccelerationPolarWithZBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerationPolarWithZ> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerationPolarWithZ>(end);
    fbb_.Required(o, AccelerationPolarWithZ::VT_ACCELERATIONMAGNITUDE);
    fbb_.Required(o, AccelerationPolarWithZ::VT_ACCELERATIONDIRECTION);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerationPolarWithZ> CreateAccelerationPolarWithZ(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<AccelerationMagnitude> accelerationMagnitude = 0,
    ::flatbuffers::Offset<CartesianAngle> accelerationDirection = 0,
    ::flatbuffers::Offset<AccelerationComponent> zAcceleration = 0) {
  AccelerationPolarWithZBuilder builder_(_fbb);
  builder_.add_zAcceleration(zAcceleration);
  builder_.add_accelerationDirection(accelerationDirection);
  builder_.add_accelerationMagnitude(accelerationMagnitude);
  return builder_.Finish();
}

struct ActionID FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActionIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGINATINGSTATIONID = 4,
    VT_SEQUENCENUMBER = 6
  };
  uint64_t originatingStationId() const {
    return GetField<uint64_t>(VT_ORIGINATINGSTATIONID, 0);
  }
  uint32_t sequenceNumber() const {
    return GetField<uint32_t>(VT_SEQUENCENUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ORIGINATINGSTATIONID, 8) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCENUMBER, 4) &&
           verifier.EndTable();
  }
};

struct ActionIDBuilder {
  typedef ActionID Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_originatingStationId(uint64_t originatingStationId) {
    fbb_.AddElement<uint64_t>(ActionID::VT_ORIGINATINGSTATIONID, originatingStationId, 0);
  }
  void add_sequenceNumber(uint32_t sequenceNumber) {
    fbb_.AddElement<uint32_t>(ActionID::VT_SEQUENCENUMBER, sequenceNumber, 0);
  }
  explicit ActionIDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActionID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActionID>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ActionID> CreateActionID(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t originatingStationId = 0,
    uint32_t sequenceNumber = 0) {
  ActionIDBuilder builder_(_fbb);
  builder_.add_originatingStationId(originatingStationId);
  builder_.add_sequenceNumber(sequenceNumber);
  return builder_.Finish();
}

struct Altitude FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AltitudeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct AltitudeBuilder {
  typedef Altitude Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Altitude::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(Altitude::VT_CONFIDENCE, confidence, 0);
  }
  explicit AltitudeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Altitude> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Altitude>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Altitude> CreateAltitude(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  AltitudeBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CartesianAngle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianAngleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CARTESIAN_VALUE = 4,
    VT_CARTESIAN_ANGLE_CONFIDENCE = 6
  };
  int64_t cartesian_value() const {
    return GetField<int64_t>(VT_CARTESIAN_VALUE, 0);
  }
  int64_t cartesian_angle_confidence() const {
    return GetField<int64_t>(VT_CARTESIAN_ANGLE_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CARTESIAN_VALUE, 8) &&
           VerifyField<int64_t>(verifier, VT_CARTESIAN_ANGLE_CONFIDENCE, 8) &&
           verifier.EndTable();
  }
};

struct CartesianAngleBuilder {
  typedef CartesianAngle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cartesian_value(int64_t cartesian_value) {
    fbb_.AddElement<int64_t>(CartesianAngle::VT_CARTESIAN_VALUE, cartesian_value, 0);
  }
  void add_cartesian_angle_confidence(int64_t cartesian_angle_confidence) {
    fbb_.AddElement<int64_t>(CartesianAngle::VT_CARTESIAN_ANGLE_CONFIDENCE, cartesian_angle_confidence, 0);
  }
  explicit CartesianAngleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianAngle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianAngle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianAngle> CreateCartesianAngle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t cartesian_value = 0,
    int64_t cartesian_angle_confidence = 0) {
  CartesianAngleBuilder builder_(_fbb);
  builder_.add_cartesian_angle_confidence(cartesian_angle_confidence);
  builder_.add_cartesian_value(cartesian_value);
  return builder_.Finish();
}

struct CartesianAngularVelocityComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianAngularVelocityComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  AngularSpeedConfidence confidence() const {
    return static_cast<AngularSpeedConfidence>(GetField<int32_t>(VT_CONFIDENCE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct CartesianAngularVelocityComponentBuilder {
  typedef CartesianAngularVelocityComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CartesianAngularVelocityComponent::VT_VALUE, value, 0);
  }
  void add_confidence(AngularSpeedConfidence confidence) {
    fbb_.AddElement<int32_t>(CartesianAngularVelocityComponent::VT_CONFIDENCE, static_cast<int32_t>(confidence), 0);
  }
  explicit CartesianAngularVelocityComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianAngularVelocityComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianAngularVelocityComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianAngularVelocityComponent> CreateCartesianAngularVelocityComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    AngularSpeedConfidence confidence = AngularSpeedConfidence_ASC_DEGSEC_01) {
  CartesianAngularVelocityComponentBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CartesianPosition3d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianPosition3dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_CORD = 4,
    VT_Y_CORD = 6,
    VT_Z_CORD = 8
  };
  int32_t x_cord() const {
    return GetField<int32_t>(VT_X_CORD, 0);
  }
  int32_t y_cord() const {
    return GetField<int32_t>(VT_Y_CORD, 0);
  }
  int32_t z_cord() const {
    return GetField<int32_t>(VT_Z_CORD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X_CORD, 4) &&
           VerifyField<int32_t>(verifier, VT_Y_CORD, 4) &&
           VerifyField<int32_t>(verifier, VT_Z_CORD, 4) &&
           verifier.EndTable();
  }
};

struct CartesianPosition3dBuilder {
  typedef CartesianPosition3d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_cord(int32_t x_cord) {
    fbb_.AddElement<int32_t>(CartesianPosition3d::VT_X_CORD, x_cord, 0);
  }
  void add_y_cord(int32_t y_cord) {
    fbb_.AddElement<int32_t>(CartesianPosition3d::VT_Y_CORD, y_cord, 0);
  }
  void add_z_cord(int32_t z_cord) {
    fbb_.AddElement<int32_t>(CartesianPosition3d::VT_Z_CORD, z_cord, 0);
  }
  explicit CartesianPosition3dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianPosition3d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianPosition3d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianPosition3d> CreateCartesianPosition3d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_cord = 0,
    int32_t y_cord = 0,
    int32_t z_cord = 0) {
  CartesianPosition3dBuilder builder_(_fbb);
  builder_.add_z_cord(z_cord);
  builder_.add_y_cord(y_cord);
  builder_.add_x_cord(x_cord);
  return builder_.Finish();
}

struct CartesianCoordinateWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianCoordinateWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct CartesianCoordinateWithConfidenceBuilder {
  typedef CartesianCoordinateWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CartesianCoordinateWithConfidence::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(CartesianCoordinateWithConfidence::VT_CONFIDENCE, confidence, 0);
  }
  explicit CartesianCoordinateWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianCoordinateWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianCoordinateWithConfidence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianCoordinateWithConfidence> CreateCartesianCoordinateWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  CartesianCoordinateWithConfidenceBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CartesianPosition3dWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianPosition3dWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_CORD = 4,
    VT_Y_CORD = 6,
    VT_Z_CORD = 8
  };
  const CartesianCoordinateWithConfidence *x_cord() const {
    return GetPointer<const CartesianCoordinateWithConfidence *>(VT_X_CORD);
  }
  const CartesianCoordinateWithConfidence *y_cord() const {
    return GetPointer<const CartesianCoordinateWithConfidence *>(VT_Y_CORD);
  }
  const CartesianCoordinateWithConfidence *z_cord() const {
    return GetPointer<const CartesianCoordinateWithConfidence *>(VT_Z_CORD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_X_CORD) &&
           verifier.VerifyTable(x_cord()) &&
           VerifyOffsetRequired(verifier, VT_Y_CORD) &&
           verifier.VerifyTable(y_cord()) &&
           VerifyOffset(verifier, VT_Z_CORD) &&
           verifier.VerifyTable(z_cord()) &&
           verifier.EndTable();
  }
};

struct CartesianPosition3dWithConfidenceBuilder {
  typedef CartesianPosition3dWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_cord(::flatbuffers::Offset<CartesianCoordinateWithConfidence> x_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_X_CORD, x_cord);
  }
  void add_y_cord(::flatbuffers::Offset<CartesianCoordinateWithConfidence> y_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_Y_CORD, y_cord);
  }
  void add_z_cord(::flatbuffers::Offset<CartesianCoordinateWithConfidence> z_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_Z_CORD, z_cord);
  }
  explicit CartesianPosition3dWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianPosition3dWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianPosition3dWithConfidence>(end);
    fbb_.Required(o, CartesianPosition3dWithConfidence::VT_X_CORD);
    fbb_.Required(o, CartesianPosition3dWithConfidence::VT_Y_CORD);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianPosition3dWithConfidence> CreateCartesianPosition3dWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CartesianCoordinateWithConfidence> x_cord = 0,
    ::flatbuffers::Offset<CartesianCoordinateWithConfidence> y_cord = 0,
    ::flatbuffers::Offset<CartesianCoordinateWithConfidence> z_cord = 0) {
  CartesianPosition3dWithConfidenceBuilder builder_(_fbb);
  builder_.add_z_cord(z_cord);
  builder_.add_y_cord(y_cord);
  builder_.add_x_cord(x_cord);
  return builder_.Finish();
}

struct CircularShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircularShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPEREFPOINT = 4,
    VT_RADIUS = 6,
    VT_HEIGHT = 8
  };
  const CartesianPosition3d *shapeRefPoint() const {
    return GetPointer<const CartesianPosition3d *>(VT_SHAPEREFPOINT);
  }
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPEREFPOINT) &&
           verifier.VerifyTable(shapeRefPoint()) &&
           VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct CircularShapeBuilder {
  typedef CircularShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shapeRefPoint(::flatbuffers::Offset<CartesianPosition3d> shapeRefPoint) {
    fbb_.AddOffset(CircularShape::VT_SHAPEREFPOINT, shapeRefPoint);
  }
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(CircularShape::VT_RADIUS, radius, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(CircularShape::VT_HEIGHT, height, 0);
  }
  explicit CircularShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircularShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircularShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CircularShape> CreateCircularShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CartesianPosition3d> shapeRefPoint = 0,
    int32_t radius = 0,
    uint32_t height = 0) {
  CircularShapeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_radius(radius);
  builder_.add_shapeRefPoint(shapeRefPoint);
  return builder_.Finish();
}

struct ClosedLanes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClosedLanesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INNERHARDSHOULDERSTATUS = 4,
    VT_OUTERHARDSHOULDERSTATUS = 6,
    VT_DRIVINGLANESTATUS = 8
  };
  HardShoulderStatus innerhardShoulderStatus() const {
    return static_cast<HardShoulderStatus>(GetField<int32_t>(VT_INNERHARDSHOULDERSTATUS, 0));
  }
  HardShoulderStatus outerhardShoulderStatus() const {
    return static_cast<HardShoulderStatus>(GetField<int32_t>(VT_OUTERHARDSHOULDERSTATUS, 0));
  }
  uint32_t drivingLaneStatus() const {
    return GetField<uint32_t>(VT_DRIVINGLANESTATUS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INNERHARDSHOULDERSTATUS, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTERHARDSHOULDERSTATUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_DRIVINGLANESTATUS, 4) &&
           verifier.EndTable();
  }
};

struct ClosedLanesBuilder {
  typedef ClosedLanes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_innerhardShoulderStatus(HardShoulderStatus innerhardShoulderStatus) {
    fbb_.AddElement<int32_t>(ClosedLanes::VT_INNERHARDSHOULDERSTATUS, static_cast<int32_t>(innerhardShoulderStatus), 0);
  }
  void add_outerhardShoulderStatus(HardShoulderStatus outerhardShoulderStatus) {
    fbb_.AddElement<int32_t>(ClosedLanes::VT_OUTERHARDSHOULDERSTATUS, static_cast<int32_t>(outerhardShoulderStatus), 0);
  }
  void add_drivingLaneStatus(uint32_t drivingLaneStatus) {
    fbb_.AddElement<uint32_t>(ClosedLanes::VT_DRIVINGLANESTATUS, drivingLaneStatus, 0);
  }
  explicit ClosedLanesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClosedLanes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClosedLanes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClosedLanes> CreateClosedLanes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    HardShoulderStatus innerhardShoulderStatus = HardShoulderStatus_HSS_AVAILABLEFORSTOPPING,
    HardShoulderStatus outerhardShoulderStatus = HardShoulderStatus_HSS_AVAILABLEFORSTOPPING,
    uint32_t drivingLaneStatus = 0) {
  ClosedLanesBuilder builder_(_fbb);
  builder_.add_drivingLaneStatus(drivingLaneStatus);
  builder_.add_outerhardShoulderStatus(outerhardShoulderStatus);
  builder_.add_innerhardShoulderStatus(innerhardShoulderStatus);
  return builder_.Finish();
}

struct CorrelationColumn FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CorrelationColumnBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct CorrelationColumnBuilder {
  typedef CorrelationColumn Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(CorrelationColumn::VT_VALUE, value);
  }
  explicit CorrelationColumnBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CorrelationColumn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CorrelationColumn>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CorrelationColumn> CreateCorrelationColumn(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value = 0) {
  CorrelationColumnBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CorrelationColumn> CreateCorrelationColumnDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return CreateCorrelationColumn(
      _fbb,
      value__);
}

struct Curvature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CurvatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  int32_t confidence() const {
    return GetField<int32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct CurvatureBuilder {
  typedef Curvature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Curvature::VT_VALUE, value, 0);
  }
  void add_confidence(int32_t confidence) {
    fbb_.AddElement<int32_t>(Curvature::VT_CONFIDENCE, confidence, 0);
  }
  explicit CurvatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Curvature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Curvature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Curvature> CreateCurvature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    int32_t confidence = 0) {
  CurvatureBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CauseCode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CauseCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAUSECODE = 4,
    VT_SUBCAUSECODE = 6
  };
  CauseCodeType causeCode() const {
    return static_cast<CauseCodeType>(GetField<int32_t>(VT_CAUSECODE, 0));
  }
  uint32_t subCauseCode() const {
    return GetField<uint32_t>(VT_SUBCAUSECODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CAUSECODE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SUBCAUSECODE, 4) &&
           verifier.EndTable();
  }
};

struct CauseCodeBuilder {
  typedef CauseCode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_causeCode(CauseCodeType causeCode) {
    fbb_.AddElement<int32_t>(CauseCode::VT_CAUSECODE, static_cast<int32_t>(causeCode), 0);
  }
  void add_subCauseCode(uint32_t subCauseCode) {
    fbb_.AddElement<uint32_t>(CauseCode::VT_SUBCAUSECODE, subCauseCode, 0);
  }
  explicit CauseCodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CauseCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CauseCode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CauseCode> CreateCauseCode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    CauseCodeType causeCode = CauseCodeType_CC_TYPE_UNAVAILABLE,
    uint32_t subCauseCode = 0) {
  CauseCodeBuilder builder_(_fbb);
  builder_.add_subCauseCode(subCauseCode);
  builder_.add_causeCode(causeCode);
  return builder_.Finish();
}

struct DangerousGoodsExtended FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DangerousGoodsExtendedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DANGEROUSGOODSTYPE = 4,
    VT_UNNUMBER = 6,
    VT_ELEVATEDTEMPERATURE = 8,
    VT_TUNNELSRESTRICTED = 10,
    VT_LIMITEDQUANTITY = 12,
    VT_EMERGENCYACTIONCODE = 14,
    VT_PHONENUMBER = 16,
    VT_COMPANYNAME = 18
  };
  DangerousGoodsBasic dangerousGoodsType() const {
    return static_cast<DangerousGoodsBasic>(GetField<int32_t>(VT_DANGEROUSGOODSTYPE, 0));
  }
  uint32_t unNumber() const {
    return GetField<uint32_t>(VT_UNNUMBER, 0);
  }
  bool elevatedTemperature() const {
    return GetField<uint8_t>(VT_ELEVATEDTEMPERATURE, 0) != 0;
  }
  bool tunnelsRestricted() const {
    return GetField<uint8_t>(VT_TUNNELSRESTRICTED, 0) != 0;
  }
  bool limitedQuantity() const {
    return GetField<uint8_t>(VT_LIMITEDQUANTITY, 0) != 0;
  }
  const ::flatbuffers::String *emergencyActionCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EMERGENCYACTIONCODE);
  }
  const ::flatbuffers::String *phoneNumber() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PHONENUMBER);
  }
  const ::flatbuffers::String *companyName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMPANYNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DANGEROUSGOODSTYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNNUMBER, 4) &&
           VerifyField<uint8_t>(verifier, VT_ELEVATEDTEMPERATURE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TUNNELSRESTRICTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIMITEDQUANTITY, 1) &&
           VerifyOffset(verifier, VT_EMERGENCYACTIONCODE) &&
           verifier.VerifyString(emergencyActionCode()) &&
           VerifyOffset(verifier, VT_PHONENUMBER) &&
           verifier.VerifyString(phoneNumber()) &&
           VerifyOffset(verifier, VT_COMPANYNAME) &&
           verifier.VerifyString(companyName()) &&
           verifier.EndTable();
  }
};

struct DangerousGoodsExtendedBuilder {
  typedef DangerousGoodsExtended Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dangerousGoodsType(DangerousGoodsBasic dangerousGoodsType) {
    fbb_.AddElement<int32_t>(DangerousGoodsExtended::VT_DANGEROUSGOODSTYPE, static_cast<int32_t>(dangerousGoodsType), 0);
  }
  void add_unNumber(uint32_t unNumber) {
    fbb_.AddElement<uint32_t>(DangerousGoodsExtended::VT_UNNUMBER, unNumber, 0);
  }
  void add_elevatedTemperature(bool elevatedTemperature) {
    fbb_.AddElement<uint8_t>(DangerousGoodsExtended::VT_ELEVATEDTEMPERATURE, static_cast<uint8_t>(elevatedTemperature), 0);
  }
  void add_tunnelsRestricted(bool tunnelsRestricted) {
    fbb_.AddElement<uint8_t>(DangerousGoodsExtended::VT_TUNNELSRESTRICTED, static_cast<uint8_t>(tunnelsRestricted), 0);
  }
  void add_limitedQuantity(bool limitedQuantity) {
    fbb_.AddElement<uint8_t>(DangerousGoodsExtended::VT_LIMITEDQUANTITY, static_cast<uint8_t>(limitedQuantity), 0);
  }
  void add_emergencyActionCode(::flatbuffers::Offset<::flatbuffers::String> emergencyActionCode) {
    fbb_.AddOffset(DangerousGoodsExtended::VT_EMERGENCYACTIONCODE, emergencyActionCode);
  }
  void add_phoneNumber(::flatbuffers::Offset<::flatbuffers::String> phoneNumber) {
    fbb_.AddOffset(DangerousGoodsExtended::VT_PHONENUMBER, phoneNumber);
  }
  void add_companyName(::flatbuffers::Offset<::flatbuffers::String> companyName) {
    fbb_.AddOffset(DangerousGoodsExtended::VT_COMPANYNAME, companyName);
  }
  explicit DangerousGoodsExtendedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DangerousGoodsExtended> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DangerousGoodsExtended>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DangerousGoodsExtended> CreateDangerousGoodsExtended(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DangerousGoodsBasic dangerousGoodsType = DangerousGoodsBasic_DGB_EXPLOSIVES1,
    uint32_t unNumber = 0,
    bool elevatedTemperature = false,
    bool tunnelsRestricted = false,
    bool limitedQuantity = false,
    ::flatbuffers::Offset<::flatbuffers::String> emergencyActionCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> phoneNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::String> companyName = 0) {
  DangerousGoodsExtendedBuilder builder_(_fbb);
  builder_.add_companyName(companyName);
  builder_.add_phoneNumber(phoneNumber);
  builder_.add_emergencyActionCode(emergencyActionCode);
  builder_.add_unNumber(unNumber);
  builder_.add_dangerousGoodsType(dangerousGoodsType);
  builder_.add_limitedQuantity(limitedQuantity);
  builder_.add_tunnelsRestricted(tunnelsRestricted);
  builder_.add_elevatedTemperature(elevatedTemperature);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DangerousGoodsExtended> CreateDangerousGoodsExtendedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DangerousGoodsBasic dangerousGoodsType = DangerousGoodsBasic_DGB_EXPLOSIVES1,
    uint32_t unNumber = 0,
    bool elevatedTemperature = false,
    bool tunnelsRestricted = false,
    bool limitedQuantity = false,
    const char *emergencyActionCode = nullptr,
    const char *phoneNumber = nullptr,
    const char *companyName = nullptr) {
  auto emergencyActionCode__ = emergencyActionCode ? _fbb.CreateString(emergencyActionCode) : 0;
  auto phoneNumber__ = phoneNumber ? _fbb.CreateString(phoneNumber) : 0;
  auto companyName__ = companyName ? _fbb.CreateString(companyName) : 0;
  return CreateDangerousGoodsExtended(
      _fbb,
      dangerousGoodsType,
      unNumber,
      elevatedTemperature,
      tunnelsRestricted,
      limitedQuantity,
      emergencyActionCode__,
      phoneNumber__,
      companyName__);
}

struct DeltaReferencePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeltaReferencePositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DELTALATITUDE = 4,
    VT_DELTALONGITUDE = 6,
    VT_DELTAALTITUDE = 8
  };
  int32_t deltaLatitude() const {
    return GetField<int32_t>(VT_DELTALATITUDE, 0);
  }
  int32_t deltaLongitude() const {
    return GetField<int32_t>(VT_DELTALONGITUDE, 0);
  }
  int32_t deltaAltitude() const {
    return GetField<int32_t>(VT_DELTAALTITUDE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DELTALATITUDE, 4) &&
           VerifyField<int32_t>(verifier, VT_DELTALONGITUDE, 4) &&
           VerifyField<int32_t>(verifier, VT_DELTAALTITUDE, 4) &&
           verifier.EndTable();
  }
};

struct DeltaReferencePositionBuilder {
  typedef DeltaReferencePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_deltaLatitude(int32_t deltaLatitude) {
    fbb_.AddElement<int32_t>(DeltaReferencePosition::VT_DELTALATITUDE, deltaLatitude, 0);
  }
  void add_deltaLongitude(int32_t deltaLongitude) {
    fbb_.AddElement<int32_t>(DeltaReferencePosition::VT_DELTALONGITUDE, deltaLongitude, 0);
  }
  void add_deltaAltitude(int32_t deltaAltitude) {
    fbb_.AddElement<int32_t>(DeltaReferencePosition::VT_DELTAALTITUDE, deltaAltitude, 0);
  }
  explicit DeltaReferencePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeltaReferencePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeltaReferencePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeltaReferencePosition> CreateDeltaReferencePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t deltaLatitude = 0,
    int32_t deltaLongitude = 0,
    int32_t deltaAltitude = 0) {
  DeltaReferencePositionBuilder builder_(_fbb);
  builder_.add_deltaAltitude(deltaAltitude);
  builder_.add_deltaLongitude(deltaLongitude);
  builder_.add_deltaLatitude(deltaLatitude);
  return builder_.Finish();
}

struct EnergyStorageType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnergyStorageTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HYDROGENSTORAGE = 4,
    VT_ELECTRICENERGYSTORAGE = 6,
    VT_LIQUIDPROPANEGAS = 8,
    VT_COMPRESSEDNATURALGAS = 10,
    VT_DIESEL = 12,
    VT_GASOLINE = 14,
    VT_AMMONIA = 16
  };
  bool hydrogenStorage() const {
    return GetField<uint8_t>(VT_HYDROGENSTORAGE, 0) != 0;
  }
  bool electricEnergyStorage() const {
    return GetField<uint8_t>(VT_ELECTRICENERGYSTORAGE, 0) != 0;
  }
  bool liquidPropaneGas() const {
    return GetField<uint8_t>(VT_LIQUIDPROPANEGAS, 0) != 0;
  }
  bool compressedNaturalGas() const {
    return GetField<uint8_t>(VT_COMPRESSEDNATURALGAS, 0) != 0;
  }
  bool diesel() const {
    return GetField<uint8_t>(VT_DIESEL, 0) != 0;
  }
  bool gasoline() const {
    return GetField<uint8_t>(VT_GASOLINE, 0) != 0;
  }
  bool ammonia() const {
    return GetField<uint8_t>(VT_AMMONIA, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HYDROGENSTORAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ELECTRICENERGYSTORAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIQUIDPROPANEGAS, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMPRESSEDNATURALGAS, 1) &&
           VerifyField<uint8_t>(verifier, VT_DIESEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_GASOLINE, 1) &&
           VerifyField<uint8_t>(verifier, VT_AMMONIA, 1) &&
           verifier.EndTable();
  }
};

struct EnergyStorageTypeBuilder {
  typedef EnergyStorageType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hydrogenStorage(bool hydrogenStorage) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_HYDROGENSTORAGE, static_cast<uint8_t>(hydrogenStorage), 0);
  }
  void add_electricEnergyStorage(bool electricEnergyStorage) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_ELECTRICENERGYSTORAGE, static_cast<uint8_t>(electricEnergyStorage), 0);
  }
  void add_liquidPropaneGas(bool liquidPropaneGas) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_LIQUIDPROPANEGAS, static_cast<uint8_t>(liquidPropaneGas), 0);
  }
  void add_compressedNaturalGas(bool compressedNaturalGas) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_COMPRESSEDNATURALGAS, static_cast<uint8_t>(compressedNaturalGas), 0);
  }
  void add_diesel(bool diesel) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_DIESEL, static_cast<uint8_t>(diesel), 0);
  }
  void add_gasoline(bool gasoline) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_GASOLINE, static_cast<uint8_t>(gasoline), 0);
  }
  void add_ammonia(bool ammonia) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_AMMONIA, static_cast<uint8_t>(ammonia), 0);
  }
  explicit EnergyStorageTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnergyStorageType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnergyStorageType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnergyStorageType> CreateEnergyStorageType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool hydrogenStorage = false,
    bool electricEnergyStorage = false,
    bool liquidPropaneGas = false,
    bool compressedNaturalGas = false,
    bool diesel = false,
    bool gasoline = false,
    bool ammonia = false) {
  EnergyStorageTypeBuilder builder_(_fbb);
  builder_.add_ammonia(ammonia);
  builder_.add_gasoline(gasoline);
  builder_.add_diesel(diesel);
  builder_.add_compressedNaturalGas(compressedNaturalGas);
  builder_.add_liquidPropaneGas(liquidPropaneGas);
  builder_.add_electricEnergyStorage(electricEnergyStorage);
  builder_.add_hydrogenStorage(hydrogenStorage);
  return builder_.Finish();
}

struct EllipticalShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EllipticalShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPEREFERENCEPOINT = 4,
    VT_SEMIMAJORAXISLENGTH = 6,
    VT_SEMIMINORAXISLENGTH = 8,
    VT_ORIENTATION = 10,
    VT_HEIGHT = 12
  };
  const CartesianPosition3d *shapeReferencePoint() const {
    return GetPointer<const CartesianPosition3d *>(VT_SHAPEREFERENCEPOINT);
  }
  uint32_t semiMajorAxisLength() const {
    return GetField<uint32_t>(VT_SEMIMAJORAXISLENGTH, 0);
  }
  uint32_t semiMinorAxisLength() const {
    return GetField<uint32_t>(VT_SEMIMINORAXISLENGTH, 0);
  }
  uint32_t orientation() const {
    return GetField<uint32_t>(VT_ORIENTATION, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPEREFERENCEPOINT) &&
           verifier.VerifyTable(shapeReferencePoint()) &&
           VerifyField<uint32_t>(verifier, VT_SEMIMAJORAXISLENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_SEMIMINORAXISLENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_ORIENTATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct EllipticalShapeBuilder {
  typedef EllipticalShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shapeReferencePoint(::flatbuffers::Offset<CartesianPosition3d> shapeReferencePoint) {
    fbb_.AddOffset(EllipticalShape::VT_SHAPEREFERENCEPOINT, shapeReferencePoint);
  }
  void add_semiMajorAxisLength(uint32_t semiMajorAxisLength) {
    fbb_.AddElement<uint32_t>(EllipticalShape::VT_SEMIMAJORAXISLENGTH, semiMajorAxisLength, 0);
  }
  void add_semiMinorAxisLength(uint32_t semiMinorAxisLength) {
    fbb_.AddElement<uint32_t>(EllipticalShape::VT_SEMIMINORAXISLENGTH, semiMinorAxisLength, 0);
  }
  void add_orientation(uint32_t orientation) {
    fbb_.AddElement<uint32_t>(EllipticalShape::VT_ORIENTATION, orientation, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(EllipticalShape::VT_HEIGHT, height, 0);
  }
  explicit EllipticalShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EllipticalShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EllipticalShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EllipticalShape> CreateEllipticalShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CartesianPosition3d> shapeReferencePoint = 0,
    uint32_t semiMajorAxisLength = 0,
    uint32_t semiMinorAxisLength = 0,
    uint32_t orientation = 0,
    uint32_t height = 0) {
  EllipticalShapeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_orientation(orientation);
  builder_.add_semiMinorAxisLength(semiMinorAxisLength);
  builder_.add_semiMajorAxisLength(semiMajorAxisLength);
  builder_.add_shapeReferencePoint(shapeReferencePoint);
  return builder_.Finish();
}

struct EulerAnglesWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EulerAnglesWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ZANGLE = 4,
    VT_YANGLE = 6,
    VT_XANGLE = 8
  };
  const CartesianAngle *zAngle() const {
    return GetPointer<const CartesianAngle *>(VT_ZANGLE);
  }
  const CartesianAngle *yAngle() const {
    return GetPointer<const CartesianAngle *>(VT_YANGLE);
  }
  const CartesianAngle *xAngle() const {
    return GetPointer<const CartesianAngle *>(VT_XANGLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ZANGLE) &&
           verifier.VerifyTable(zAngle()) &&
           VerifyOffset(verifier, VT_YANGLE) &&
           verifier.VerifyTable(yAngle()) &&
           VerifyOffset(verifier, VT_XANGLE) &&
           verifier.VerifyTable(xAngle()) &&
           verifier.EndTable();
  }
};

struct EulerAnglesWithConfidenceBuilder {
  typedef EulerAnglesWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_zAngle(::flatbuffers::Offset<CartesianAngle> zAngle) {
    fbb_.AddOffset(EulerAnglesWithConfidence::VT_ZANGLE, zAngle);
  }
  void add_yAngle(::flatbuffers::Offset<CartesianAngle> yAngle) {
    fbb_.AddOffset(EulerAnglesWithConfidence::VT_YANGLE, yAngle);
  }
  void add_xAngle(::flatbuffers::Offset<CartesianAngle> xAngle) {
    fbb_.AddOffset(EulerAnglesWithConfidence::VT_XANGLE, xAngle);
  }
  explicit EulerAnglesWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EulerAnglesWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EulerAnglesWithConfidence>(end);
    fbb_.Required(o, EulerAnglesWithConfidence::VT_ZANGLE);
    return o;
  }
};

inline ::flatbuffers::Offset<EulerAnglesWithConfidence> CreateEulerAnglesWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CartesianAngle> zAngle = 0,
    ::flatbuffers::Offset<CartesianAngle> yAngle = 0,
    ::flatbuffers::Offset<CartesianAngle> xAngle = 0) {
  EulerAnglesWithConfidenceBuilder builder_(_fbb);
  builder_.add_xAngle(xAngle);
  builder_.add_yAngle(yAngle);
  builder_.add_zAngle(zAngle);
  return builder_.Finish();
}

struct EventHistory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventHistoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_POINTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<EventPoint>> *event_points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EventPoint>> *>(VT_EVENT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENT_POINTS) &&
           verifier.VerifyVector(event_points()) &&
           verifier.VerifyVectorOfTables(event_points()) &&
           verifier.EndTable();
  }
};

struct EventHistoryBuilder {
  typedef EventHistory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EventPoint>>> event_points) {
    fbb_.AddOffset(EventHistory::VT_EVENT_POINTS, event_points);
  }
  explicit EventHistoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventHistory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventHistory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventHistory> CreateEventHistory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EventPoint>>> event_points = 0) {
  EventHistoryBuilder builder_(_fbb);
  builder_.add_event_points(event_points);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EventHistory> CreateEventHistoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<EventPoint>> *event_points = nullptr) {
  auto event_points__ = event_points ? _fbb.CreateVector<::flatbuffers::Offset<EventPoint>>(*event_points) : 0;
  return CreateEventHistory(
      _fbb,
      event_points__);
}

struct EventPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENTPOSITION = 4,
    VT_EVENTDELTATIME = 6,
    VT_INFORMATIONQUALITY = 8
  };
  const DeltaReferencePosition *eventPosition() const {
    return GetPointer<const DeltaReferencePosition *>(VT_EVENTPOSITION);
  }
  uint32_t eventDeltaTime() const {
    return GetField<uint32_t>(VT_EVENTDELTATIME, 0);
  }
  uint32_t informationQuality() const {
    return GetField<uint32_t>(VT_INFORMATIONQUALITY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EVENTPOSITION) &&
           verifier.VerifyTable(eventPosition()) &&
           VerifyField<uint32_t>(verifier, VT_EVENTDELTATIME, 4) &&
           VerifyField<uint32_t>(verifier, VT_INFORMATIONQUALITY, 4) &&
           verifier.EndTable();
  }
};

struct EventPointBuilder {
  typedef EventPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_eventPosition(::flatbuffers::Offset<DeltaReferencePosition> eventPosition) {
    fbb_.AddOffset(EventPoint::VT_EVENTPOSITION, eventPosition);
  }
  void add_eventDeltaTime(uint32_t eventDeltaTime) {
    fbb_.AddElement<uint32_t>(EventPoint::VT_EVENTDELTATIME, eventDeltaTime, 0);
  }
  void add_informationQuality(uint32_t informationQuality) {
    fbb_.AddElement<uint32_t>(EventPoint::VT_INFORMATIONQUALITY, informationQuality, 0);
  }
  explicit EventPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventPoint>(end);
    fbb_.Required(o, EventPoint::VT_EVENTPOSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<EventPoint> CreateEventPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<DeltaReferencePosition> eventPosition = 0,
    uint32_t eventDeltaTime = 0,
    uint32_t informationQuality = 0) {
  EventPointBuilder builder_(_fbb);
  builder_.add_informationQuality(informationQuality);
  builder_.add_eventDeltaTime(eventDeltaTime);
  builder_.add_eventPosition(eventPosition);
  return builder_.Finish();
}

struct Heading FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeadingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct HeadingBuilder {
  typedef Heading Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Heading::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(Heading::VT_CONFIDENCE, confidence, 0);
  }
  explicit HeadingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Heading> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Heading>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Heading> CreateHeading(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  HeadingBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct IntersectionReferenceID FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntersectionReferenceIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGION = 4,
    VT_ID = 6
  };
  int64_t region() const {
    return GetField<int64_t>(VT_REGION, 0);
  }
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_REGION, 8) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           verifier.EndTable();
  }
};

struct IntersectionReferenceIDBuilder {
  typedef IntersectionReferenceID Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_region(int64_t region) {
    fbb_.AddElement<int64_t>(IntersectionReferenceID::VT_REGION, region, 0);
  }
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(IntersectionReferenceID::VT_ID, id, 0);
  }
  explicit IntersectionReferenceIDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntersectionReferenceID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntersectionReferenceID>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntersectionReferenceID> CreateIntersectionReferenceID(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t region = 0,
    int64_t id = 0) {
  IntersectionReferenceIDBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_region(region);
  return builder_.Finish();
}

struct ItineraryPath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItineraryPathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ReferencePosition>> *path() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ReferencePosition>> *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfTables(path()) &&
           verifier.EndTable();
  }
};

struct ItineraryPathBuilder {
  typedef ItineraryPath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ReferencePosition>>> path) {
    fbb_.AddOffset(ItineraryPath::VT_PATH, path);
  }
  explicit ItineraryPathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ItineraryPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ItineraryPath>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ItineraryPath> CreateItineraryPath(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ReferencePosition>>> path = 0) {
  ItineraryPathBuilder builder_(_fbb);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ItineraryPath> CreateItineraryPathDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ReferencePosition>> *path = nullptr) {
  auto path__ = path ? _fbb.CreateVector<::flatbuffers::Offset<ReferencePosition>>(*path) : 0;
  return CreateItineraryPath(
      _fbb,
      path__);
}

struct LongitudinalAcceleration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LongitudinalAccelerationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  int32_t confidence() const {
    return GetField<int32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct LongitudinalAccelerationBuilder {
  typedef LongitudinalAcceleration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(LongitudinalAcceleration::VT_VALUE, value, 0);
  }
  void add_confidence(int32_t confidence) {
    fbb_.AddElement<int32_t>(LongitudinalAcceleration::VT_CONFIDENCE, confidence, 0);
  }
  explicit LongitudinalAccelerationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LongitudinalAcceleration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LongitudinalAcceleration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LongitudinalAcceleration> CreateLongitudinalAcceleration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    int32_t confidence = 0) {
  LongitudinalAccelerationBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct LongitudinalLanePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LongitudinalLanePositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDINALLANEPOSITIONVALUE = 4,
    VT_LONGITUDINALLANEPOSITIONCONFIDENCE = 6
  };
  uint32_t longitudinalLanePositionValue() const {
    return GetField<uint32_t>(VT_LONGITUDINALLANEPOSITIONVALUE, 0);
  }
  uint32_t longitudinalLanePositionConfidence() const {
    return GetField<uint32_t>(VT_LONGITUDINALLANEPOSITIONCONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LONGITUDINALLANEPOSITIONVALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_LONGITUDINALLANEPOSITIONCONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct LongitudinalLanePositionBuilder {
  typedef LongitudinalLanePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_longitudinalLanePositionValue(uint32_t longitudinalLanePositionValue) {
    fbb_.AddElement<uint32_t>(LongitudinalLanePosition::VT_LONGITUDINALLANEPOSITIONVALUE, longitudinalLanePositionValue, 0);
  }
  void add_longitudinalLanePositionConfidence(uint32_t longitudinalLanePositionConfidence) {
    fbb_.AddElement<uint32_t>(LongitudinalLanePosition::VT_LONGITUDINALLANEPOSITIONCONFIDENCE, longitudinalLanePositionConfidence, 0);
  }
  explicit LongitudinalLanePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LongitudinalLanePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LongitudinalLanePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LongitudinalLanePosition> CreateLongitudinalLanePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t longitudinalLanePositionValue = 0,
    uint32_t longitudinalLanePositionConfidence = 0) {
  LongitudinalLanePositionBuilder builder_(_fbb);
  builder_.add_longitudinalLanePositionConfidence(longitudinalLanePositionConfidence);
  builder_.add_longitudinalLanePositionValue(longitudinalLanePositionValue);
  return builder_.Finish();
}

struct LowerTriangularPositiveSemidefiniteMatrix FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LowerTriangularPositiveSemidefiniteMatrixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPONENTSINCLUDEDINTHEMATRIX = 4,
    VT_MATRIX = 6
  };
  const MatrixIncludedComponents *componentsIncludedIntheMatrix() const {
    return GetPointer<const MatrixIncludedComponents *>(VT_COMPONENTSINCLUDEDINTHEMATRIX);
  }
  const LowerTriangularPositiveSemidefiniteMatrixColumns *matrix() const {
    return GetPointer<const LowerTriangularPositiveSemidefiniteMatrixColumns *>(VT_MATRIX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COMPONENTSINCLUDEDINTHEMATRIX) &&
           verifier.VerifyTable(componentsIncludedIntheMatrix()) &&
           VerifyOffsetRequired(verifier, VT_MATRIX) &&
           verifier.VerifyTable(matrix()) &&
           verifier.EndTable();
  }
};

struct LowerTriangularPositiveSemidefiniteMatrixBuilder {
  typedef LowerTriangularPositiveSemidefiniteMatrix Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_componentsIncludedIntheMatrix(::flatbuffers::Offset<MatrixIncludedComponents> componentsIncludedIntheMatrix) {
    fbb_.AddOffset(LowerTriangularPositiveSemidefiniteMatrix::VT_COMPONENTSINCLUDEDINTHEMATRIX, componentsIncludedIntheMatrix);
  }
  void add_matrix(::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns> matrix) {
    fbb_.AddOffset(LowerTriangularPositiveSemidefiniteMatrix::VT_MATRIX, matrix);
  }
  explicit LowerTriangularPositiveSemidefiniteMatrixBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix>(end);
    fbb_.Required(o, LowerTriangularPositiveSemidefiniteMatrix::VT_COMPONENTSINCLUDEDINTHEMATRIX);
    fbb_.Required(o, LowerTriangularPositiveSemidefiniteMatrix::VT_MATRIX);
    return o;
  }
};

inline ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix> CreateLowerTriangularPositiveSemidefiniteMatrix(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MatrixIncludedComponents> componentsIncludedIntheMatrix = 0,
    ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns> matrix = 0) {
  LowerTriangularPositiveSemidefiniteMatrixBuilder builder_(_fbb);
  builder_.add_matrix(matrix);
  builder_.add_componentsIncludedIntheMatrix(componentsIncludedIntheMatrix);
  return builder_.Finish();
}

struct LowerTriangularPositiveSemidefiniteMatrixColumns FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CorrelationColumn>> *columns() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CorrelationColumn>> *>(VT_COLUMNS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
};

struct LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder {
  typedef LowerTriangularPositiveSemidefiniteMatrixColumns Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_columns(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CorrelationColumn>>> columns) {
    fbb_.AddOffset(LowerTriangularPositiveSemidefiniteMatrixColumns::VT_COLUMNS, columns);
  }
  explicit LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns> CreateLowerTriangularPositiveSemidefiniteMatrixColumns(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CorrelationColumn>>> columns = 0) {
  LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder builder_(_fbb);
  builder_.add_columns(columns);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns> CreateLowerTriangularPositiveSemidefiniteMatrixColumnsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CorrelationColumn>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<::flatbuffers::Offset<CorrelationColumn>>(*columns) : 0;
  return CreateLowerTriangularPositiveSemidefiniteMatrixColumns(
      _fbb,
      columns__);
}

struct MapPosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapPositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAPREFERENCE = 4,
    VT_LANEID = 6,
    VT_CONNECTIONID = 8,
    VT_LONGITUDINALLANEPOSITION = 10
  };
  const MapReference *mapReference() const {
    return GetPointer<const MapReference *>(VT_MAPREFERENCE);
  }
  uint32_t laneId() const {
    return GetField<uint32_t>(VT_LANEID, 0);
  }
  uint32_t connectionId() const {
    return GetField<uint32_t>(VT_CONNECTIONID, 0);
  }
  const LongitudinalLanePosition *longitudinalLanePosition() const {
    return GetPointer<const LongitudinalLanePosition *>(VT_LONGITUDINALLANEPOSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAPREFERENCE) &&
           verifier.VerifyTable(mapReference()) &&
           VerifyField<uint32_t>(verifier, VT_LANEID, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONNECTIONID, 4) &&
           VerifyOffset(verifier, VT_LONGITUDINALLANEPOSITION) &&
           verifier.VerifyTable(longitudinalLanePosition()) &&
           verifier.EndTable();
  }
};

struct MapPositionBuilder {
  typedef MapPosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mapReference(::flatbuffers::Offset<MapReference> mapReference) {
    fbb_.AddOffset(MapPosition::VT_MAPREFERENCE, mapReference);
  }
  void add_laneId(uint32_t laneId) {
    fbb_.AddElement<uint32_t>(MapPosition::VT_LANEID, laneId, 0);
  }
  void add_connectionId(uint32_t connectionId) {
    fbb_.AddElement<uint32_t>(MapPosition::VT_CONNECTIONID, connectionId, 0);
  }
  void add_longitudinalLanePosition(::flatbuffers::Offset<LongitudinalLanePosition> longitudinalLanePosition) {
    fbb_.AddOffset(MapPosition::VT_LONGITUDINALLANEPOSITION, longitudinalLanePosition);
  }
  explicit MapPositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MapPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MapPosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MapPosition> CreateMapPosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MapReference> mapReference = 0,
    uint32_t laneId = 0,
    uint32_t connectionId = 0,
    ::flatbuffers::Offset<LongitudinalLanePosition> longitudinalLanePosition = 0) {
  MapPositionBuilder builder_(_fbb);
  builder_.add_longitudinalLanePosition(longitudinalLanePosition);
  builder_.add_connectionId(connectionId);
  builder_.add_laneId(laneId);
  builder_.add_mapReference(mapReference);
  return builder_.Finish();
}

struct MapReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAPREF = 4
  };
  const MapReference_::Anonymous1 *mapref() const {
    return GetPointer<const MapReference_::Anonymous1 *>(VT_MAPREF);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAPREF) &&
           verifier.VerifyTable(mapref()) &&
           verifier.EndTable();
  }
};

struct MapReferenceBuilder {
  typedef MapReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mapref(::flatbuffers::Offset<MapReference_::Anonymous1> mapref) {
    fbb_.AddOffset(MapReference::VT_MAPREF, mapref);
  }
  explicit MapReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MapReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MapReference>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MapReference> CreateMapReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MapReference_::Anonymous1> mapref = 0) {
  MapReferenceBuilder builder_(_fbb);
  builder_.add_mapref(mapref);
  return builder_.Finish();
}

namespace MapReference_ {

struct Anonymous1 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous1Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROADSEGMENT = 4,
    VT_INTERSECTION = 6
  };
  const RoadSegmentReferenceID *roadsegment() const {
    return GetPointer<const RoadSegmentReferenceID *>(VT_ROADSEGMENT);
  }
  const IntersectionReferenceID *intersection() const {
    return GetPointer<const IntersectionReferenceID *>(VT_INTERSECTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROADSEGMENT) &&
           verifier.VerifyTable(roadsegment()) &&
           VerifyOffset(verifier, VT_INTERSECTION) &&
           verifier.VerifyTable(intersection()) &&
           verifier.EndTable();
  }
};

struct Anonymous1Builder {
  typedef Anonymous1 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_roadsegment(::flatbuffers::Offset<RoadSegmentReferenceID> roadsegment) {
    fbb_.AddOffset(Anonymous1::VT_ROADSEGMENT, roadsegment);
  }
  void add_intersection(::flatbuffers::Offset<IntersectionReferenceID> intersection) {
    fbb_.AddOffset(Anonymous1::VT_INTERSECTION, intersection);
  }
  explicit Anonymous1Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous1>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous1> CreateAnonymous1(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<RoadSegmentReferenceID> roadsegment = 0,
    ::flatbuffers::Offset<IntersectionReferenceID> intersection = 0) {
  Anonymous1Builder builder_(_fbb);
  builder_.add_intersection(intersection);
  builder_.add_roadsegment(roadsegment);
  return builder_.Finish();
}

}  // namespace MapReference_

struct MatrixIncludedComponents FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatrixIncludedComponentsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XPOSITION = 4,
    VT_YPOSITION = 6,
    VT_ZPOSITION = 8,
    VT_XVELOCITYORVELOCITYMAGNITUDE = 10,
    VT_YVELOCITYORVELOCITYDIRECTION = 12,
    VT_ZSPEED = 14,
    VT_XACCELORACCELMAGNITUDE = 16,
    VT_YACCELORACCELDIRECTION = 18,
    VT_ZACCELERATION = 20,
    VT_ZANGLE = 22,
    VT_YANGLE = 24,
    VT_XANGLE = 26,
    VT_ZANGULARVELOCITY = 28
  };
  bool xPosition() const {
    return GetField<uint8_t>(VT_XPOSITION, 0) != 0;
  }
  bool yPosition() const {
    return GetField<uint8_t>(VT_YPOSITION, 0) != 0;
  }
  bool zPosition() const {
    return GetField<uint8_t>(VT_ZPOSITION, 0) != 0;
  }
  bool xVelocityOrVelocityMagnitude() const {
    return GetField<uint8_t>(VT_XVELOCITYORVELOCITYMAGNITUDE, 0) != 0;
  }
  bool yVelocityOrVelocityDirection() const {
    return GetField<uint8_t>(VT_YVELOCITYORVELOCITYDIRECTION, 0) != 0;
  }
  bool zSpeed() const {
    return GetField<uint8_t>(VT_ZSPEED, 0) != 0;
  }
  bool xAccelOrAccelMagnitude() const {
    return GetField<uint8_t>(VT_XACCELORACCELMAGNITUDE, 0) != 0;
  }
  bool yAccelOrAccelDirection() const {
    return GetField<uint8_t>(VT_YACCELORACCELDIRECTION, 0) != 0;
  }
  bool zAcceleration() const {
    return GetField<uint8_t>(VT_ZACCELERATION, 0) != 0;
  }
  bool zAngle() const {
    return GetField<uint8_t>(VT_ZANGLE, 0) != 0;
  }
  bool yAngle() const {
    return GetField<uint8_t>(VT_YANGLE, 0) != 0;
  }
  bool xAngle() const {
    return GetField<uint8_t>(VT_XANGLE, 0) != 0;
  }
  bool zAngularVelocity() const {
    return GetField<uint8_t>(VT_ZANGULARVELOCITY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_XPOSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_YPOSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZPOSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_XVELOCITYORVELOCITYMAGNITUDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_YVELOCITYORVELOCITYDIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZSPEED, 1) &&
           VerifyField<uint8_t>(verifier, VT_XACCELORACCELMAGNITUDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_YACCELORACCELDIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZACCELERATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZANGLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_YANGLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_XANGLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZANGULARVELOCITY, 1) &&
           verifier.EndTable();
  }
};

struct MatrixIncludedComponentsBuilder {
  typedef MatrixIncludedComponents Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xPosition(bool xPosition) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_XPOSITION, static_cast<uint8_t>(xPosition), 0);
  }
  void add_yPosition(bool yPosition) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_YPOSITION, static_cast<uint8_t>(yPosition), 0);
  }
  void add_zPosition(bool zPosition) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_ZPOSITION, static_cast<uint8_t>(zPosition), 0);
  }
  void add_xVelocityOrVelocityMagnitude(bool xVelocityOrVelocityMagnitude) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_XVELOCITYORVELOCITYMAGNITUDE, static_cast<uint8_t>(xVelocityOrVelocityMagnitude), 0);
  }
  void add_yVelocityOrVelocityDirection(bool yVelocityOrVelocityDirection) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_YVELOCITYORVELOCITYDIRECTION, static_cast<uint8_t>(yVelocityOrVelocityDirection), 0);
  }
  void add_zSpeed(bool zSpeed) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_ZSPEED, static_cast<uint8_t>(zSpeed), 0);
  }
  void add_xAccelOrAccelMagnitude(bool xAccelOrAccelMagnitude) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_XACCELORACCELMAGNITUDE, static_cast<uint8_t>(xAccelOrAccelMagnitude), 0);
  }
  void add_yAccelOrAccelDirection(bool yAccelOrAccelDirection) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_YACCELORACCELDIRECTION, static_cast<uint8_t>(yAccelOrAccelDirection), 0);
  }
  void add_zAcceleration(bool zAcceleration) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_ZACCELERATION, static_cast<uint8_t>(zAcceleration), 0);
  }
  void add_zAngle(bool zAngle) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_ZANGLE, static_cast<uint8_t>(zAngle), 0);
  }
  void add_yAngle(bool yAngle) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_YANGLE, static_cast<uint8_t>(yAngle), 0);
  }
  void add_xAngle(bool xAngle) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_XANGLE, static_cast<uint8_t>(xAngle), 0);
  }
  void add_zAngularVelocity(bool zAngularVelocity) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_ZANGULARVELOCITY, static_cast<uint8_t>(zAngularVelocity), 0);
  }
  explicit MatrixIncludedComponentsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MatrixIncludedComponents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MatrixIncludedComponents>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MatrixIncludedComponents> CreateMatrixIncludedComponents(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool xPosition = false,
    bool yPosition = false,
    bool zPosition = false,
    bool xVelocityOrVelocityMagnitude = false,
    bool yVelocityOrVelocityDirection = false,
    bool zSpeed = false,
    bool xAccelOrAccelMagnitude = false,
    bool yAccelOrAccelDirection = false,
    bool zAcceleration = false,
    bool zAngle = false,
    bool yAngle = false,
    bool xAngle = false,
    bool zAngularVelocity = false) {
  MatrixIncludedComponentsBuilder builder_(_fbb);
  builder_.add_zAngularVelocity(zAngularVelocity);
  builder_.add_xAngle(xAngle);
  builder_.add_yAngle(yAngle);
  builder_.add_zAngle(zAngle);
  builder_.add_zAcceleration(zAcceleration);
  builder_.add_yAccelOrAccelDirection(yAccelOrAccelDirection);
  builder_.add_xAccelOrAccelMagnitude(xAccelOrAccelMagnitude);
  builder_.add_zSpeed(zSpeed);
  builder_.add_yVelocityOrVelocityDirection(yVelocityOrVelocityDirection);
  builder_.add_xVelocityOrVelocityMagnitude(xVelocityOrVelocityMagnitude);
  builder_.add_zPosition(zPosition);
  builder_.add_yPosition(yPosition);
  builder_.add_xPosition(xPosition);
  return builder_.Finish();
}

struct MessageRateHz FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageRateHzBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MANTISSA = 4,
    VT_EXPONENT = 6
  };
  uint32_t mantissa() const {
    return GetField<uint32_t>(VT_MANTISSA, 0);
  }
  int32_t exponent() const {
    return GetField<int32_t>(VT_EXPONENT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MANTISSA, 4) &&
           VerifyField<int32_t>(verifier, VT_EXPONENT, 4) &&
           verifier.EndTable();
  }
};

struct MessageRateHzBuilder {
  typedef MessageRateHz Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mantissa(uint32_t mantissa) {
    fbb_.AddElement<uint32_t>(MessageRateHz::VT_MANTISSA, mantissa, 0);
  }
  void add_exponent(int32_t exponent) {
    fbb_.AddElement<int32_t>(MessageRateHz::VT_EXPONENT, exponent, 0);
  }
  explicit MessageRateHzBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageRateHz> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageRateHz>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageRateHz> CreateMessageRateHz(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mantissa = 0,
    int32_t exponent = 0) {
  MessageRateHzBuilder builder_(_fbb);
  builder_.add_exponent(exponent);
  builder_.add_mantissa(mantissa);
  return builder_.Finish();
}

struct MessageSegmentationInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageSegmentationInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTALMSGNO = 4,
    VT_THISMSGNO = 6
  };
  uint32_t totalMsgNo() const {
    return GetField<uint32_t>(VT_TOTALMSGNO, 0);
  }
  uint32_t thisMsgNo() const {
    return GetField<uint32_t>(VT_THISMSGNO, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOTALMSGNO, 4) &&
           VerifyField<uint32_t>(verifier, VT_THISMSGNO, 4) &&
           verifier.EndTable();
  }
};

struct MessageSegmentationInfoBuilder {
  typedef MessageSegmentationInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_totalMsgNo(uint32_t totalMsgNo) {
    fbb_.AddElement<uint32_t>(MessageSegmentationInfo::VT_TOTALMSGNO, totalMsgNo, 0);
  }
  void add_thisMsgNo(uint32_t thisMsgNo) {
    fbb_.AddElement<uint32_t>(MessageSegmentationInfo::VT_THISMSGNO, thisMsgNo, 0);
  }
  explicit MessageSegmentationInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageSegmentationInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageSegmentationInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageSegmentationInfo> CreateMessageSegmentationInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t totalMsgNo = 0,
    uint32_t thisMsgNo = 0) {
  MessageSegmentationInfoBuilder builder_(_fbb);
  builder_.add_thisMsgNo(thisMsgNo);
  builder_.add_totalMsgNo(totalMsgNo);
  return builder_.Finish();
}

struct ObjectClass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectClassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_ = 4
  };
  const ObjectClass_::Anonymous2 *class_() const {
    return GetPointer<const ObjectClass_::Anonymous2 *>(VT_CLASS_);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLASS_) &&
           verifier.VerifyTable(class_()) &&
           verifier.EndTable();
  }
};

struct ObjectClassBuilder {
  typedef ObjectClass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_class_(::flatbuffers::Offset<ObjectClass_::Anonymous2> class_) {
    fbb_.AddOffset(ObjectClass::VT_CLASS_, class_);
  }
  explicit ObjectClassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectClass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectClass> CreateObjectClass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectClass_::Anonymous2> class_ = 0) {
  ObjectClassBuilder builder_(_fbb);
  builder_.add_class_(class_);
  return builder_.Finish();
}

namespace ObjectClass_ {

struct Anonymous2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEHICLESUBCLASS = 4,
    VT_VRUSUBCLASS = 6,
    VT_GROUPSUBCLASS = 8,
    VT_OTHERSUBCLASS = 10
  };
  TrafficParticipantType vehicleSubClass() const {
    return static_cast<TrafficParticipantType>(GetField<int32_t>(VT_VEHICLESUBCLASS, 0));
  }
  const VruProfileAndSubprofile *vruSubClass() const {
    return GetPointer<const VruProfileAndSubprofile *>(VT_VRUSUBCLASS);
  }
  const VruClusterInformation *groupSubClass() const {
    return GetPointer<const VruClusterInformation *>(VT_GROUPSUBCLASS);
  }
  const OtherSubClass *otherSubClass() const {
    return GetPointer<const OtherSubClass *>(VT_OTHERSUBCLASS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VEHICLESUBCLASS, 4) &&
           VerifyOffset(verifier, VT_VRUSUBCLASS) &&
           verifier.VerifyTable(vruSubClass()) &&
           VerifyOffset(verifier, VT_GROUPSUBCLASS) &&
           verifier.VerifyTable(groupSubClass()) &&
           VerifyOffset(verifier, VT_OTHERSUBCLASS) &&
           verifier.VerifyTable(otherSubClass()) &&
           verifier.EndTable();
  }
};

struct Anonymous2Builder {
  typedef Anonymous2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vehicleSubClass(TrafficParticipantType vehicleSubClass) {
    fbb_.AddElement<int32_t>(Anonymous2::VT_VEHICLESUBCLASS, static_cast<int32_t>(vehicleSubClass), 0);
  }
  void add_vruSubClass(::flatbuffers::Offset<VruProfileAndSubprofile> vruSubClass) {
    fbb_.AddOffset(Anonymous2::VT_VRUSUBCLASS, vruSubClass);
  }
  void add_groupSubClass(::flatbuffers::Offset<VruClusterInformation> groupSubClass) {
    fbb_.AddOffset(Anonymous2::VT_GROUPSUBCLASS, groupSubClass);
  }
  void add_otherSubClass(::flatbuffers::Offset<OtherSubClass> otherSubClass) {
    fbb_.AddOffset(Anonymous2::VT_OTHERSUBCLASS, otherSubClass);
  }
  explicit Anonymous2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous2> CreateAnonymous2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    TrafficParticipantType vehicleSubClass = TrafficParticipantType_TP_TYPE_UNKNOWN,
    ::flatbuffers::Offset<VruProfileAndSubprofile> vruSubClass = 0,
    ::flatbuffers::Offset<VruClusterInformation> groupSubClass = 0,
    ::flatbuffers::Offset<OtherSubClass> otherSubClass = 0) {
  Anonymous2Builder builder_(_fbb);
  builder_.add_otherSubClass(otherSubClass);
  builder_.add_groupSubClass(groupSubClass);
  builder_.add_vruSubClass(vruSubClass);
  builder_.add_vehicleSubClass(vehicleSubClass);
  return builder_.Finish();
}

}  // namespace ObjectClass_

struct ObjectClassWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectClassWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTCLASS = 4,
    VT_CONFIDENCE = 6
  };
  const ObjectClass *objectClass() const {
    return GetPointer<const ObjectClass *>(VT_OBJECTCLASS);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OBJECTCLASS) &&
           verifier.VerifyTable(objectClass()) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct ObjectClassWithConfidenceBuilder {
  typedef ObjectClassWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectClass(::flatbuffers::Offset<ObjectClass> objectClass) {
    fbb_.AddOffset(ObjectClassWithConfidence::VT_OBJECTCLASS, objectClass);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(ObjectClassWithConfidence::VT_CONFIDENCE, confidence, 0);
  }
  explicit ObjectClassWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectClassWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectClassWithConfidence>(end);
    fbb_.Required(o, ObjectClassWithConfidence::VT_OBJECTCLASS);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectClassWithConfidence> CreateObjectClassWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectClass> objectClass = 0,
    uint32_t confidence = 0) {
  ObjectClassWithConfidenceBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_objectClass(objectClass);
  return builder_.Finish();
}

struct ObjectDimension FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectDimensionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct ObjectDimensionBuilder {
  typedef ObjectDimension Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(ObjectDimension::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(ObjectDimension::VT_CONFIDENCE, confidence, 0);
  }
  explicit ObjectDimensionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectDimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectDimension>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectDimension> CreateObjectDimension(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0,
    uint32_t confidence = 0) {
  ObjectDimensionBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct OtherSubClass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtherSubClassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNKNOWN = 4,
    VT_SINGLEOBJECT = 6,
    VT_MULTIPLEOBJECTS = 8,
    VT_BULKMATERIAL = 10
  };
  bool unknown() const {
    return GetField<uint8_t>(VT_UNKNOWN, 0) != 0;
  }
  bool singleObject() const {
    return GetField<uint8_t>(VT_SINGLEOBJECT, 0) != 0;
  }
  bool multipleObjects() const {
    return GetField<uint8_t>(VT_MULTIPLEOBJECTS, 0) != 0;
  }
  bool bulkMaterial() const {
    return GetField<uint8_t>(VT_BULKMATERIAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UNKNOWN, 1) &&
           VerifyField<uint8_t>(verifier, VT_SINGLEOBJECT, 1) &&
           VerifyField<uint8_t>(verifier, VT_MULTIPLEOBJECTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_BULKMATERIAL, 1) &&
           verifier.EndTable();
  }
};

struct OtherSubClassBuilder {
  typedef OtherSubClass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unknown(bool unknown) {
    fbb_.AddElement<uint8_t>(OtherSubClass::VT_UNKNOWN, static_cast<uint8_t>(unknown), 0);
  }
  void add_singleObject(bool singleObject) {
    fbb_.AddElement<uint8_t>(OtherSubClass::VT_SINGLEOBJECT, static_cast<uint8_t>(singleObject), 0);
  }
  void add_multipleObjects(bool multipleObjects) {
    fbb_.AddElement<uint8_t>(OtherSubClass::VT_MULTIPLEOBJECTS, static_cast<uint8_t>(multipleObjects), 0);
  }
  void add_bulkMaterial(bool bulkMaterial) {
    fbb_.AddElement<uint8_t>(OtherSubClass::VT_BULKMATERIAL, static_cast<uint8_t>(bulkMaterial), 0);
  }
  explicit OtherSubClassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtherSubClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtherSubClass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OtherSubClass> CreateOtherSubClass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool unknown = false,
    bool singleObject = false,
    bool multipleObjects = false,
    bool bulkMaterial = false) {
  OtherSubClassBuilder builder_(_fbb);
  builder_.add_bulkMaterial(bulkMaterial);
  builder_.add_multipleObjects(multipleObjects);
  builder_.add_singleObject(singleObject);
  builder_.add_unknown(unknown);
  return builder_.Finish();
}

struct PolygonalShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolygonalShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPEREFERENCEPOINT = 4,
    VT_POLYGON = 6,
    VT_HEIGHT = 8
  };
  const CartesianPosition3d *shapeReferencePoint() const {
    return GetPointer<const CartesianPosition3d *>(VT_SHAPEREFERENCEPOINT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<CartesianPosition3d>> *polygon() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CartesianPosition3d>> *>(VT_POLYGON);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPEREFERENCEPOINT) &&
           verifier.VerifyTable(shapeReferencePoint()) &&
           VerifyOffset(verifier, VT_POLYGON) &&
           verifier.VerifyVector(polygon()) &&
           verifier.VerifyVectorOfTables(polygon()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct PolygonalShapeBuilder {
  typedef PolygonalShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shapeReferencePoint(::flatbuffers::Offset<CartesianPosition3d> shapeReferencePoint) {
    fbb_.AddOffset(PolygonalShape::VT_SHAPEREFERENCEPOINT, shapeReferencePoint);
  }
  void add_polygon(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CartesianPosition3d>>> polygon) {
    fbb_.AddOffset(PolygonalShape::VT_POLYGON, polygon);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(PolygonalShape::VT_HEIGHT, height, 0);
  }
  explicit PolygonalShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PolygonalShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PolygonalShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PolygonalShape> CreatePolygonalShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CartesianPosition3d> shapeReferencePoint = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CartesianPosition3d>>> polygon = 0,
    uint32_t height = 0) {
  PolygonalShapeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_polygon(polygon);
  builder_.add_shapeReferencePoint(shapeReferencePoint);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PolygonalShape> CreatePolygonalShapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CartesianPosition3d> shapeReferencePoint = 0,
    const std::vector<::flatbuffers::Offset<CartesianPosition3d>> *polygon = nullptr,
    uint32_t height = 0) {
  auto polygon__ = polygon ? _fbb.CreateVector<::flatbuffers::Offset<CartesianPosition3d>>(*polygon) : 0;
  return CreatePolygonalShape(
      _fbb,
      shapeReferencePoint,
      polygon__,
      height);
}

struct PositionConfidenceEllipse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PositionConfidenceEllipseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEMI_MAJOR_CONFIDENCE = 4,
    VT_SEMI_MINOR_CONFIDENCE = 6,
    VT_SEMI_MAJOR_ORIENTATION = 8
  };
  uint32_t semi_major_confidence() const {
    return GetField<uint32_t>(VT_SEMI_MAJOR_CONFIDENCE, 0);
  }
  uint32_t semi_minor_confidence() const {
    return GetField<uint32_t>(VT_SEMI_MINOR_CONFIDENCE, 0);
  }
  uint32_t semi_major_orientation() const {
    return GetField<uint32_t>(VT_SEMI_MAJOR_ORIENTATION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_MAJOR_CONFIDENCE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_MINOR_CONFIDENCE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_MAJOR_ORIENTATION, 4) &&
           verifier.EndTable();
  }
};

struct PositionConfidenceEllipseBuilder {
  typedef PositionConfidenceEllipse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_semi_major_confidence(uint32_t semi_major_confidence) {
    fbb_.AddElement<uint32_t>(PositionConfidenceEllipse::VT_SEMI_MAJOR_CONFIDENCE, semi_major_confidence, 0);
  }
  void add_semi_minor_confidence(uint32_t semi_minor_confidence) {
    fbb_.AddElement<uint32_t>(PositionConfidenceEllipse::VT_SEMI_MINOR_CONFIDENCE, semi_minor_confidence, 0);
  }
  void add_semi_major_orientation(uint32_t semi_major_orientation) {
    fbb_.AddElement<uint32_t>(PositionConfidenceEllipse::VT_SEMI_MAJOR_ORIENTATION, semi_major_orientation, 0);
  }
  explicit PositionConfidenceEllipseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PositionConfidenceEllipse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PositionConfidenceEllipse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PositionConfidenceEllipse> CreatePositionConfidenceEllipse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t semi_major_confidence = 0,
    uint32_t semi_minor_confidence = 0,
    uint32_t semi_major_orientation = 0) {
  PositionConfidenceEllipseBuilder builder_(_fbb);
  builder_.add_semi_major_orientation(semi_major_orientation);
  builder_.add_semi_minor_confidence(semi_minor_confidence);
  builder_.add_semi_major_confidence(semi_major_confidence);
  return builder_.Finish();
}

struct RadialShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadialShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAREDREFPOINT = 4,
    VT_RANGE = 6,
    VT_STATIONARYHORIZONTALOPENINGANGLESTART = 8,
    VT_STATIONARYHORIZONTALOPENINGANGLEEND = 10,
    VT_VERTICALOPENINGANGLESTART = 12,
    VT_VERTICALOPENINGANGLEEND = 14
  };
  const CartesianPosition3d *sharedRefPoint() const {
    return GetPointer<const CartesianPosition3d *>(VT_SHAREDREFPOINT);
  }
  uint32_t range() const {
    return GetField<uint32_t>(VT_RANGE, 0);
  }
  uint32_t stationaryHorizontalOpeningAngleStart() const {
    return GetField<uint32_t>(VT_STATIONARYHORIZONTALOPENINGANGLESTART, 0);
  }
  uint32_t stationaryHorizontalOpeningAngleEnd() const {
    return GetField<uint32_t>(VT_STATIONARYHORIZONTALOPENINGANGLEEND, 0);
  }
  uint32_t verticalOpeningAngleStart() const {
    return GetField<uint32_t>(VT_VERTICALOPENINGANGLESTART, 0);
  }
  uint32_t verticalOpeningAngleEnd() const {
    return GetField<uint32_t>(VT_VERTICALOPENINGANGLEEND, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAREDREFPOINT) &&
           verifier.VerifyTable(sharedRefPoint()) &&
           VerifyField<uint32_t>(verifier, VT_RANGE, 4) &&
           VerifyField<uint32_t>(verifier, VT_STATIONARYHORIZONTALOPENINGANGLESTART, 4) &&
           VerifyField<uint32_t>(verifier, VT_STATIONARYHORIZONTALOPENINGANGLEEND, 4) &&
           VerifyField<uint32_t>(verifier, VT_VERTICALOPENINGANGLESTART, 4) &&
           VerifyField<uint32_t>(verifier, VT_VERTICALOPENINGANGLEEND, 4) &&
           verifier.EndTable();
  }
};

struct RadialShapeBuilder {
  typedef RadialShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sharedRefPoint(::flatbuffers::Offset<CartesianPosition3d> sharedRefPoint) {
    fbb_.AddOffset(RadialShape::VT_SHAREDREFPOINT, sharedRefPoint);
  }
  void add_range(uint32_t range) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_RANGE, range, 0);
  }
  void add_stationaryHorizontalOpeningAngleStart(uint32_t stationaryHorizontalOpeningAngleStart) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_STATIONARYHORIZONTALOPENINGANGLESTART, stationaryHorizontalOpeningAngleStart, 0);
  }
  void add_stationaryHorizontalOpeningAngleEnd(uint32_t stationaryHorizontalOpeningAngleEnd) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_STATIONARYHORIZONTALOPENINGANGLEEND, stationaryHorizontalOpeningAngleEnd, 0);
  }
  void add_verticalOpeningAngleStart(uint32_t verticalOpeningAngleStart) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_VERTICALOPENINGANGLESTART, verticalOpeningAngleStart, 0);
  }
  void add_verticalOpeningAngleEnd(uint32_t verticalOpeningAngleEnd) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_VERTICALOPENINGANGLEEND, verticalOpeningAngleEnd, 0);
  }
  explicit RadialShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadialShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadialShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadialShape> CreateRadialShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CartesianPosition3d> sharedRefPoint = 0,
    uint32_t range = 0,
    uint32_t stationaryHorizontalOpeningAngleStart = 0,
    uint32_t stationaryHorizontalOpeningAngleEnd = 0,
    uint32_t verticalOpeningAngleStart = 0,
    uint32_t verticalOpeningAngleEnd = 0) {
  RadialShapeBuilder builder_(_fbb);
  builder_.add_verticalOpeningAngleEnd(verticalOpeningAngleEnd);
  builder_.add_verticalOpeningAngleStart(verticalOpeningAngleStart);
  builder_.add_stationaryHorizontalOpeningAngleEnd(stationaryHorizontalOpeningAngleEnd);
  builder_.add_stationaryHorizontalOpeningAngleStart(stationaryHorizontalOpeningAngleStart);
  builder_.add_range(range);
  builder_.add_sharedRefPoint(sharedRefPoint);
  return builder_.Finish();
}

struct RadialShapes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadialShapesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFPOINTID = 4,
    VT_X_CORD = 6,
    VT_Y_CORD = 8,
    VT_Z_CORD = 10,
    VT_RADIALSHAPESLIST = 12
  };
  uint32_t refPointID() const {
    return GetField<uint32_t>(VT_REFPOINTID, 0);
  }
  int32_t x_cord() const {
    return GetField<int32_t>(VT_X_CORD, 0);
  }
  int32_t y_cord() const {
    return GetField<int32_t>(VT_Y_CORD, 0);
  }
  int32_t z_cord() const {
    return GetField<int32_t>(VT_Z_CORD, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<RadialShapeDetails>> *radialShapesList() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<RadialShapeDetails>> *>(VT_RADIALSHAPESLIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REFPOINTID, 4) &&
           VerifyField<int32_t>(verifier, VT_X_CORD, 4) &&
           VerifyField<int32_t>(verifier, VT_Y_CORD, 4) &&
           VerifyField<int32_t>(verifier, VT_Z_CORD, 4) &&
           VerifyOffset(verifier, VT_RADIALSHAPESLIST) &&
           verifier.VerifyVector(radialShapesList()) &&
           verifier.VerifyVectorOfTables(radialShapesList()) &&
           verifier.EndTable();
  }
};

struct RadialShapesBuilder {
  typedef RadialShapes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_refPointID(uint32_t refPointID) {
    fbb_.AddElement<uint32_t>(RadialShapes::VT_REFPOINTID, refPointID, 0);
  }
  void add_x_cord(int32_t x_cord) {
    fbb_.AddElement<int32_t>(RadialShapes::VT_X_CORD, x_cord, 0);
  }
  void add_y_cord(int32_t y_cord) {
    fbb_.AddElement<int32_t>(RadialShapes::VT_Y_CORD, y_cord, 0);
  }
  void add_z_cord(int32_t z_cord) {
    fbb_.AddElement<int32_t>(RadialShapes::VT_Z_CORD, z_cord, 0);
  }
  void add_radialShapesList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RadialShapeDetails>>> radialShapesList) {
    fbb_.AddOffset(RadialShapes::VT_RADIALSHAPESLIST, radialShapesList);
  }
  explicit RadialShapesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadialShapes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadialShapes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadialShapes> CreateRadialShapes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t refPointID = 0,
    int32_t x_cord = 0,
    int32_t y_cord = 0,
    int32_t z_cord = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RadialShapeDetails>>> radialShapesList = 0) {
  RadialShapesBuilder builder_(_fbb);
  builder_.add_radialShapesList(radialShapesList);
  builder_.add_z_cord(z_cord);
  builder_.add_y_cord(y_cord);
  builder_.add_x_cord(x_cord);
  builder_.add_refPointID(refPointID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RadialShapes> CreateRadialShapesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t refPointID = 0,
    int32_t x_cord = 0,
    int32_t y_cord = 0,
    int32_t z_cord = 0,
    const std::vector<::flatbuffers::Offset<RadialShapeDetails>> *radialShapesList = nullptr) {
  auto radialShapesList__ = radialShapesList ? _fbb.CreateVector<::flatbuffers::Offset<RadialShapeDetails>>(*radialShapesList) : 0;
  return CreateRadialShapes(
      _fbb,
      refPointID,
      x_cord,
      y_cord,
      z_cord,
      radialShapesList__);
}

struct RadialShapeDetails FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadialShapeDetailsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANGE = 4,
    VT_HORIZONTALOPENINGANGLESTART = 6,
    VT_HORIZONTALOPENINGANGLEEND = 8,
    VT_VERTICALOPENINGANGLESTART = 10,
    VT_VERTICALOPENINGANGLEEND = 12
  };
  int32_t range() const {
    return GetField<int32_t>(VT_RANGE, 0);
  }
  uint32_t horizontalOpeningAngleStart() const {
    return GetField<uint32_t>(VT_HORIZONTALOPENINGANGLESTART, 0);
  }
  uint32_t horizontalOpeningAngleEnd() const {
    return GetField<uint32_t>(VT_HORIZONTALOPENINGANGLEEND, 0);
  }
  uint32_t verticalOpeningAngleStart() const {
    return GetField<uint32_t>(VT_VERTICALOPENINGANGLESTART, 0);
  }
  uint32_t verticalOpeningAngleEnd() const {
    return GetField<uint32_t>(VT_VERTICALOPENINGANGLEEND, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANGE, 4) &&
           VerifyField<uint32_t>(verifier, VT_HORIZONTALOPENINGANGLESTART, 4) &&
           VerifyField<uint32_t>(verifier, VT_HORIZONTALOPENINGANGLEEND, 4) &&
           VerifyField<uint32_t>(verifier, VT_VERTICALOPENINGANGLESTART, 4) &&
           VerifyField<uint32_t>(verifier, VT_VERTICALOPENINGANGLEEND, 4) &&
           verifier.EndTable();
  }
};

struct RadialShapeDetailsBuilder {
  typedef RadialShapeDetails Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_range(int32_t range) {
    fbb_.AddElement<int32_t>(RadialShapeDetails::VT_RANGE, range, 0);
  }
  void add_horizontalOpeningAngleStart(uint32_t horizontalOpeningAngleStart) {
    fbb_.AddElement<uint32_t>(RadialShapeDetails::VT_HORIZONTALOPENINGANGLESTART, horizontalOpeningAngleStart, 0);
  }
  void add_horizontalOpeningAngleEnd(uint32_t horizontalOpeningAngleEnd) {
    fbb_.AddElement<uint32_t>(RadialShapeDetails::VT_HORIZONTALOPENINGANGLEEND, horizontalOpeningAngleEnd, 0);
  }
  void add_verticalOpeningAngleStart(uint32_t verticalOpeningAngleStart) {
    fbb_.AddElement<uint32_t>(RadialShapeDetails::VT_VERTICALOPENINGANGLESTART, verticalOpeningAngleStart, 0);
  }
  void add_verticalOpeningAngleEnd(uint32_t verticalOpeningAngleEnd) {
    fbb_.AddElement<uint32_t>(RadialShapeDetails::VT_VERTICALOPENINGANGLEEND, verticalOpeningAngleEnd, 0);
  }
  explicit RadialShapeDetailsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadialShapeDetails> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadialShapeDetails>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadialShapeDetails> CreateRadialShapeDetails(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t range = 0,
    uint32_t horizontalOpeningAngleStart = 0,
    uint32_t horizontalOpeningAngleEnd = 0,
    uint32_t verticalOpeningAngleStart = 0,
    uint32_t verticalOpeningAngleEnd = 0) {
  RadialShapeDetailsBuilder builder_(_fbb);
  builder_.add_verticalOpeningAngleEnd(verticalOpeningAngleEnd);
  builder_.add_verticalOpeningAngleStart(verticalOpeningAngleStart);
  builder_.add_horizontalOpeningAngleEnd(horizontalOpeningAngleEnd);
  builder_.add_horizontalOpeningAngleStart(horizontalOpeningAngleStart);
  builder_.add_range(range);
  return builder_.Finish();
}

struct RectangularShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RectangularShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER_POINT = 4,
    VT_SEMILENGTH = 6,
    VT_SEMIBREADTH = 8,
    VT_ORIENTATION = 10,
    VT_HEIGHT = 12
  };
  const CartesianPosition3d *center_point() const {
    return GetPointer<const CartesianPosition3d *>(VT_CENTER_POINT);
  }
  uint32_t semiLength() const {
    return GetField<uint32_t>(VT_SEMILENGTH, 0);
  }
  uint32_t semiBreadth() const {
    return GetField<uint32_t>(VT_SEMIBREADTH, 0);
  }
  uint32_t orientation() const {
    return GetField<uint32_t>(VT_ORIENTATION, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CENTER_POINT) &&
           verifier.VerifyTable(center_point()) &&
           VerifyField<uint32_t>(verifier, VT_SEMILENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_SEMIBREADTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_ORIENTATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct RectangularShapeBuilder {
  typedef RectangularShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center_point(::flatbuffers::Offset<CartesianPosition3d> center_point) {
    fbb_.AddOffset(RectangularShape::VT_CENTER_POINT, center_point);
  }
  void add_semiLength(uint32_t semiLength) {
    fbb_.AddElement<uint32_t>(RectangularShape::VT_SEMILENGTH, semiLength, 0);
  }
  void add_semiBreadth(uint32_t semiBreadth) {
    fbb_.AddElement<uint32_t>(RectangularShape::VT_SEMIBREADTH, semiBreadth, 0);
  }
  void add_orientation(uint32_t orientation) {
    fbb_.AddElement<uint32_t>(RectangularShape::VT_ORIENTATION, orientation, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(RectangularShape::VT_HEIGHT, height, 0);
  }
  explicit RectangularShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RectangularShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RectangularShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RectangularShape> CreateRectangularShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CartesianPosition3d> center_point = 0,
    uint32_t semiLength = 0,
    uint32_t semiBreadth = 0,
    uint32_t orientation = 0,
    uint32_t height = 0) {
  RectangularShapeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_orientation(orientation);
  builder_.add_semiBreadth(semiBreadth);
  builder_.add_semiLength(semiLength);
  builder_.add_center_point(center_point);
  return builder_.Finish();
}

struct ReferenceDenms FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReferenceDenmsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION_IDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ActionID>> *action_IDs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ActionID>> *>(VT_ACTION_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION_IDS) &&
           verifier.VerifyVector(action_IDs()) &&
           verifier.VerifyVectorOfTables(action_IDs()) &&
           verifier.EndTable();
  }
};

struct ReferenceDenmsBuilder {
  typedef ReferenceDenms Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action_IDs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ActionID>>> action_IDs) {
    fbb_.AddOffset(ReferenceDenms::VT_ACTION_IDS, action_IDs);
  }
  explicit ReferenceDenmsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReferenceDenms> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReferenceDenms>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReferenceDenms> CreateReferenceDenms(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ActionID>>> action_IDs = 0) {
  ReferenceDenmsBuilder builder_(_fbb);
  builder_.add_action_IDs(action_IDs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReferenceDenms> CreateReferenceDenmsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ActionID>> *action_IDs = nullptr) {
  auto action_IDs__ = action_IDs ? _fbb.CreateVector<::flatbuffers::Offset<ActionID>>(*action_IDs) : 0;
  return CreateReferenceDenms(
      _fbb,
      action_IDs__);
}

struct ReferencePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReferencePositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATITUDE = 4,
    VT_LONGITUDE = 6,
    VT_POSITION_CONFIDENCE = 8,
    VT_ALTITUDE = 10
  };
  int64_t latitude() const {
    return GetField<int64_t>(VT_LATITUDE, 0);
  }
  int64_t longitude() const {
    return GetField<int64_t>(VT_LONGITUDE, 0);
  }
  const PositionConfidenceEllipse *position_confidence() const {
    return GetPointer<const PositionConfidenceEllipse *>(VT_POSITION_CONFIDENCE);
  }
  const Altitude *altitude() const {
    return GetPointer<const Altitude *>(VT_ALTITUDE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LATITUDE, 8) &&
           VerifyField<int64_t>(verifier, VT_LONGITUDE, 8) &&
           VerifyOffsetRequired(verifier, VT_POSITION_CONFIDENCE) &&
           verifier.VerifyTable(position_confidence()) &&
           VerifyOffsetRequired(verifier, VT_ALTITUDE) &&
           verifier.VerifyTable(altitude()) &&
           verifier.EndTable();
  }
};

struct ReferencePositionBuilder {
  typedef ReferencePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_latitude(int64_t latitude) {
    fbb_.AddElement<int64_t>(ReferencePosition::VT_LATITUDE, latitude, 0);
  }
  void add_longitude(int64_t longitude) {
    fbb_.AddElement<int64_t>(ReferencePosition::VT_LONGITUDE, longitude, 0);
  }
  void add_position_confidence(::flatbuffers::Offset<PositionConfidenceEllipse> position_confidence) {
    fbb_.AddOffset(ReferencePosition::VT_POSITION_CONFIDENCE, position_confidence);
  }
  void add_altitude(::flatbuffers::Offset<Altitude> altitude) {
    fbb_.AddOffset(ReferencePosition::VT_ALTITUDE, altitude);
  }
  explicit ReferencePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReferencePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReferencePosition>(end);
    fbb_.Required(o, ReferencePosition::VT_POSITION_CONFIDENCE);
    fbb_.Required(o, ReferencePosition::VT_ALTITUDE);
    return o;
  }
};

inline ::flatbuffers::Offset<ReferencePosition> CreateReferencePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t latitude = 0,
    int64_t longitude = 0,
    ::flatbuffers::Offset<PositionConfidenceEllipse> position_confidence = 0,
    ::flatbuffers::Offset<Altitude> altitude = 0) {
  ReferencePositionBuilder builder_(_fbb);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_altitude(altitude);
  builder_.add_position_confidence(position_confidence);
  return builder_.Finish();
}

struct RestrictedTypes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RestrictedTypesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESTRICTED_VEHICLES = 4
  };
  const ::flatbuffers::Vector<int32_t> *restricted_vehicles() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_RESTRICTED_VEHICLES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESTRICTED_VEHICLES) &&
           verifier.VerifyVector(restricted_vehicles()) &&
           verifier.EndTable();
  }
};

struct RestrictedTypesBuilder {
  typedef RestrictedTypes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_restricted_vehicles(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> restricted_vehicles) {
    fbb_.AddOffset(RestrictedTypes::VT_RESTRICTED_VEHICLES, restricted_vehicles);
  }
  explicit RestrictedTypesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RestrictedTypes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RestrictedTypes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RestrictedTypes> CreateRestrictedTypes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> restricted_vehicles = 0) {
  RestrictedTypesBuilder builder_(_fbb);
  builder_.add_restricted_vehicles(restricted_vehicles);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RestrictedTypes> CreateRestrictedTypesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *restricted_vehicles = nullptr) {
  auto restricted_vehicles__ = restricted_vehicles ? _fbb.CreateVector<int32_t>(*restricted_vehicles) : 0;
  return CreateRestrictedTypes(
      _fbb,
      restricted_vehicles__);
}

struct RoadSegmentReferenceID FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoadSegmentReferenceIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGION = 4,
    VT_ID = 6
  };
  int64_t region() const {
    return GetField<int64_t>(VT_REGION, 0);
  }
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_REGION, 8) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           verifier.EndTable();
  }
};

struct RoadSegmentReferenceIDBuilder {
  typedef RoadSegmentReferenceID Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_region(int64_t region) {
    fbb_.AddElement<int64_t>(RoadSegmentReferenceID::VT_REGION, region, 0);
  }
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(RoadSegmentReferenceID::VT_ID, id, 0);
  }
  explicit RoadSegmentReferenceIDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoadSegmentReferenceID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoadSegmentReferenceID>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoadSegmentReferenceID> CreateRoadSegmentReferenceID(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t region = 0,
    int64_t id = 0) {
  RoadSegmentReferenceIDBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_region(region);
  return builder_.Finish();
}

struct Shape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4
  };
  const Shape_::Anonymous3 *shape() const {
    return GetPointer<const Shape_::Anonymous3 *>(VT_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  typedef Shape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<Shape_::Anonymous3> shape) {
    fbb_.AddOffset(Shape::VT_SHAPE, shape);
  }
  explicit ShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Shape> CreateShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Shape_::Anonymous3> shape = 0) {
  ShapeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  return builder_.Finish();
}

namespace Shape_ {

struct Anonymous3 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECTANGULAR = 4,
    VT_CIRCULAR = 6,
    VT_POLYGONAL = 8,
    VT_ELLIPTICAL = 10,
    VT_RADIAL = 12,
    VT_RADIALSHAPES = 14
  };
  const RectangularShape *rectangular() const {
    return GetPointer<const RectangularShape *>(VT_RECTANGULAR);
  }
  const CircularShape *circular() const {
    return GetPointer<const CircularShape *>(VT_CIRCULAR);
  }
  const PolygonalShape *polygonal() const {
    return GetPointer<const PolygonalShape *>(VT_POLYGONAL);
  }
  const EllipticalShape *elliptical() const {
    return GetPointer<const EllipticalShape *>(VT_ELLIPTICAL);
  }
  const RadialShape *radial() const {
    return GetPointer<const RadialShape *>(VT_RADIAL);
  }
  const RadialShapes *radialShapes() const {
    return GetPointer<const RadialShapes *>(VT_RADIALSHAPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECTANGULAR) &&
           verifier.VerifyTable(rectangular()) &&
           VerifyOffset(verifier, VT_CIRCULAR) &&
           verifier.VerifyTable(circular()) &&
           VerifyOffset(verifier, VT_POLYGONAL) &&
           verifier.VerifyTable(polygonal()) &&
           VerifyOffset(verifier, VT_ELLIPTICAL) &&
           verifier.VerifyTable(elliptical()) &&
           VerifyOffset(verifier, VT_RADIAL) &&
           verifier.VerifyTable(radial()) &&
           VerifyOffset(verifier, VT_RADIALSHAPES) &&
           verifier.VerifyTable(radialShapes()) &&
           verifier.EndTable();
  }
};

struct Anonymous3Builder {
  typedef Anonymous3 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rectangular(::flatbuffers::Offset<RectangularShape> rectangular) {
    fbb_.AddOffset(Anonymous3::VT_RECTANGULAR, rectangular);
  }
  void add_circular(::flatbuffers::Offset<CircularShape> circular) {
    fbb_.AddOffset(Anonymous3::VT_CIRCULAR, circular);
  }
  void add_polygonal(::flatbuffers::Offset<PolygonalShape> polygonal) {
    fbb_.AddOffset(Anonymous3::VT_POLYGONAL, polygonal);
  }
  void add_elliptical(::flatbuffers::Offset<EllipticalShape> elliptical) {
    fbb_.AddOffset(Anonymous3::VT_ELLIPTICAL, elliptical);
  }
  void add_radial(::flatbuffers::Offset<RadialShape> radial) {
    fbb_.AddOffset(Anonymous3::VT_RADIAL, radial);
  }
  void add_radialShapes(::flatbuffers::Offset<RadialShapes> radialShapes) {
    fbb_.AddOffset(Anonymous3::VT_RADIALSHAPES, radialShapes);
  }
  explicit Anonymous3Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous3>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous3> CreateAnonymous3(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<RectangularShape> rectangular = 0,
    ::flatbuffers::Offset<CircularShape> circular = 0,
    ::flatbuffers::Offset<PolygonalShape> polygonal = 0,
    ::flatbuffers::Offset<EllipticalShape> elliptical = 0,
    ::flatbuffers::Offset<RadialShape> radial = 0,
    ::flatbuffers::Offset<RadialShapes> radialShapes = 0) {
  Anonymous3Builder builder_(_fbb);
  builder_.add_radialShapes(radialShapes);
  builder_.add_radial(radial);
  builder_.add_elliptical(elliptical);
  builder_.add_polygonal(polygonal);
  builder_.add_circular(circular);
  builder_.add_rectangular(rectangular);
  return builder_.Finish();
}

}  // namespace Shape_

struct Speed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct SpeedBuilder {
  typedef Speed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Speed::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(Speed::VT_CONFIDENCE, confidence, 0);
  }
  explicit SpeedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Speed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Speed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Speed> CreateSpeed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  SpeedBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VehicleIdentification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VehicleIdentificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WMINUMBER = 4,
    VT_VDS = 6
  };
  const ::flatbuffers::String *WMInumber() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WMINUMBER);
  }
  const ::flatbuffers::String *VDS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WMINUMBER) &&
           verifier.VerifyString(WMInumber()) &&
           VerifyOffset(verifier, VT_VDS) &&
           verifier.VerifyString(VDS()) &&
           verifier.EndTable();
  }
};

struct VehicleIdentificationBuilder {
  typedef VehicleIdentification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_WMInumber(::flatbuffers::Offset<::flatbuffers::String> WMInumber) {
    fbb_.AddOffset(VehicleIdentification::VT_WMINUMBER, WMInumber);
  }
  void add_VDS(::flatbuffers::Offset<::flatbuffers::String> VDS) {
    fbb_.AddOffset(VehicleIdentification::VT_VDS, VDS);
  }
  explicit VehicleIdentificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VehicleIdentification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VehicleIdentification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VehicleIdentification> CreateVehicleIdentification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> WMInumber = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VDS = 0) {
  VehicleIdentificationBuilder builder_(_fbb);
  builder_.add_VDS(VDS);
  builder_.add_WMInumber(WMInumber);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VehicleIdentification> CreateVehicleIdentificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *WMInumber = nullptr,
    const char *VDS = nullptr) {
  auto WMInumber__ = WMInumber ? _fbb.CreateString(WMInumber) : 0;
  auto VDS__ = VDS ? _fbb.CreateString(VDS) : 0;
  return CreateVehicleIdentification(
      _fbb,
      WMInumber__,
      VDS__);
}

struct VehicleLength FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VehicleLengthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_VEH_LEN_CONF_IND = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  VehicleLengthConfidenceIndication veh_len_conf_ind() const {
    return static_cast<VehicleLengthConfidenceIndication>(GetField<int32_t>(VT_VEH_LEN_CONF_IND, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_VEH_LEN_CONF_IND, 4) &&
           verifier.EndTable();
  }
};

struct VehicleLengthBuilder {
  typedef VehicleLength Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(VehicleLength::VT_VALUE, value, 0);
  }
  void add_veh_len_conf_ind(VehicleLengthConfidenceIndication veh_len_conf_ind) {
    fbb_.AddElement<int32_t>(VehicleLength::VT_VEH_LEN_CONF_IND, static_cast<int32_t>(veh_len_conf_ind), 0);
  }
  explicit VehicleLengthBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VehicleLength> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VehicleLength>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VehicleLength> CreateVehicleLength(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    VehicleLengthConfidenceIndication veh_len_conf_ind = VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT) {
  VehicleLengthBuilder builder_(_fbb);
  builder_.add_veh_len_conf_ind(veh_len_conf_ind);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VehicleWidth FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VehicleWidthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct VehicleWidthBuilder {
  typedef VehicleWidth Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(VehicleWidth::VT_VALUE, value, 0);
  }
  explicit VehicleWidthBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VehicleWidth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VehicleWidth>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VehicleWidth> CreateVehicleWidth(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  VehicleWidthBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VelocityCartesian FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityCartesianBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XVELOCITY = 4,
    VT_YVELOCITY = 6,
    VT_ZVELOCITY = 8
  };
  const VelocityComponent *xVelocity() const {
    return GetPointer<const VelocityComponent *>(VT_XVELOCITY);
  }
  const VelocityComponent *yVelocity() const {
    return GetPointer<const VelocityComponent *>(VT_YVELOCITY);
  }
  const VelocityComponent *zVelocity() const {
    return GetPointer<const VelocityComponent *>(VT_ZVELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_XVELOCITY) &&
           verifier.VerifyTable(xVelocity()) &&
           VerifyOffsetRequired(verifier, VT_YVELOCITY) &&
           verifier.VerifyTable(yVelocity()) &&
           VerifyOffset(verifier, VT_ZVELOCITY) &&
           verifier.VerifyTable(zVelocity()) &&
           verifier.EndTable();
  }
};

struct VelocityCartesianBuilder {
  typedef VelocityCartesian Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xVelocity(::flatbuffers::Offset<VelocityComponent> xVelocity) {
    fbb_.AddOffset(VelocityCartesian::VT_XVELOCITY, xVelocity);
  }
  void add_yVelocity(::flatbuffers::Offset<VelocityComponent> yVelocity) {
    fbb_.AddOffset(VelocityCartesian::VT_YVELOCITY, yVelocity);
  }
  void add_zVelocity(::flatbuffers::Offset<VelocityComponent> zVelocity) {
    fbb_.AddOffset(VelocityCartesian::VT_ZVELOCITY, zVelocity);
  }
  explicit VelocityCartesianBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityCartesian> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityCartesian>(end);
    fbb_.Required(o, VelocityCartesian::VT_XVELOCITY);
    fbb_.Required(o, VelocityCartesian::VT_YVELOCITY);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityCartesian> CreateVelocityCartesian(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<VelocityComponent> xVelocity = 0,
    ::flatbuffers::Offset<VelocityComponent> yVelocity = 0,
    ::flatbuffers::Offset<VelocityComponent> zVelocity = 0) {
  VelocityCartesianBuilder builder_(_fbb);
  builder_.add_zVelocity(zVelocity);
  builder_.add_yVelocity(yVelocity);
  builder_.add_xVelocity(xVelocity);
  return builder_.Finish();
}

struct VelocityComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEL_COMP_VALUE = 4,
    VT_SPEED_CONFIDENCE = 6
  };
  int32_t vel_comp_value() const {
    return GetField<int32_t>(VT_VEL_COMP_VALUE, 0);
  }
  uint32_t speed_confidence() const {
    return GetField<uint32_t>(VT_SPEED_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VEL_COMP_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SPEED_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct VelocityComponentBuilder {
  typedef VelocityComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vel_comp_value(int32_t vel_comp_value) {
    fbb_.AddElement<int32_t>(VelocityComponent::VT_VEL_COMP_VALUE, vel_comp_value, 0);
  }
  void add_speed_confidence(uint32_t speed_confidence) {
    fbb_.AddElement<uint32_t>(VelocityComponent::VT_SPEED_CONFIDENCE, speed_confidence, 0);
  }
  explicit VelocityComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityComponent> CreateVelocityComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t vel_comp_value = 0,
    uint32_t speed_confidence = 0) {
  VelocityComponentBuilder builder_(_fbb);
  builder_.add_speed_confidence(speed_confidence);
  builder_.add_vel_comp_value(vel_comp_value);
  return builder_.Finish();
}

struct VelocityPolarWithZ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityPolarWithZBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VELOCITYMAGNITUDE = 4,
    VT_VELOCITYDIRECTION = 6,
    VT_ZVELOCITY = 8
  };
  const Speed *velocityMagnitude() const {
    return GetPointer<const Speed *>(VT_VELOCITYMAGNITUDE);
  }
  const CartesianAngle *velocityDirection() const {
    return GetPointer<const CartesianAngle *>(VT_VELOCITYDIRECTION);
  }
  const VelocityComponent *zVelocity() const {
    return GetPointer<const VelocityComponent *>(VT_ZVELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VELOCITYMAGNITUDE) &&
           verifier.VerifyTable(velocityMagnitude()) &&
           VerifyOffsetRequired(verifier, VT_VELOCITYDIRECTION) &&
           verifier.VerifyTable(velocityDirection()) &&
           VerifyOffset(verifier, VT_ZVELOCITY) &&
           verifier.VerifyTable(zVelocity()) &&
           verifier.EndTable();
  }
};

struct VelocityPolarWithZBuilder {
  typedef VelocityPolarWithZ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_velocityMagnitude(::flatbuffers::Offset<Speed> velocityMagnitude) {
    fbb_.AddOffset(VelocityPolarWithZ::VT_VELOCITYMAGNITUDE, velocityMagnitude);
  }
  void add_velocityDirection(::flatbuffers::Offset<CartesianAngle> velocityDirection) {
    fbb_.AddOffset(VelocityPolarWithZ::VT_VELOCITYDIRECTION, velocityDirection);
  }
  void add_zVelocity(::flatbuffers::Offset<VelocityComponent> zVelocity) {
    fbb_.AddOffset(VelocityPolarWithZ::VT_ZVELOCITY, zVelocity);
  }
  explicit VelocityPolarWithZBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityPolarWithZ> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityPolarWithZ>(end);
    fbb_.Required(o, VelocityPolarWithZ::VT_VELOCITYMAGNITUDE);
    fbb_.Required(o, VelocityPolarWithZ::VT_VELOCITYDIRECTION);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityPolarWithZ> CreateVelocityPolarWithZ(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Speed> velocityMagnitude = 0,
    ::flatbuffers::Offset<CartesianAngle> velocityDirection = 0,
    ::flatbuffers::Offset<VelocityComponent> zVelocity = 0) {
  VelocityPolarWithZBuilder builder_(_fbb);
  builder_.add_zVelocity(zVelocity);
  builder_.add_velocityDirection(velocityDirection);
  builder_.add_velocityMagnitude(velocityMagnitude);
  return builder_.Finish();
}

struct Velocity3dWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Velocity3dWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VELOCITY = 4
  };
  const Velocity3dWithConfidence_::Anonymous4 *velocity() const {
    return GetPointer<const Velocity3dWithConfidence_::Anonymous4 *>(VT_VELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyTable(velocity()) &&
           verifier.EndTable();
  }
};

struct Velocity3dWithConfidenceBuilder {
  typedef Velocity3dWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_velocity(::flatbuffers::Offset<Velocity3dWithConfidence_::Anonymous4> velocity) {
    fbb_.AddOffset(Velocity3dWithConfidence::VT_VELOCITY, velocity);
  }
  explicit Velocity3dWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Velocity3dWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Velocity3dWithConfidence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Velocity3dWithConfidence> CreateVelocity3dWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Velocity3dWithConfidence_::Anonymous4> velocity = 0) {
  Velocity3dWithConfidenceBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  return builder_.Finish();
}

namespace Velocity3dWithConfidence_ {

struct Anonymous4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous4Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POLARVELOCITY = 4,
    VT_CARTESIANVELOCITY = 6
  };
  const VelocityPolarWithZ *polarVelocity() const {
    return GetPointer<const VelocityPolarWithZ *>(VT_POLARVELOCITY);
  }
  const VelocityCartesian *cartesianVelocity() const {
    return GetPointer<const VelocityCartesian *>(VT_CARTESIANVELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POLARVELOCITY) &&
           verifier.VerifyTable(polarVelocity()) &&
           VerifyOffset(verifier, VT_CARTESIANVELOCITY) &&
           verifier.VerifyTable(cartesianVelocity()) &&
           verifier.EndTable();
  }
};

struct Anonymous4Builder {
  typedef Anonymous4 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_polarVelocity(::flatbuffers::Offset<VelocityPolarWithZ> polarVelocity) {
    fbb_.AddOffset(Anonymous4::VT_POLARVELOCITY, polarVelocity);
  }
  void add_cartesianVelocity(::flatbuffers::Offset<VelocityCartesian> cartesianVelocity) {
    fbb_.AddOffset(Anonymous4::VT_CARTESIANVELOCITY, cartesianVelocity);
  }
  explicit Anonymous4Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous4>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous4> CreateAnonymous4(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<VelocityPolarWithZ> polarVelocity = 0,
    ::flatbuffers::Offset<VelocityCartesian> cartesianVelocity = 0) {
  Anonymous4Builder builder_(_fbb);
  builder_.add_cartesianVelocity(cartesianVelocity);
  builder_.add_polarVelocity(polarVelocity);
  return builder_.Finish();
}

}  // namespace Velocity3dWithConfidence_

struct VruClusterInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VruClusterInformationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLUSTERID = 4,
    VT_CLUSTERBOUNDINGBOXSHAPE = 6,
    VT_CLUSTERCARDINALITYSIZE = 8,
    VT_CLUSTERPROFILES = 10
  };
  uint32_t clusterId() const {
    return GetField<uint32_t>(VT_CLUSTERID, 0);
  }
  const Shape *clusterBoundingBoxShape() const {
    return GetPointer<const Shape *>(VT_CLUSTERBOUNDINGBOXSHAPE);
  }
  uint32_t clusterCardinalitySize() const {
    return GetField<uint32_t>(VT_CLUSTERCARDINALITYSIZE, 0);
  }
  const VruClusterProfiles *clusterProfiles() const {
    return GetPointer<const VruClusterProfiles *>(VT_CLUSTERPROFILES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CLUSTERID, 4) &&
           VerifyOffset(verifier, VT_CLUSTERBOUNDINGBOXSHAPE) &&
           verifier.VerifyTable(clusterBoundingBoxShape()) &&
           VerifyField<uint32_t>(verifier, VT_CLUSTERCARDINALITYSIZE, 4) &&
           VerifyOffset(verifier, VT_CLUSTERPROFILES) &&
           verifier.VerifyTable(clusterProfiles()) &&
           verifier.EndTable();
  }
};

struct VruClusterInformationBuilder {
  typedef VruClusterInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_clusterId(uint32_t clusterId) {
    fbb_.AddElement<uint32_t>(VruClusterInformation::VT_CLUSTERID, clusterId, 0);
  }
  void add_clusterBoundingBoxShape(::flatbuffers::Offset<Shape> clusterBoundingBoxShape) {
    fbb_.AddOffset(VruClusterInformation::VT_CLUSTERBOUNDINGBOXSHAPE, clusterBoundingBoxShape);
  }
  void add_clusterCardinalitySize(uint32_t clusterCardinalitySize) {
    fbb_.AddElement<uint32_t>(VruClusterInformation::VT_CLUSTERCARDINALITYSIZE, clusterCardinalitySize, 0);
  }
  void add_clusterProfiles(::flatbuffers::Offset<VruClusterProfiles> clusterProfiles) {
    fbb_.AddOffset(VruClusterInformation::VT_CLUSTERPROFILES, clusterProfiles);
  }
  explicit VruClusterInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VruClusterInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VruClusterInformation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VruClusterInformation> CreateVruClusterInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t clusterId = 0,
    ::flatbuffers::Offset<Shape> clusterBoundingBoxShape = 0,
    uint32_t clusterCardinalitySize = 0,
    ::flatbuffers::Offset<VruClusterProfiles> clusterProfiles = 0) {
  VruClusterInformationBuilder builder_(_fbb);
  builder_.add_clusterProfiles(clusterProfiles);
  builder_.add_clusterCardinalitySize(clusterCardinalitySize);
  builder_.add_clusterBoundingBoxShape(clusterBoundingBoxShape);
  builder_.add_clusterId(clusterId);
  return builder_.Finish();
}

struct VruClusterProfiles FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VruClusterProfilesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEDESTRIAN = 4,
    VT_BICYCLIST = 6,
    VT_MOTORCYCLIST = 8,
    VT_ANIMAL = 10
  };
  bool pedestrian() const {
    return GetField<uint8_t>(VT_PEDESTRIAN, 0) != 0;
  }
  bool bicyclist() const {
    return GetField<uint8_t>(VT_BICYCLIST, 0) != 0;
  }
  bool motorcyclist() const {
    return GetField<uint8_t>(VT_MOTORCYCLIST, 0) != 0;
  }
  bool animal() const {
    return GetField<uint8_t>(VT_ANIMAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PEDESTRIAN, 1) &&
           VerifyField<uint8_t>(verifier, VT_BICYCLIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_MOTORCYCLIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_ANIMAL, 1) &&
           verifier.EndTable();
  }
};

struct VruClusterProfilesBuilder {
  typedef VruClusterProfiles Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pedestrian(bool pedestrian) {
    fbb_.AddElement<uint8_t>(VruClusterProfiles::VT_PEDESTRIAN, static_cast<uint8_t>(pedestrian), 0);
  }
  void add_bicyclist(bool bicyclist) {
    fbb_.AddElement<uint8_t>(VruClusterProfiles::VT_BICYCLIST, static_cast<uint8_t>(bicyclist), 0);
  }
  void add_motorcyclist(bool motorcyclist) {
    fbb_.AddElement<uint8_t>(VruClusterProfiles::VT_MOTORCYCLIST, static_cast<uint8_t>(motorcyclist), 0);
  }
  void add_animal(bool animal) {
    fbb_.AddElement<uint8_t>(VruClusterProfiles::VT_ANIMAL, static_cast<uint8_t>(animal), 0);
  }
  explicit VruClusterProfilesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VruClusterProfiles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VruClusterProfiles>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VruClusterProfiles> CreateVruClusterProfiles(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool pedestrian = false,
    bool bicyclist = false,
    bool motorcyclist = false,
    bool animal = false) {
  VruClusterProfilesBuilder builder_(_fbb);
  builder_.add_animal(animal);
  builder_.add_motorcyclist(motorcyclist);
  builder_.add_bicyclist(bicyclist);
  builder_.add_pedestrian(pedestrian);
  return builder_.Finish();
}

struct VruProfileAndSubprofile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VruProfileAndSubprofileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VRU = 4
  };
  const VruProfileAndSubprofile_::Anonymous5 *vru() const {
    return GetPointer<const VruProfileAndSubprofile_::Anonymous5 *>(VT_VRU);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VRU) &&
           verifier.VerifyTable(vru()) &&
           verifier.EndTable();
  }
};

struct VruProfileAndSubprofileBuilder {
  typedef VruProfileAndSubprofile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vru(::flatbuffers::Offset<VruProfileAndSubprofile_::Anonymous5> vru) {
    fbb_.AddOffset(VruProfileAndSubprofile::VT_VRU, vru);
  }
  explicit VruProfileAndSubprofileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VruProfileAndSubprofile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VruProfileAndSubprofile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VruProfileAndSubprofile> CreateVruProfileAndSubprofile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<VruProfileAndSubprofile_::Anonymous5> vru = 0) {
  VruProfileAndSubprofileBuilder builder_(_fbb);
  builder_.add_vru(vru);
  return builder_.Finish();
}

namespace VruProfileAndSubprofile_ {

struct Anonymous5 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous5Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEDESTRIAN = 4,
    VT_BICYCLISTANDLIGHTVRUVEHICLE = 6,
    VT_MOTORCYCLIST = 8,
    VT_ANIMAL = 10
  };
  VruSubProfilePedestrian pedestrian() const {
    return static_cast<VruSubProfilePedestrian>(GetField<int32_t>(VT_PEDESTRIAN, 0));
  }
  VruSubProfileBicyclist bicyclistAndLightVruVehicle() const {
    return static_cast<VruSubProfileBicyclist>(GetField<int32_t>(VT_BICYCLISTANDLIGHTVRUVEHICLE, 0));
  }
  VruSubProfileMotorcyclist motorcyclist() const {
    return static_cast<VruSubProfileMotorcyclist>(GetField<int32_t>(VT_MOTORCYCLIST, 0));
  }
  VruSubProfileAnimal animal() const {
    return static_cast<VruSubProfileAnimal>(GetField<int32_t>(VT_ANIMAL, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEDESTRIAN, 4) &&
           VerifyField<int32_t>(verifier, VT_BICYCLISTANDLIGHTVRUVEHICLE, 4) &&
           VerifyField<int32_t>(verifier, VT_MOTORCYCLIST, 4) &&
           VerifyField<int32_t>(verifier, VT_ANIMAL, 4) &&
           verifier.EndTable();
  }
};

struct Anonymous5Builder {
  typedef Anonymous5 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pedestrian(VruSubProfilePedestrian pedestrian) {
    fbb_.AddElement<int32_t>(Anonymous5::VT_PEDESTRIAN, static_cast<int32_t>(pedestrian), 0);
  }
  void add_bicyclistAndLightVruVehicle(VruSubProfileBicyclist bicyclistAndLightVruVehicle) {
    fbb_.AddElement<int32_t>(Anonymous5::VT_BICYCLISTANDLIGHTVRUVEHICLE, static_cast<int32_t>(bicyclistAndLightVruVehicle), 0);
  }
  void add_motorcyclist(VruSubProfileMotorcyclist motorcyclist) {
    fbb_.AddElement<int32_t>(Anonymous5::VT_MOTORCYCLIST, static_cast<int32_t>(motorcyclist), 0);
  }
  void add_animal(VruSubProfileAnimal animal) {
    fbb_.AddElement<int32_t>(Anonymous5::VT_ANIMAL, static_cast<int32_t>(animal), 0);
  }
  explicit Anonymous5Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous5> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous5>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous5> CreateAnonymous5(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VruSubProfilePedestrian pedestrian = VruSubProfilePedestrian_PED_UNAVAILABLE,
    VruSubProfileBicyclist bicyclistAndLightVruVehicle = VruSubProfileBicyclist_BC_UNAVAILABLE,
    VruSubProfileMotorcyclist motorcyclist = VruSubProfileMotorcyclist_MC_UNAVAILABLE,
    VruSubProfileAnimal animal = VruSubProfileAnimal_AN_UNAVAILABLE) {
  Anonymous5Builder builder_(_fbb);
  builder_.add_animal(animal);
  builder_.add_motorcyclist(motorcyclist);
  builder_.add_bicyclistAndLightVruVehicle(bicyclistAndLightVruVehicle);
  builder_.add_pedestrian(pedestrian);
  return builder_.Finish();
}

}  // namespace VruProfileAndSubprofile_

struct Wgs84Angle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Wgs84AngleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WGSANGLEVALUE = 4,
    VT_WGS84ANGLECONFIDENCE = 6
  };
  uint32_t wgsAngleValue() const {
    return GetField<uint32_t>(VT_WGSANGLEVALUE, 0);
  }
  uint32_t wgs84AngleConfidence() const {
    return GetField<uint32_t>(VT_WGS84ANGLECONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_WGSANGLEVALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_WGS84ANGLECONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct Wgs84AngleBuilder {
  typedef Wgs84Angle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wgsAngleValue(uint32_t wgsAngleValue) {
    fbb_.AddElement<uint32_t>(Wgs84Angle::VT_WGSANGLEVALUE, wgsAngleValue, 0);
  }
  void add_wgs84AngleConfidence(uint32_t wgs84AngleConfidence) {
    fbb_.AddElement<uint32_t>(Wgs84Angle::VT_WGS84ANGLECONFIDENCE, wgs84AngleConfidence, 0);
  }
  explicit Wgs84AngleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Wgs84Angle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Wgs84Angle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Wgs84Angle> CreateWgs84Angle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t wgsAngleValue = 0,
    uint32_t wgs84AngleConfidence = 0) {
  Wgs84AngleBuilder builder_(_fbb);
  builder_.add_wgs84AngleConfidence(wgs84AngleConfidence);
  builder_.add_wgsAngleValue(wgsAngleValue);
  return builder_.Finish();
}

struct YawRate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef YawRateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_YAWRATEVALUE = 4,
    VT_YAWRATECONFIDENCE = 6
  };
  int32_t yawratevalue() const {
    return GetField<int32_t>(VT_YAWRATEVALUE, 0);
  }
  YawRateConfidence yawrateconfidence() const {
    return static_cast<YawRateConfidence>(GetField<int32_t>(VT_YAWRATECONFIDENCE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_YAWRATEVALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_YAWRATECONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct YawRateBuilder {
  typedef YawRate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_yawratevalue(int32_t yawratevalue) {
    fbb_.AddElement<int32_t>(YawRate::VT_YAWRATEVALUE, yawratevalue, 0);
  }
  void add_yawrateconfidence(YawRateConfidence yawrateconfidence) {
    fbb_.AddElement<int32_t>(YawRate::VT_YAWRATECONFIDENCE, static_cast<int32_t>(yawrateconfidence), 0);
  }
  explicit YawRateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<YawRate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<YawRate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<YawRate> CreateYawRate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t yawratevalue = 0,
    YawRateConfidence yawrateconfidence = YawRateConfidence_YRC_degSec_000_01) {
  YawRateBuilder builder_(_fbb);
  builder_.add_yawrateconfidence(yawrateconfidence);
  builder_.add_yawratevalue(yawratevalue);
  return builder_.Finish();
}

namespace Acceleration3dWithConfidence_ {

}  // namespace Acceleration3dWithConfidence_

namespace MapReference_ {

}  // namespace MapReference_

namespace ObjectClass_ {

}  // namespace ObjectClass_

namespace Shape_ {

}  // namespace Shape_

namespace Velocity3dWithConfidence_ {

}  // namespace Velocity3dWithConfidence_

namespace VruProfileAndSubprofile_ {

}  // namespace VruProfileAndSubprofile_

#endif  // FLATBUFFERS_GENERATED_ETSIITSCDD_H_
