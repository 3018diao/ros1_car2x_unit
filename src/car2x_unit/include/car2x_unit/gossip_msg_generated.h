// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GOSSIPMSG_GOSSIP_H_
#define FLATBUFFERS_GENERATED_GOSSIPMSG_GOSSIP_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

namespace Gossip {

struct GossipMessage;
struct GossipMessageBuilder;

struct ChannelBusyRatio;
struct ChannelBusyRatioBuilder;

struct LinkLayerReception;
struct LinkLayerReceptionBuilder;

struct CPMessage;
struct CPMessageBuilder;

struct ItsPduHeader;
struct ItsPduHeaderBuilder;

struct ManagementContainer;
struct ManagementContainerBuilder;

struct FacilityLayerReception;
struct FacilityLayerReceptionBuilder;

struct ReferencePosition;
struct ReferencePositionBuilder;

struct PerceivedObject;
struct PerceivedObjectBuilder;

struct CartesianPosition3dWithConfidence;
struct CartesianPosition3dWithConfidenceBuilder;

struct CartesianCoordinateWithConfidence;
struct CartesianCoordinateWithConfidenceBuilder;

struct Velocity3dWithConfidence;
struct Velocity3dWithConfidenceBuilder;

struct VelocityCartesian;
struct VelocityCartesianBuilder;

struct VelocityComponent;
struct VelocityComponentBuilder;

enum StationType : int32_t {
  StationType_STN_TYPE_UNKNOWN = 0,
  StationType_STN_TYPE_PEDESTRIAN = 1,
  StationType_STN_TYPE_CYCLIST = 2,
  StationType_STN_TYPE_MOPED = 3,
  StationType_STN_TYPE_MOTORCYCLE = 4,
  StationType_STN_TYPE_PASSENGER_CAR = 5,
  StationType_STN_TYPE_BUS = 6,
  StationType_STN_TYPE_LIGHT_TRUCK = 7,
  StationType_STN_TYPE_HEAVY_TRUCK = 8,
  StationType_STN_TYPE_TRAILER = 9,
  StationType_STN_TYPE_SPECIAL_VEHICLE = 10,
  StationType_STN_TYPE_TRAM = 11,
  StationType_STN_TYPE_ROAD_SIDE_UNIT = 15,
  StationType_MIN = StationType_STN_TYPE_UNKNOWN,
  StationType_MAX = StationType_STN_TYPE_ROAD_SIDE_UNIT
};

inline const StationType (&EnumValuesStationType())[13] {
  static const StationType values[] = {
    StationType_STN_TYPE_UNKNOWN,
    StationType_STN_TYPE_PEDESTRIAN,
    StationType_STN_TYPE_CYCLIST,
    StationType_STN_TYPE_MOPED,
    StationType_STN_TYPE_MOTORCYCLE,
    StationType_STN_TYPE_PASSENGER_CAR,
    StationType_STN_TYPE_BUS,
    StationType_STN_TYPE_LIGHT_TRUCK,
    StationType_STN_TYPE_HEAVY_TRUCK,
    StationType_STN_TYPE_TRAILER,
    StationType_STN_TYPE_SPECIAL_VEHICLE,
    StationType_STN_TYPE_TRAM,
    StationType_STN_TYPE_ROAD_SIDE_UNIT
  };
  return values;
}

inline const char * const *EnumNamesStationType() {
  static const char * const names[17] = {
    "STN_TYPE_UNKNOWN",
    "STN_TYPE_PEDESTRIAN",
    "STN_TYPE_CYCLIST",
    "STN_TYPE_MOPED",
    "STN_TYPE_MOTORCYCLE",
    "STN_TYPE_PASSENGER_CAR",
    "STN_TYPE_BUS",
    "STN_TYPE_LIGHT_TRUCK",
    "STN_TYPE_HEAVY_TRUCK",
    "STN_TYPE_TRAILER",
    "STN_TYPE_SPECIAL_VEHICLE",
    "STN_TYPE_TRAM",
    "",
    "",
    "",
    "STN_TYPE_ROAD_SIDE_UNIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameStationType(StationType e) {
  if (::flatbuffers::IsOutRange(e, StationType_STN_TYPE_UNKNOWN, StationType_STN_TYPE_ROAD_SIDE_UNIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStationType()[index];
}

enum FacilityLayerMessage : uint8_t {
  FacilityLayerMessage_NONE = 0,
  FacilityLayerMessage_CPMessage = 1,
  FacilityLayerMessage_MIN = FacilityLayerMessage_NONE,
  FacilityLayerMessage_MAX = FacilityLayerMessage_CPMessage
};

inline const FacilityLayerMessage (&EnumValuesFacilityLayerMessage())[2] {
  static const FacilityLayerMessage values[] = {
    FacilityLayerMessage_NONE,
    FacilityLayerMessage_CPMessage
  };
  return values;
}

inline const char * const *EnumNamesFacilityLayerMessage() {
  static const char * const names[3] = {
    "NONE",
    "CPMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameFacilityLayerMessage(FacilityLayerMessage e) {
  if (::flatbuffers::IsOutRange(e, FacilityLayerMessage_NONE, FacilityLayerMessage_CPMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFacilityLayerMessage()[index];
}

template<typename T> struct FacilityLayerMessageTraits {
  static const FacilityLayerMessage enum_value = FacilityLayerMessage_NONE;
};

template<> struct FacilityLayerMessageTraits<Gossip::CPMessage> {
  static const FacilityLayerMessage enum_value = FacilityLayerMessage_CPMessage;
};

bool VerifyFacilityLayerMessage(::flatbuffers::Verifier &verifier, const void *obj, FacilityLayerMessage type);
bool VerifyFacilityLayerMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum GossipType : uint8_t {
  GossipType_NONE = 0,
  GossipType_ChannelBusyRatio = 1,
  GossipType_LinkLayerReception = 2,
  GossipType_FacilityLayerReception = 3,
  GossipType_MIN = GossipType_NONE,
  GossipType_MAX = GossipType_FacilityLayerReception
};

inline const GossipType (&EnumValuesGossipType())[4] {
  static const GossipType values[] = {
    GossipType_NONE,
    GossipType_ChannelBusyRatio,
    GossipType_LinkLayerReception,
    GossipType_FacilityLayerReception
  };
  return values;
}

inline const char * const *EnumNamesGossipType() {
  static const char * const names[5] = {
    "NONE",
    "ChannelBusyRatio",
    "LinkLayerReception",
    "FacilityLayerReception",
    nullptr
  };
  return names;
}

inline const char *EnumNameGossipType(GossipType e) {
  if (::flatbuffers::IsOutRange(e, GossipType_NONE, GossipType_FacilityLayerReception)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGossipType()[index];
}

template<typename T> struct GossipTypeTraits {
  static const GossipType enum_value = GossipType_NONE;
};

template<> struct GossipTypeTraits<Gossip::ChannelBusyRatio> {
  static const GossipType enum_value = GossipType_ChannelBusyRatio;
};

template<> struct GossipTypeTraits<Gossip::LinkLayerReception> {
  static const GossipType enum_value = GossipType_LinkLayerReception;
};

template<> struct GossipTypeTraits<Gossip::FacilityLayerReception> {
  static const GossipType enum_value = GossipType_FacilityLayerReception;
};

bool VerifyGossipType(::flatbuffers::Verifier &verifier, const void *obj, GossipType type);
bool VerifyGossipTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct GossipMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GossipMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GOSSIP_TYPE = 4,
    VT_GOSSIP = 6
  };
  Gossip::GossipType gossip_type() const {
    return static_cast<Gossip::GossipType>(GetField<uint8_t>(VT_GOSSIP_TYPE, 0));
  }
  const void *gossip() const {
    return GetPointer<const void *>(VT_GOSSIP);
  }
  template<typename T> const T *gossip_as() const;
  const Gossip::ChannelBusyRatio *gossip_as_ChannelBusyRatio() const {
    return gossip_type() == Gossip::GossipType_ChannelBusyRatio ? static_cast<const Gossip::ChannelBusyRatio *>(gossip()) : nullptr;
  }
  const Gossip::LinkLayerReception *gossip_as_LinkLayerReception() const {
    return gossip_type() == Gossip::GossipType_LinkLayerReception ? static_cast<const Gossip::LinkLayerReception *>(gossip()) : nullptr;
  }
  const Gossip::FacilityLayerReception *gossip_as_FacilityLayerReception() const {
    return gossip_type() == Gossip::GossipType_FacilityLayerReception ? static_cast<const Gossip::FacilityLayerReception *>(gossip()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GOSSIP_TYPE, 1) &&
           VerifyOffset(verifier, VT_GOSSIP) &&
           VerifyGossipType(verifier, gossip(), gossip_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Gossip::ChannelBusyRatio *GossipMessage::gossip_as<Gossip::ChannelBusyRatio>() const {
  return gossip_as_ChannelBusyRatio();
}

template<> inline const Gossip::LinkLayerReception *GossipMessage::gossip_as<Gossip::LinkLayerReception>() const {
  return gossip_as_LinkLayerReception();
}

template<> inline const Gossip::FacilityLayerReception *GossipMessage::gossip_as<Gossip::FacilityLayerReception>() const {
  return gossip_as_FacilityLayerReception();
}

struct GossipMessageBuilder {
  typedef GossipMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gossip_type(Gossip::GossipType gossip_type) {
    fbb_.AddElement<uint8_t>(GossipMessage::VT_GOSSIP_TYPE, static_cast<uint8_t>(gossip_type), 0);
  }
  void add_gossip(::flatbuffers::Offset<void> gossip) {
    fbb_.AddOffset(GossipMessage::VT_GOSSIP, gossip);
  }
  explicit GossipMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GossipMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GossipMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GossipMessage> CreateGossipMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gossip::GossipType gossip_type = Gossip::GossipType_NONE,
    ::flatbuffers::Offset<void> gossip = 0) {
  GossipMessageBuilder builder_(_fbb);
  builder_.add_gossip(gossip);
  builder_.add_gossip_type(gossip_type);
  return builder_.Finish();
}

struct ChannelBusyRatio FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChannelBusyRatioBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUSY = 4,
    VT_TOTAL = 6
  };
  uint32_t busy() const {
    return GetField<uint32_t>(VT_BUSY, 0);
  }
  uint32_t total() const {
    return GetField<uint32_t>(VT_TOTAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BUSY, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL, 4) &&
           verifier.EndTable();
  }
};

struct ChannelBusyRatioBuilder {
  typedef ChannelBusyRatio Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_busy(uint32_t busy) {
    fbb_.AddElement<uint32_t>(ChannelBusyRatio::VT_BUSY, busy, 0);
  }
  void add_total(uint32_t total) {
    fbb_.AddElement<uint32_t>(ChannelBusyRatio::VT_TOTAL, total, 0);
  }
  explicit ChannelBusyRatioBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChannelBusyRatio> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChannelBusyRatio>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChannelBusyRatio> CreateChannelBusyRatio(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t busy = 0,
    uint32_t total = 0) {
  ChannelBusyRatioBuilder builder_(_fbb);
  builder_.add_total(total);
  builder_.add_busy(busy);
  return builder_.Finish();
}

struct LinkLayerReception FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinkLayerReceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_DESTINATION = 6,
    VT_CHANNEL = 8,
    VT_POWER_CBM = 10,
    VT_PAYLOAD = 12
  };
  const ::flatbuffers::Vector<uint8_t> *source() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SOURCE);
  }
  const ::flatbuffers::Vector<uint8_t> *destination() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DESTINATION);
  }
  uint32_t channel() const {
    return GetField<uint32_t>(VT_CHANNEL, 0);
  }
  int32_t power_cbm() const {
    return GetField<int32_t>(VT_POWER_CBM, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           verifier.VerifyVector(source()) &&
           VerifyOffsetRequired(verifier, VT_DESTINATION) &&
           verifier.VerifyVector(destination()) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL, 4) &&
           VerifyField<int32_t>(verifier, VT_POWER_CBM, 4) &&
           VerifyOffsetRequired(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct LinkLayerReceptionBuilder {
  typedef LinkLayerReception Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source) {
    fbb_.AddOffset(LinkLayerReception::VT_SOURCE, source);
  }
  void add_destination(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination) {
    fbb_.AddOffset(LinkLayerReception::VT_DESTINATION, destination);
  }
  void add_channel(uint32_t channel) {
    fbb_.AddElement<uint32_t>(LinkLayerReception::VT_CHANNEL, channel, 0);
  }
  void add_power_cbm(int32_t power_cbm) {
    fbb_.AddElement<int32_t>(LinkLayerReception::VT_POWER_CBM, power_cbm, 0);
  }
  void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(LinkLayerReception::VT_PAYLOAD, payload);
  }
  explicit LinkLayerReceptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinkLayerReception> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinkLayerReception>(end);
    fbb_.Required(o, LinkLayerReception::VT_SOURCE);
    fbb_.Required(o, LinkLayerReception::VT_DESTINATION);
    fbb_.Required(o, LinkLayerReception::VT_PAYLOAD);
    return o;
  }
};

inline ::flatbuffers::Offset<LinkLayerReception> CreateLinkLayerReception(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination = 0,
    uint32_t channel = 0,
    int32_t power_cbm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
  LinkLayerReceptionBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_power_cbm(power_cbm);
  builder_.add_channel(channel);
  builder_.add_destination(destination);
  builder_.add_source(source);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LinkLayerReception> CreateLinkLayerReceptionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *source = nullptr,
    const std::vector<uint8_t> *destination = nullptr,
    uint32_t channel = 0,
    int32_t power_cbm = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  auto source__ = source ? _fbb.CreateVector<uint8_t>(*source) : 0;
  auto destination__ = destination ? _fbb.CreateVector<uint8_t>(*destination) : 0;
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return Gossip::CreateLinkLayerReception(
      _fbb,
      source__,
      destination__,
      channel,
      power_cbm,
      payload__);
}

struct CPMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CPMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_GENERATION_DELTA_TIME = 6
  };
  const Gossip::ItsPduHeader *header() const {
    return GetPointer<const Gossip::ItsPduHeader *>(VT_HEADER);
  }
  uint64_t generation_delta_time() const {
    return GetField<uint64_t>(VT_GENERATION_DELTA_TIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint64_t>(verifier, VT_GENERATION_DELTA_TIME, 8) &&
           verifier.EndTable();
  }
};

struct CPMessageBuilder {
  typedef CPMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<Gossip::ItsPduHeader> header) {
    fbb_.AddOffset(CPMessage::VT_HEADER, header);
  }
  void add_generation_delta_time(uint64_t generation_delta_time) {
    fbb_.AddElement<uint64_t>(CPMessage::VT_GENERATION_DELTA_TIME, generation_delta_time, 0);
  }
  explicit CPMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CPMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CPMessage>(end);
    fbb_.Required(o, CPMessage::VT_HEADER);
    return o;
  }
};

inline ::flatbuffers::Offset<CPMessage> CreateCPMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gossip::ItsPduHeader> header = 0,
    uint64_t generation_delta_time = 0) {
  CPMessageBuilder builder_(_fbb);
  builder_.add_generation_delta_time(generation_delta_time);
  builder_.add_header(header);
  return builder_.Finish();
}

struct ItsPduHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItsPduHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_MESSAGE_ID = 6,
    VT_STATION_ID = 8
  };
  uint32_t protocol_version() const {
    return GetField<uint32_t>(VT_PROTOCOL_VERSION, 0);
  }
  uint32_t message_id() const {
    return GetField<uint32_t>(VT_MESSAGE_ID, 0);
  }
  uint32_t station_id() const {
    return GetField<uint32_t>(VT_STATION_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROTOCOL_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_STATION_ID, 4) &&
           verifier.EndTable();
  }
};

struct ItsPduHeaderBuilder {
  typedef ItsPduHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol_version(uint32_t protocol_version) {
    fbb_.AddElement<uint32_t>(ItsPduHeader::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_message_id(uint32_t message_id) {
    fbb_.AddElement<uint32_t>(ItsPduHeader::VT_MESSAGE_ID, message_id, 0);
  }
  void add_station_id(uint32_t station_id) {
    fbb_.AddElement<uint32_t>(ItsPduHeader::VT_STATION_ID, station_id, 0);
  }
  explicit ItsPduHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ItsPduHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ItsPduHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ItsPduHeader> CreateItsPduHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_version = 0,
    uint32_t message_id = 0,
    uint32_t station_id = 0) {
  ItsPduHeaderBuilder builder_(_fbb);
  builder_.add_station_id(station_id);
  builder_.add_message_id(message_id);
  builder_.add_protocol_version(protocol_version);
  return builder_.Finish();
}

struct ManagementContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ManagementContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_TIME = 4,
    VT_REFERENCE_POSITION = 6,
    VT_STATION_TYPE = 8
  };
  uint64_t reference_time() const {
    return GetField<uint64_t>(VT_REFERENCE_TIME, 0);
  }
  const Gossip::ReferencePosition *reference_position() const {
    return GetPointer<const Gossip::ReferencePosition *>(VT_REFERENCE_POSITION);
  }
  Gossip::StationType station_type() const {
    return static_cast<Gossip::StationType>(GetField<int32_t>(VT_STATION_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REFERENCE_TIME, 8) &&
           VerifyOffsetRequired(verifier, VT_REFERENCE_POSITION) &&
           verifier.VerifyTable(reference_position()) &&
           VerifyField<int32_t>(verifier, VT_STATION_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct ManagementContainerBuilder {
  typedef ManagementContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reference_time(uint64_t reference_time) {
    fbb_.AddElement<uint64_t>(ManagementContainer::VT_REFERENCE_TIME, reference_time, 0);
  }
  void add_reference_position(::flatbuffers::Offset<Gossip::ReferencePosition> reference_position) {
    fbb_.AddOffset(ManagementContainer::VT_REFERENCE_POSITION, reference_position);
  }
  void add_station_type(Gossip::StationType station_type) {
    fbb_.AddElement<int32_t>(ManagementContainer::VT_STATION_TYPE, static_cast<int32_t>(station_type), 0);
  }
  explicit ManagementContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ManagementContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ManagementContainer>(end);
    fbb_.Required(o, ManagementContainer::VT_REFERENCE_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<ManagementContainer> CreateManagementContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t reference_time = 0,
    ::flatbuffers::Offset<Gossip::ReferencePosition> reference_position = 0,
    Gossip::StationType station_type = Gossip::StationType_STN_TYPE_UNKNOWN) {
  ManagementContainerBuilder builder_(_fbb);
  builder_.add_reference_time(reference_time);
  builder_.add_station_type(station_type);
  builder_.add_reference_position(reference_position);
  return builder_.Finish();
}

struct FacilityLayerReception FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FacilityLayerReceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  Gossip::FacilityLayerMessage msg_type() const {
    return static_cast<Gossip::FacilityLayerMessage>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const Gossip::CPMessage *msg_as_CPMessage() const {
    return msg_type() == Gossip::FacilityLayerMessage_CPMessage ? static_cast<const Gossip::CPMessage *>(msg()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyFacilityLayerMessage(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Gossip::CPMessage *FacilityLayerReception::msg_as<Gossip::CPMessage>() const {
  return msg_as_CPMessage();
}

struct FacilityLayerReceptionBuilder {
  typedef FacilityLayerReception Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_type(Gossip::FacilityLayerMessage msg_type) {
    fbb_.AddElement<uint8_t>(FacilityLayerReception::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(::flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(FacilityLayerReception::VT_MSG, msg);
  }
  explicit FacilityLayerReceptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FacilityLayerReception> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FacilityLayerReception>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FacilityLayerReception> CreateFacilityLayerReception(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gossip::FacilityLayerMessage msg_type = Gossip::FacilityLayerMessage_NONE,
    ::flatbuffers::Offset<void> msg = 0) {
  FacilityLayerReceptionBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

struct ReferencePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReferencePositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATITUDE = 4,
    VT_LONGITUDE = 6
  };
  int64_t latitude() const {
    return GetField<int64_t>(VT_LATITUDE, 0);
  }
  int64_t longitude() const {
    return GetField<int64_t>(VT_LONGITUDE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LATITUDE, 8) &&
           VerifyField<int64_t>(verifier, VT_LONGITUDE, 8) &&
           verifier.EndTable();
  }
};

struct ReferencePositionBuilder {
  typedef ReferencePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_latitude(int64_t latitude) {
    fbb_.AddElement<int64_t>(ReferencePosition::VT_LATITUDE, latitude, 0);
  }
  void add_longitude(int64_t longitude) {
    fbb_.AddElement<int64_t>(ReferencePosition::VT_LONGITUDE, longitude, 0);
  }
  explicit ReferencePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReferencePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReferencePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReferencePosition> CreateReferencePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t latitude = 0,
    int64_t longitude = 0) {
  ReferencePositionBuilder builder_(_fbb);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  return builder_.Finish();
}

struct PerceivedObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceivedObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_ID = 4,
    VT_MEASUREMENT_DELTA_TIME = 6,
    VT_POSITION = 8,
    VT_VELOCITY = 10,
    VT_OBJECT_AGE = 12,
    VT_OBJECT_PERCEPTION_QUALITY = 14,
    VT_SENSOR_ID_LIST = 16
  };
  uint32_t object_id() const {
    return GetField<uint32_t>(VT_OBJECT_ID, 0);
  }
  int32_t measurement_delta_time() const {
    return GetField<int32_t>(VT_MEASUREMENT_DELTA_TIME, 0);
  }
  const Gossip::CartesianPosition3dWithConfidence *position() const {
    return GetPointer<const Gossip::CartesianPosition3dWithConfidence *>(VT_POSITION);
  }
  const Gossip::Velocity3dWithConfidence *velocity() const {
    return GetPointer<const Gossip::Velocity3dWithConfidence *>(VT_VELOCITY);
  }
  uint32_t object_age() const {
    return GetField<uint32_t>(VT_OBJECT_AGE, 0);
  }
  uint32_t object_perception_quality() const {
    return GetField<uint32_t>(VT_OBJECT_PERCEPTION_QUALITY, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *sensor_id_list() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_SENSOR_ID_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_MEASUREMENT_DELTA_TIME, 4) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyTable(velocity()) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_AGE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_PERCEPTION_QUALITY, 4) &&
           VerifyOffset(verifier, VT_SENSOR_ID_LIST) &&
           verifier.VerifyVector(sensor_id_list()) &&
           verifier.EndTable();
  }
};

struct PerceivedObjectBuilder {
  typedef PerceivedObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_object_id(uint32_t object_id) {
    fbb_.AddElement<uint32_t>(PerceivedObject::VT_OBJECT_ID, object_id, 0);
  }
  void add_measurement_delta_time(int32_t measurement_delta_time) {
    fbb_.AddElement<int32_t>(PerceivedObject::VT_MEASUREMENT_DELTA_TIME, measurement_delta_time, 0);
  }
  void add_position(::flatbuffers::Offset<Gossip::CartesianPosition3dWithConfidence> position) {
    fbb_.AddOffset(PerceivedObject::VT_POSITION, position);
  }
  void add_velocity(::flatbuffers::Offset<Gossip::Velocity3dWithConfidence> velocity) {
    fbb_.AddOffset(PerceivedObject::VT_VELOCITY, velocity);
  }
  void add_object_age(uint32_t object_age) {
    fbb_.AddElement<uint32_t>(PerceivedObject::VT_OBJECT_AGE, object_age, 0);
  }
  void add_object_perception_quality(uint32_t object_perception_quality) {
    fbb_.AddElement<uint32_t>(PerceivedObject::VT_OBJECT_PERCEPTION_QUALITY, object_perception_quality, 0);
  }
  void add_sensor_id_list(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> sensor_id_list) {
    fbb_.AddOffset(PerceivedObject::VT_SENSOR_ID_LIST, sensor_id_list);
  }
  explicit PerceivedObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceivedObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceivedObject>(end);
    fbb_.Required(o, PerceivedObject::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceivedObject> CreatePerceivedObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t object_id = 0,
    int32_t measurement_delta_time = 0,
    ::flatbuffers::Offset<Gossip::CartesianPosition3dWithConfidence> position = 0,
    ::flatbuffers::Offset<Gossip::Velocity3dWithConfidence> velocity = 0,
    uint32_t object_age = 0,
    uint32_t object_perception_quality = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> sensor_id_list = 0) {
  PerceivedObjectBuilder builder_(_fbb);
  builder_.add_sensor_id_list(sensor_id_list);
  builder_.add_object_perception_quality(object_perception_quality);
  builder_.add_object_age(object_age);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  builder_.add_measurement_delta_time(measurement_delta_time);
  builder_.add_object_id(object_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceivedObject> CreatePerceivedObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t object_id = 0,
    int32_t measurement_delta_time = 0,
    ::flatbuffers::Offset<Gossip::CartesianPosition3dWithConfidence> position = 0,
    ::flatbuffers::Offset<Gossip::Velocity3dWithConfidence> velocity = 0,
    uint32_t object_age = 0,
    uint32_t object_perception_quality = 0,
    const std::vector<uint32_t> *sensor_id_list = nullptr) {
  auto sensor_id_list__ = sensor_id_list ? _fbb.CreateVector<uint32_t>(*sensor_id_list) : 0;
  return Gossip::CreatePerceivedObject(
      _fbb,
      object_id,
      measurement_delta_time,
      position,
      velocity,
      object_age,
      object_perception_quality,
      sensor_id_list__);
}

struct CartesianPosition3dWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianPosition3dWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_CORD = 4,
    VT_Y_CORD = 6,
    VT_Z_CORD = 8
  };
  const Gossip::CartesianCoordinateWithConfidence *x_cord() const {
    return GetPointer<const Gossip::CartesianCoordinateWithConfidence *>(VT_X_CORD);
  }
  const Gossip::CartesianCoordinateWithConfidence *y_cord() const {
    return GetPointer<const Gossip::CartesianCoordinateWithConfidence *>(VT_Y_CORD);
  }
  const Gossip::CartesianCoordinateWithConfidence *z_cord() const {
    return GetPointer<const Gossip::CartesianCoordinateWithConfidence *>(VT_Z_CORD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_X_CORD) &&
           verifier.VerifyTable(x_cord()) &&
           VerifyOffsetRequired(verifier, VT_Y_CORD) &&
           verifier.VerifyTable(y_cord()) &&
           VerifyOffset(verifier, VT_Z_CORD) &&
           verifier.VerifyTable(z_cord()) &&
           verifier.EndTable();
  }
};

struct CartesianPosition3dWithConfidenceBuilder {
  typedef CartesianPosition3dWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_cord(::flatbuffers::Offset<Gossip::CartesianCoordinateWithConfidence> x_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_X_CORD, x_cord);
  }
  void add_y_cord(::flatbuffers::Offset<Gossip::CartesianCoordinateWithConfidence> y_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_Y_CORD, y_cord);
  }
  void add_z_cord(::flatbuffers::Offset<Gossip::CartesianCoordinateWithConfidence> z_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_Z_CORD, z_cord);
  }
  explicit CartesianPosition3dWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianPosition3dWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianPosition3dWithConfidence>(end);
    fbb_.Required(o, CartesianPosition3dWithConfidence::VT_X_CORD);
    fbb_.Required(o, CartesianPosition3dWithConfidence::VT_Y_CORD);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianPosition3dWithConfidence> CreateCartesianPosition3dWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gossip::CartesianCoordinateWithConfidence> x_cord = 0,
    ::flatbuffers::Offset<Gossip::CartesianCoordinateWithConfidence> y_cord = 0,
    ::flatbuffers::Offset<Gossip::CartesianCoordinateWithConfidence> z_cord = 0) {
  CartesianPosition3dWithConfidenceBuilder builder_(_fbb);
  builder_.add_z_cord(z_cord);
  builder_.add_y_cord(y_cord);
  builder_.add_x_cord(x_cord);
  return builder_.Finish();
}

struct CartesianCoordinateWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianCoordinateWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct CartesianCoordinateWithConfidenceBuilder {
  typedef CartesianCoordinateWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CartesianCoordinateWithConfidence::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(CartesianCoordinateWithConfidence::VT_CONFIDENCE, confidence, 0);
  }
  explicit CartesianCoordinateWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianCoordinateWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianCoordinateWithConfidence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianCoordinateWithConfidence> CreateCartesianCoordinateWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  CartesianCoordinateWithConfidenceBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Velocity3dWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Velocity3dWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CARTESIAN_VELOCITY = 4
  };
  const Gossip::VelocityCartesian *cartesian_velocity() const {
    return GetPointer<const Gossip::VelocityCartesian *>(VT_CARTESIAN_VELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CARTESIAN_VELOCITY) &&
           verifier.VerifyTable(cartesian_velocity()) &&
           verifier.EndTable();
  }
};

struct Velocity3dWithConfidenceBuilder {
  typedef Velocity3dWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cartesian_velocity(::flatbuffers::Offset<Gossip::VelocityCartesian> cartesian_velocity) {
    fbb_.AddOffset(Velocity3dWithConfidence::VT_CARTESIAN_VELOCITY, cartesian_velocity);
  }
  explicit Velocity3dWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Velocity3dWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Velocity3dWithConfidence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Velocity3dWithConfidence> CreateVelocity3dWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gossip::VelocityCartesian> cartesian_velocity = 0) {
  Velocity3dWithConfidenceBuilder builder_(_fbb);
  builder_.add_cartesian_velocity(cartesian_velocity);
  return builder_.Finish();
}

struct VelocityCartesian FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityCartesianBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_VELOCITY = 4,
    VT_Y_VELOCITY = 6,
    VT_Z_VELOCITY = 8
  };
  const Gossip::VelocityComponent *x_velocity() const {
    return GetPointer<const Gossip::VelocityComponent *>(VT_X_VELOCITY);
  }
  const Gossip::VelocityComponent *y_velocity() const {
    return GetPointer<const Gossip::VelocityComponent *>(VT_Y_VELOCITY);
  }
  const Gossip::VelocityComponent *z_velocity() const {
    return GetPointer<const Gossip::VelocityComponent *>(VT_Z_VELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_X_VELOCITY) &&
           verifier.VerifyTable(x_velocity()) &&
           VerifyOffsetRequired(verifier, VT_Y_VELOCITY) &&
           verifier.VerifyTable(y_velocity()) &&
           VerifyOffset(verifier, VT_Z_VELOCITY) &&
           verifier.VerifyTable(z_velocity()) &&
           verifier.EndTable();
  }
};

struct VelocityCartesianBuilder {
  typedef VelocityCartesian Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_velocity(::flatbuffers::Offset<Gossip::VelocityComponent> x_velocity) {
    fbb_.AddOffset(VelocityCartesian::VT_X_VELOCITY, x_velocity);
  }
  void add_y_velocity(::flatbuffers::Offset<Gossip::VelocityComponent> y_velocity) {
    fbb_.AddOffset(VelocityCartesian::VT_Y_VELOCITY, y_velocity);
  }
  void add_z_velocity(::flatbuffers::Offset<Gossip::VelocityComponent> z_velocity) {
    fbb_.AddOffset(VelocityCartesian::VT_Z_VELOCITY, z_velocity);
  }
  explicit VelocityCartesianBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityCartesian> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityCartesian>(end);
    fbb_.Required(o, VelocityCartesian::VT_X_VELOCITY);
    fbb_.Required(o, VelocityCartesian::VT_Y_VELOCITY);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityCartesian> CreateVelocityCartesian(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gossip::VelocityComponent> x_velocity = 0,
    ::flatbuffers::Offset<Gossip::VelocityComponent> y_velocity = 0,
    ::flatbuffers::Offset<Gossip::VelocityComponent> z_velocity = 0) {
  VelocityCartesianBuilder builder_(_fbb);
  builder_.add_z_velocity(z_velocity);
  builder_.add_y_velocity(y_velocity);
  builder_.add_x_velocity(x_velocity);
  return builder_.Finish();
}

struct VelocityComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEL_COMP_VALUE = 4,
    VT_SPEED_CONFIDENCE = 6
  };
  int32_t vel_comp_value() const {
    return GetField<int32_t>(VT_VEL_COMP_VALUE, 0);
  }
  uint32_t speed_confidence() const {
    return GetField<uint32_t>(VT_SPEED_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VEL_COMP_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SPEED_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct VelocityComponentBuilder {
  typedef VelocityComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vel_comp_value(int32_t vel_comp_value) {
    fbb_.AddElement<int32_t>(VelocityComponent::VT_VEL_COMP_VALUE, vel_comp_value, 0);
  }
  void add_speed_confidence(uint32_t speed_confidence) {
    fbb_.AddElement<uint32_t>(VelocityComponent::VT_SPEED_CONFIDENCE, speed_confidence, 0);
  }
  explicit VelocityComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityComponent> CreateVelocityComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t vel_comp_value = 0,
    uint32_t speed_confidence = 0) {
  VelocityComponentBuilder builder_(_fbb);
  builder_.add_speed_confidence(speed_confidence);
  builder_.add_vel_comp_value(vel_comp_value);
  return builder_.Finish();
}

inline bool VerifyFacilityLayerMessage(::flatbuffers::Verifier &verifier, const void *obj, FacilityLayerMessage type) {
  switch (type) {
    case FacilityLayerMessage_NONE: {
      return true;
    }
    case FacilityLayerMessage_CPMessage: {
      auto ptr = reinterpret_cast<const Gossip::CPMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFacilityLayerMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFacilityLayerMessage(
        verifier,  values->Get(i), types->GetEnum<FacilityLayerMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGossipType(::flatbuffers::Verifier &verifier, const void *obj, GossipType type) {
  switch (type) {
    case GossipType_NONE: {
      return true;
    }
    case GossipType_ChannelBusyRatio: {
      auto ptr = reinterpret_cast<const Gossip::ChannelBusyRatio *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GossipType_LinkLayerReception: {
      auto ptr = reinterpret_cast<const Gossip::LinkLayerReception *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GossipType_FacilityLayerReception: {
      auto ptr = reinterpret_cast<const Gossip::FacilityLayerReception *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGossipTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGossipType(
        verifier,  values->Get(i), types->GetEnum<GossipType>(i))) {
      return false;
    }
  }
  return true;
}

inline const Gossip::GossipMessage *GetGossipMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Gossip::GossipMessage>(buf);
}

inline const Gossip::GossipMessage *GetSizePrefixedGossipMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Gossip::GossipMessage>(buf);
}

inline bool VerifyGossipMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Gossip::GossipMessage>(nullptr);
}

inline bool VerifySizePrefixedGossipMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Gossip::GossipMessage>(nullptr);
}

inline void FinishGossipMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Gossip::GossipMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGossipMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Gossip::GossipMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Gossip

#endif  // FLATBUFFERS_GENERATED_GOSSIPMSG_GOSSIP_H_
