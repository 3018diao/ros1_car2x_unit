// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ETSIMSGINTERFACE_GOSSIPMESSAGE__H_
#define FLATBUFFERS_GENERATED_ETSIMSGINTERFACE_GOSSIPMESSAGE__H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

#include "cam_interface_generated.h"
#include "cpm_interface_generated.h"
#include "etsi_its_cdd_generated.h"
#include "itspduheader_interface_generated.h"

struct CommandRequest;
struct CommandRequestBuilder;

namespace CommandRequest_ {

struct Anonymous6;
struct Anonymous6Builder;

}  // namespace CommandRequest_

struct CommandResponse;
struct CommandResponseBuilder;

struct CommandResponseData;
struct CommandResponseDataBuilder;

namespace CommandResponseData_ {

struct Anonymous7;
struct Anonymous7Builder;

}  // namespace CommandResponseData_

struct RadioConfiguration;
struct RadioConfigurationBuilder;

struct LinkLayerTransmission;
struct LinkLayerTransmissionBuilder;

struct LinkLayerReception;
struct LinkLayerReceptionBuilder;

struct FacilityLayerTransmission;
struct FacilityLayerTransmissionBuilder;

struct FacilityLayerReception;
struct FacilityLayerReceptionBuilder;

struct FacilityLayerMessage;
struct FacilityLayerMessageBuilder;

namespace FacilityLayerMessage_ {

struct Anonymous8;
struct Anonymous8Builder;

}  // namespace FacilityLayerMessage_

struct ChannelBusyRatio;
struct ChannelBusyRatioBuilder;

struct GossipMessage;
struct GossipMessageBuilder;

namespace GossipMessage_ {

struct Anonymous9;
struct Anonymous9Builder;

}  // namespace GossipMessage_

namespace CommandResponse_ {

enum Status : int32_t {
  Status_SUCCESS = 0,
  Status_FAILURE = 1,
  Status_UNKNOWN = 2,
  Status_NOT_IMPLEMENTED = 3,
  Status_MIN = Status_SUCCESS,
  Status_MAX = Status_NOT_IMPLEMENTED
};

inline const Status (&EnumValuesStatus())[4] {
  static const Status values[] = {
    Status_SUCCESS,
    Status_FAILURE,
    Status_UNKNOWN,
    Status_NOT_IMPLEMENTED
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[5] = {
    "SUCCESS",
    "FAILURE",
    "UNKNOWN",
    "NOT_IMPLEMENTED",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (::flatbuffers::IsOutRange(e, Status_SUCCESS, Status_NOT_IMPLEMENTED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

}  // namespace CommandResponse_

enum LifecycleAction : int32_t {
  LifecycleAction_SOFT_RESET = 0,
  LifecycleAction_HARD_RESET = 1,
  LifecycleAction_MIN = LifecycleAction_SOFT_RESET,
  LifecycleAction_MAX = LifecycleAction_HARD_RESET
};

inline const LifecycleAction (&EnumValuesLifecycleAction())[2] {
  static const LifecycleAction values[] = {
    LifecycleAction_SOFT_RESET,
    LifecycleAction_HARD_RESET
  };
  return values;
}

inline const char * const *EnumNamesLifecycleAction() {
  static const char * const names[3] = {
    "SOFT_RESET",
    "HARD_RESET",
    nullptr
  };
  return names;
}

inline const char *EnumNameLifecycleAction(LifecycleAction e) {
  if (::flatbuffers::IsOutRange(e, LifecycleAction_SOFT_RESET, LifecycleAction_HARD_RESET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLifecycleAction()[index];
}

enum LinkLayerPriority : int32_t {
  LinkLayerPriority_BACKGROUND = 0,
  LinkLayerPriority_BEST_EFFORT = 1,
  LinkLayerPriority_VIDEO = 2,
  LinkLayerPriority_VOICE = 3,
  LinkLayerPriority_MIN = LinkLayerPriority_BACKGROUND,
  LinkLayerPriority_MAX = LinkLayerPriority_VOICE
};

inline const LinkLayerPriority (&EnumValuesLinkLayerPriority())[4] {
  static const LinkLayerPriority values[] = {
    LinkLayerPriority_BACKGROUND,
    LinkLayerPriority_BEST_EFFORT,
    LinkLayerPriority_VIDEO,
    LinkLayerPriority_VOICE
  };
  return values;
}

inline const char * const *EnumNamesLinkLayerPriority() {
  static const char * const names[5] = {
    "BACKGROUND",
    "BEST_EFFORT",
    "VIDEO",
    "VOICE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLinkLayerPriority(LinkLayerPriority e) {
  if (::flatbuffers::IsOutRange(e, LinkLayerPriority_BACKGROUND, LinkLayerPriority_VOICE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLinkLayerPriority()[index];
}

struct CommandRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4
  };
  const CommandRequest_::Anonymous6 *kind() const {
    return GetPointer<const CommandRequest_::Anonymous6 *>(VT_KIND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KIND) &&
           verifier.VerifyTable(kind()) &&
           verifier.EndTable();
  }
};

struct CommandRequestBuilder {
  typedef CommandRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kind(::flatbuffers::Offset<CommandRequest_::Anonymous6> kind) {
    fbb_.AddOffset(CommandRequest::VT_KIND, kind);
  }
  explicit CommandRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandRequest> CreateCommandRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CommandRequest_::Anonymous6> kind = 0) {
  CommandRequestBuilder builder_(_fbb);
  builder_.add_kind(kind);
  return builder_.Finish();
}

namespace CommandRequest_ {

struct Anonymous6 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous6Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIFECYCLE = 4,
    VT_LINKLAYER_TX = 6,
    VT_RADIO_CFG = 8,
    VT_FACILITIESLAYER_TX = 10
  };
  LifecycleAction lifecycle() const {
    return static_cast<LifecycleAction>(GetField<int32_t>(VT_LIFECYCLE, 0));
  }
  const LinkLayerTransmission *linklayer_tx() const {
    return GetPointer<const LinkLayerTransmission *>(VT_LINKLAYER_TX);
  }
  const RadioConfiguration *radio_cfg() const {
    return GetPointer<const RadioConfiguration *>(VT_RADIO_CFG);
  }
  const FacilityLayerTransmission *facilitieslayer_tx() const {
    return GetPointer<const FacilityLayerTransmission *>(VT_FACILITIESLAYER_TX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LIFECYCLE, 4) &&
           VerifyOffset(verifier, VT_LINKLAYER_TX) &&
           verifier.VerifyTable(linklayer_tx()) &&
           VerifyOffset(verifier, VT_RADIO_CFG) &&
           verifier.VerifyTable(radio_cfg()) &&
           VerifyOffset(verifier, VT_FACILITIESLAYER_TX) &&
           verifier.VerifyTable(facilitieslayer_tx()) &&
           verifier.EndTable();
  }
};

struct Anonymous6Builder {
  typedef Anonymous6 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lifecycle(LifecycleAction lifecycle) {
    fbb_.AddElement<int32_t>(Anonymous6::VT_LIFECYCLE, static_cast<int32_t>(lifecycle), 0);
  }
  void add_linklayer_tx(::flatbuffers::Offset<LinkLayerTransmission> linklayer_tx) {
    fbb_.AddOffset(Anonymous6::VT_LINKLAYER_TX, linklayer_tx);
  }
  void add_radio_cfg(::flatbuffers::Offset<RadioConfiguration> radio_cfg) {
    fbb_.AddOffset(Anonymous6::VT_RADIO_CFG, radio_cfg);
  }
  void add_facilitieslayer_tx(::flatbuffers::Offset<FacilityLayerTransmission> facilitieslayer_tx) {
    fbb_.AddOffset(Anonymous6::VT_FACILITIESLAYER_TX, facilitieslayer_tx);
  }
  explicit Anonymous6Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous6> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous6>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous6> CreateAnonymous6(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LifecycleAction lifecycle = LifecycleAction_SOFT_RESET,
    ::flatbuffers::Offset<LinkLayerTransmission> linklayer_tx = 0,
    ::flatbuffers::Offset<RadioConfiguration> radio_cfg = 0,
    ::flatbuffers::Offset<FacilityLayerTransmission> facilitieslayer_tx = 0) {
  Anonymous6Builder builder_(_fbb);
  builder_.add_facilitieslayer_tx(facilitieslayer_tx);
  builder_.add_radio_cfg(radio_cfg);
  builder_.add_linklayer_tx(linklayer_tx);
  builder_.add_lifecycle(lifecycle);
  return builder_.Finish();
}

}  // namespace CommandRequest_

struct CommandResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_MESSAGE = 6,
    VT_DATA = 8
  };
  CommandResponse_::Status status() const {
    return static_cast<CommandResponse_::Status>(GetField<int32_t>(VT_STATUS, 0));
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  const CommandResponseData *data() const {
    return GetPointer<const CommandResponseData *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct CommandResponseBuilder {
  typedef CommandResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(CommandResponse_::Status status) {
    fbb_.AddElement<int32_t>(CommandResponse::VT_STATUS, static_cast<int32_t>(status), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(CommandResponse::VT_MESSAGE, message);
  }
  void add_data(::flatbuffers::Offset<CommandResponseData> data) {
    fbb_.AddOffset(CommandResponse::VT_DATA, data);
  }
  explicit CommandResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandResponse> CreateCommandResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    CommandResponse_::Status status = CommandResponse_::Status_SUCCESS,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    ::flatbuffers::Offset<CommandResponseData> data = 0) {
  CommandResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CommandResponse> CreateCommandResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    CommandResponse_::Status status = CommandResponse_::Status_SUCCESS,
    const char *message = nullptr,
    ::flatbuffers::Offset<CommandResponseData> data = 0) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return CreateCommandResponse(
      _fbb,
      status,
      message__,
      data);
}

struct CommandResponseData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandResponseDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4
  };
  const CommandResponseData_::Anonymous7 *kind() const {
    return GetPointer<const CommandResponseData_::Anonymous7 *>(VT_KIND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KIND) &&
           verifier.VerifyTable(kind()) &&
           verifier.EndTable();
  }
};

struct CommandResponseDataBuilder {
  typedef CommandResponseData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kind(::flatbuffers::Offset<CommandResponseData_::Anonymous7> kind) {
    fbb_.AddOffset(CommandResponseData::VT_KIND, kind);
  }
  explicit CommandResponseDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandResponseData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandResponseData> CreateCommandResponseData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CommandResponseData_::Anonymous7> kind = 0) {
  CommandResponseDataBuilder builder_(_fbb);
  builder_.add_kind(kind);
  return builder_.Finish();
}

namespace CommandResponseData_ {

struct Anonymous7 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous7Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIO_CFG = 4
  };
  const RadioConfiguration *radio_cfg() const {
    return GetPointer<const RadioConfiguration *>(VT_RADIO_CFG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RADIO_CFG) &&
           verifier.VerifyTable(radio_cfg()) &&
           verifier.EndTable();
  }
};

struct Anonymous7Builder {
  typedef Anonymous7 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_radio_cfg(::flatbuffers::Offset<RadioConfiguration> radio_cfg) {
    fbb_.AddOffset(Anonymous7::VT_RADIO_CFG, radio_cfg);
  }
  explicit Anonymous7Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous7> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous7>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous7> CreateAnonymous7(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<RadioConfiguration> radio_cfg = 0) {
  Anonymous7Builder builder_(_fbb);
  builder_.add_radio_cfg(radio_cfg);
  return builder_.Finish();
}

}  // namespace CommandResponseData_

struct RadioConfiguration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadioConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_CHANNEL_FREQUENCY_MHZ = 6,
    VT_FILTER_UNICAST_DESTINATION = 8,
    VT_DEFAULT_TX_POWER_CBM = 10,
    VT_DEFAULT_TX_DATARATE_500KBPS = 12
  };
  const ::flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  uint32_t channel_frequency_mhz() const {
    return GetField<uint32_t>(VT_CHANNEL_FREQUENCY_MHZ, 0);
  }
  bool filter_unicast_destination() const {
    return GetField<uint8_t>(VT_FILTER_UNICAST_DESTINATION, 0) != 0;
  }
  int32_t default_tx_power_cbm() const {
    return GetField<int32_t>(VT_DEFAULT_TX_POWER_CBM, 0);
  }
  uint32_t default_tx_datarate_500kbps() const {
    return GetField<uint32_t>(VT_DEFAULT_TX_DATARATE_500KBPS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyVector(address()) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL_FREQUENCY_MHZ, 4) &&
           VerifyField<uint8_t>(verifier, VT_FILTER_UNICAST_DESTINATION, 1) &&
           VerifyField<int32_t>(verifier, VT_DEFAULT_TX_POWER_CBM, 4) &&
           VerifyField<uint32_t>(verifier, VT_DEFAULT_TX_DATARATE_500KBPS, 4) &&
           verifier.EndTable();
  }
};

struct RadioConfigurationBuilder {
  typedef RadioConfiguration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(RadioConfiguration::VT_ADDRESS, address);
  }
  void add_channel_frequency_mhz(uint32_t channel_frequency_mhz) {
    fbb_.AddElement<uint32_t>(RadioConfiguration::VT_CHANNEL_FREQUENCY_MHZ, channel_frequency_mhz, 0);
  }
  void add_filter_unicast_destination(bool filter_unicast_destination) {
    fbb_.AddElement<uint8_t>(RadioConfiguration::VT_FILTER_UNICAST_DESTINATION, static_cast<uint8_t>(filter_unicast_destination), 0);
  }
  void add_default_tx_power_cbm(int32_t default_tx_power_cbm) {
    fbb_.AddElement<int32_t>(RadioConfiguration::VT_DEFAULT_TX_POWER_CBM, default_tx_power_cbm, 0);
  }
  void add_default_tx_datarate_500kbps(uint32_t default_tx_datarate_500kbps) {
    fbb_.AddElement<uint32_t>(RadioConfiguration::VT_DEFAULT_TX_DATARATE_500KBPS, default_tx_datarate_500kbps, 0);
  }
  explicit RadioConfigurationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadioConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadioConfiguration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadioConfiguration> CreateRadioConfiguration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> address = 0,
    uint32_t channel_frequency_mhz = 0,
    bool filter_unicast_destination = false,
    int32_t default_tx_power_cbm = 0,
    uint32_t default_tx_datarate_500kbps = 0) {
  RadioConfigurationBuilder builder_(_fbb);
  builder_.add_default_tx_datarate_500kbps(default_tx_datarate_500kbps);
  builder_.add_default_tx_power_cbm(default_tx_power_cbm);
  builder_.add_channel_frequency_mhz(channel_frequency_mhz);
  builder_.add_address(address);
  builder_.add_filter_unicast_destination(filter_unicast_destination);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RadioConfiguration> CreateRadioConfigurationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *address = nullptr,
    uint32_t channel_frequency_mhz = 0,
    bool filter_unicast_destination = false,
    int32_t default_tx_power_cbm = 0,
    uint32_t default_tx_datarate_500kbps = 0) {
  auto address__ = address ? _fbb.CreateVector<uint8_t>(*address) : 0;
  return CreateRadioConfiguration(
      _fbb,
      address__,
      channel_frequency_mhz,
      filter_unicast_destination,
      default_tx_power_cbm,
      default_tx_datarate_500kbps);
}

struct LinkLayerTransmission FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinkLayerTransmissionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_DESTINATION = 6,
    VT_PRIORITY = 8,
    VT_CHANNEL = 10,
    VT_DATARATE_500KBPS = 12,
    VT_POWER_CBM = 14,
    VT_PAYLOAD = 16
  };
  const ::flatbuffers::Vector<uint8_t> *source() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SOURCE);
  }
  const ::flatbuffers::Vector<uint8_t> *destination() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DESTINATION);
  }
  LinkLayerPriority priority() const {
    return static_cast<LinkLayerPriority>(GetField<int32_t>(VT_PRIORITY, 0));
  }
  uint32_t channel() const {
    return GetField<uint32_t>(VT_CHANNEL, 0);
  }
  uint32_t datarate_500kbps() const {
    return GetField<uint32_t>(VT_DATARATE_500KBPS, 0);
  }
  int32_t power_cbm() const {
    return GetField<int32_t>(VT_POWER_CBM, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyVector(source()) &&
           VerifyOffsetRequired(verifier, VT_DESTINATION) &&
           verifier.VerifyVector(destination()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL, 4) &&
           VerifyField<uint32_t>(verifier, VT_DATARATE_500KBPS, 4) &&
           VerifyField<int32_t>(verifier, VT_POWER_CBM, 4) &&
           VerifyOffsetRequired(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct LinkLayerTransmissionBuilder {
  typedef LinkLayerTransmission Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source) {
    fbb_.AddOffset(LinkLayerTransmission::VT_SOURCE, source);
  }
  void add_destination(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination) {
    fbb_.AddOffset(LinkLayerTransmission::VT_DESTINATION, destination);
  }
  void add_priority(LinkLayerPriority priority) {
    fbb_.AddElement<int32_t>(LinkLayerTransmission::VT_PRIORITY, static_cast<int32_t>(priority), 0);
  }
  void add_channel(uint32_t channel) {
    fbb_.AddElement<uint32_t>(LinkLayerTransmission::VT_CHANNEL, channel, 0);
  }
  void add_datarate_500kbps(uint32_t datarate_500kbps) {
    fbb_.AddElement<uint32_t>(LinkLayerTransmission::VT_DATARATE_500KBPS, datarate_500kbps, 0);
  }
  void add_power_cbm(int32_t power_cbm) {
    fbb_.AddElement<int32_t>(LinkLayerTransmission::VT_POWER_CBM, power_cbm, 0);
  }
  void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(LinkLayerTransmission::VT_PAYLOAD, payload);
  }
  explicit LinkLayerTransmissionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinkLayerTransmission> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinkLayerTransmission>(end);
    fbb_.Required(o, LinkLayerTransmission::VT_DESTINATION);
    fbb_.Required(o, LinkLayerTransmission::VT_PAYLOAD);
    return o;
  }
};

inline ::flatbuffers::Offset<LinkLayerTransmission> CreateLinkLayerTransmission(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination = 0,
    LinkLayerPriority priority = LinkLayerPriority_BACKGROUND,
    uint32_t channel = 0,
    uint32_t datarate_500kbps = 0,
    int32_t power_cbm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
  LinkLayerTransmissionBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_power_cbm(power_cbm);
  builder_.add_datarate_500kbps(datarate_500kbps);
  builder_.add_channel(channel);
  builder_.add_priority(priority);
  builder_.add_destination(destination);
  builder_.add_source(source);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LinkLayerTransmission> CreateLinkLayerTransmissionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *source = nullptr,
    const std::vector<uint8_t> *destination = nullptr,
    LinkLayerPriority priority = LinkLayerPriority_BACKGROUND,
    uint32_t channel = 0,
    uint32_t datarate_500kbps = 0,
    int32_t power_cbm = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  auto source__ = source ? _fbb.CreateVector<uint8_t>(*source) : 0;
  auto destination__ = destination ? _fbb.CreateVector<uint8_t>(*destination) : 0;
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return CreateLinkLayerTransmission(
      _fbb,
      source__,
      destination__,
      priority,
      channel,
      datarate_500kbps,
      power_cbm,
      payload__);
}

struct LinkLayerReception FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinkLayerReceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_DESTINATION = 6,
    VT_CHANNEL = 8,
    VT_POWER_CBM = 10,
    VT_PAYLOAD = 12
  };
  const ::flatbuffers::Vector<uint8_t> *source() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SOURCE);
  }
  const ::flatbuffers::Vector<uint8_t> *destination() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DESTINATION);
  }
  uint32_t channel() const {
    return GetField<uint32_t>(VT_CHANNEL, 0);
  }
  int32_t power_cbm() const {
    return GetField<int32_t>(VT_POWER_CBM, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           verifier.VerifyVector(source()) &&
           VerifyOffsetRequired(verifier, VT_DESTINATION) &&
           verifier.VerifyVector(destination()) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL, 4) &&
           VerifyField<int32_t>(verifier, VT_POWER_CBM, 4) &&
           VerifyOffsetRequired(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct LinkLayerReceptionBuilder {
  typedef LinkLayerReception Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source) {
    fbb_.AddOffset(LinkLayerReception::VT_SOURCE, source);
  }
  void add_destination(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination) {
    fbb_.AddOffset(LinkLayerReception::VT_DESTINATION, destination);
  }
  void add_channel(uint32_t channel) {
    fbb_.AddElement<uint32_t>(LinkLayerReception::VT_CHANNEL, channel, 0);
  }
  void add_power_cbm(int32_t power_cbm) {
    fbb_.AddElement<int32_t>(LinkLayerReception::VT_POWER_CBM, power_cbm, 0);
  }
  void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(LinkLayerReception::VT_PAYLOAD, payload);
  }
  explicit LinkLayerReceptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinkLayerReception> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinkLayerReception>(end);
    fbb_.Required(o, LinkLayerReception::VT_SOURCE);
    fbb_.Required(o, LinkLayerReception::VT_DESTINATION);
    fbb_.Required(o, LinkLayerReception::VT_PAYLOAD);
    return o;
  }
};

inline ::flatbuffers::Offset<LinkLayerReception> CreateLinkLayerReception(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination = 0,
    uint32_t channel = 0,
    int32_t power_cbm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
  LinkLayerReceptionBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_power_cbm(power_cbm);
  builder_.add_channel(channel);
  builder_.add_destination(destination);
  builder_.add_source(source);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LinkLayerReception> CreateLinkLayerReceptionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *source = nullptr,
    const std::vector<uint8_t> *destination = nullptr,
    uint32_t channel = 0,
    int32_t power_cbm = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  auto source__ = source ? _fbb.CreateVector<uint8_t>(*source) : 0;
  auto destination__ = destination ? _fbb.CreateVector<uint8_t>(*destination) : 0;
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return CreateLinkLayerReception(
      _fbb,
      source__,
      destination__,
      channel,
      power_cbm,
      payload__);
}

struct FacilityLayerTransmission FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FacilityLayerTransmissionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG = 4
  };
  const FacilityLayerMessage *msg() const {
    return GetPointer<const FacilityLayerMessage *>(VT_MSG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MSG) &&
           verifier.VerifyTable(msg()) &&
           verifier.EndTable();
  }
};

struct FacilityLayerTransmissionBuilder {
  typedef FacilityLayerTransmission Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg(::flatbuffers::Offset<FacilityLayerMessage> msg) {
    fbb_.AddOffset(FacilityLayerTransmission::VT_MSG, msg);
  }
  explicit FacilityLayerTransmissionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FacilityLayerTransmission> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FacilityLayerTransmission>(end);
    fbb_.Required(o, FacilityLayerTransmission::VT_MSG);
    return o;
  }
};

inline ::flatbuffers::Offset<FacilityLayerTransmission> CreateFacilityLayerTransmission(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FacilityLayerMessage> msg = 0) {
  FacilityLayerTransmissionBuilder builder_(_fbb);
  builder_.add_msg(msg);
  return builder_.Finish();
}

struct FacilityLayerReception FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FacilityLayerReceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG = 4
  };
  const FacilityLayerMessage *msg() const {
    return GetPointer<const FacilityLayerMessage *>(VT_MSG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MSG) &&
           verifier.VerifyTable(msg()) &&
           verifier.EndTable();
  }
};

struct FacilityLayerReceptionBuilder {
  typedef FacilityLayerReception Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg(::flatbuffers::Offset<FacilityLayerMessage> msg) {
    fbb_.AddOffset(FacilityLayerReception::VT_MSG, msg);
  }
  explicit FacilityLayerReceptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FacilityLayerReception> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FacilityLayerReception>(end);
    fbb_.Required(o, FacilityLayerReception::VT_MSG);
    return o;
  }
};

inline ::flatbuffers::Offset<FacilityLayerReception> CreateFacilityLayerReception(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FacilityLayerMessage> msg = 0) {
  FacilityLayerReceptionBuilder builder_(_fbb);
  builder_.add_msg(msg);
  return builder_.Finish();
}

struct FacilityLayerMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FacilityLayerMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4
  };
  const FacilityLayerMessage_::Anonymous8 *kind() const {
    return GetPointer<const FacilityLayerMessage_::Anonymous8 *>(VT_KIND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KIND) &&
           verifier.VerifyTable(kind()) &&
           verifier.EndTable();
  }
};

struct FacilityLayerMessageBuilder {
  typedef FacilityLayerMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kind(::flatbuffers::Offset<FacilityLayerMessage_::Anonymous8> kind) {
    fbb_.AddOffset(FacilityLayerMessage::VT_KIND, kind);
  }
  explicit FacilityLayerMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FacilityLayerMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FacilityLayerMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FacilityLayerMessage> CreateFacilityLayerMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<FacilityLayerMessage_::Anonymous8> kind = 0) {
  FacilityLayerMessageBuilder builder_(_fbb);
  builder_.add_kind(kind);
  return builder_.Finish();
}

namespace FacilityLayerMessage_ {

struct Anonymous8 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous8Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAM_MSG = 4,
    VT_CPM_MSG = 6
  };
  const CAMessage *cam_msg() const {
    return GetPointer<const CAMessage *>(VT_CAM_MSG);
  }
  const CPMessage *cpm_msg() const {
    return GetPointer<const CPMessage *>(VT_CPM_MSG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CAM_MSG) &&
           verifier.VerifyTable(cam_msg()) &&
           VerifyOffset(verifier, VT_CPM_MSG) &&
           verifier.VerifyTable(cpm_msg()) &&
           verifier.EndTable();
  }
};

struct Anonymous8Builder {
  typedef Anonymous8 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cam_msg(::flatbuffers::Offset<CAMessage> cam_msg) {
    fbb_.AddOffset(Anonymous8::VT_CAM_MSG, cam_msg);
  }
  void add_cpm_msg(::flatbuffers::Offset<CPMessage> cpm_msg) {
    fbb_.AddOffset(Anonymous8::VT_CPM_MSG, cpm_msg);
  }
  explicit Anonymous8Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous8>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous8> CreateAnonymous8(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CAMessage> cam_msg = 0,
    ::flatbuffers::Offset<CPMessage> cpm_msg = 0) {
  Anonymous8Builder builder_(_fbb);
  builder_.add_cpm_msg(cpm_msg);
  builder_.add_cam_msg(cam_msg);
  return builder_.Finish();
}

}  // namespace FacilityLayerMessage_

struct ChannelBusyRatio FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChannelBusyRatioBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUSY = 4,
    VT_TOTAL = 6
  };
  uint32_t busy() const {
    return GetField<uint32_t>(VT_BUSY, 0);
  }
  uint32_t total() const {
    return GetField<uint32_t>(VT_TOTAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BUSY, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL, 4) &&
           verifier.EndTable();
  }
};

struct ChannelBusyRatioBuilder {
  typedef ChannelBusyRatio Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_busy(uint32_t busy) {
    fbb_.AddElement<uint32_t>(ChannelBusyRatio::VT_BUSY, busy, 0);
  }
  void add_total(uint32_t total) {
    fbb_.AddElement<uint32_t>(ChannelBusyRatio::VT_TOTAL, total, 0);
  }
  explicit ChannelBusyRatioBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChannelBusyRatio> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChannelBusyRatio>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChannelBusyRatio> CreateChannelBusyRatio(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t busy = 0,
    uint32_t total = 0) {
  ChannelBusyRatioBuilder builder_(_fbb);
  builder_.add_total(total);
  builder_.add_busy(busy);
  return builder_.Finish();
}

struct GossipMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GossipMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4
  };
  const GossipMessage_::Anonymous9 *kind() const {
    return GetPointer<const GossipMessage_::Anonymous9 *>(VT_KIND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KIND) &&
           verifier.VerifyTable(kind()) &&
           verifier.EndTable();
  }
};

struct GossipMessageBuilder {
  typedef GossipMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kind(::flatbuffers::Offset<GossipMessage_::Anonymous9> kind) {
    fbb_.AddOffset(GossipMessage::VT_KIND, kind);
  }
  explicit GossipMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GossipMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GossipMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GossipMessage> CreateGossipMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<GossipMessage_::Anonymous9> kind = 0) {
  GossipMessageBuilder builder_(_fbb);
  builder_.add_kind(kind);
  return builder_.Finish();
}

namespace GossipMessage_ {

struct Anonymous9 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Anonymous9Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CBR = 4,
    VT_LINKLAYER_RX = 6,
    VT_FACILITYLAYER_RX = 8
  };
  const ChannelBusyRatio *cbr() const {
    return GetPointer<const ChannelBusyRatio *>(VT_CBR);
  }
  const LinkLayerReception *linklayer_rx() const {
    return GetPointer<const LinkLayerReception *>(VT_LINKLAYER_RX);
  }
  const FacilityLayerReception *facilitylayer_rx() const {
    return GetPointer<const FacilityLayerReception *>(VT_FACILITYLAYER_RX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CBR) &&
           verifier.VerifyTable(cbr()) &&
           VerifyOffset(verifier, VT_LINKLAYER_RX) &&
           verifier.VerifyTable(linklayer_rx()) &&
           VerifyOffset(verifier, VT_FACILITYLAYER_RX) &&
           verifier.VerifyTable(facilitylayer_rx()) &&
           verifier.EndTable();
  }
};

struct Anonymous9Builder {
  typedef Anonymous9 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cbr(::flatbuffers::Offset<ChannelBusyRatio> cbr) {
    fbb_.AddOffset(Anonymous9::VT_CBR, cbr);
  }
  void add_linklayer_rx(::flatbuffers::Offset<LinkLayerReception> linklayer_rx) {
    fbb_.AddOffset(Anonymous9::VT_LINKLAYER_RX, linklayer_rx);
  }
  void add_facilitylayer_rx(::flatbuffers::Offset<FacilityLayerReception> facilitylayer_rx) {
    fbb_.AddOffset(Anonymous9::VT_FACILITYLAYER_RX, facilitylayer_rx);
  }
  explicit Anonymous9Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Anonymous9> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Anonymous9>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Anonymous9> CreateAnonymous9(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChannelBusyRatio> cbr = 0,
    ::flatbuffers::Offset<LinkLayerReception> linklayer_rx = 0,
    ::flatbuffers::Offset<FacilityLayerReception> facilitylayer_rx = 0) {
  Anonymous9Builder builder_(_fbb);
  builder_.add_facilitylayer_rx(facilitylayer_rx);
  builder_.add_linklayer_rx(linklayer_rx);
  builder_.add_cbr(cbr);
  return builder_.Finish();
}

}  // namespace GossipMessage_

namespace CommandRequest_ {

}  // namespace CommandRequest_

namespace CommandResponseData_ {

}  // namespace CommandResponseData_

namespace FacilityLayerMessage_ {

}  // namespace FacilityLayerMessage_

namespace GossipMessage_ {

}  // namespace GossipMessage_

#endif  // FLATBUFFERS_GENERATED_ETSIMSGINTERFACE_GOSSIPMESSAGE__H_
