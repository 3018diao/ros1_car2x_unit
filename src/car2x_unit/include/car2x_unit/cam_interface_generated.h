// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAMINTERFACE_H_
#define FLATBUFFERS_GENERATED_CAMINTERFACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

#include "etsi_its_cdd_generated.h"
#include "itspduheader_interface_generated.h"

struct CAMessage;
struct CAMessageBuilder;

struct BasicVehicleContainerHighFrequency;
struct BasicVehicleContainerHighFrequencyBuilder;

struct BasicVehicleContainerLowFrequency;
struct BasicVehicleContainerLowFrequencyBuilder;

struct CAMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CAMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_GENERATION_DELTA_TIME = 6,
    VT_STATION_TYPE = 8,
    VT_REFERENCE_POSITION = 10,
    VT_HIGH_FREQUENCY_CONTAINER = 12,
    VT_LOW_FREQUENCY_CONTAINER = 14
  };
  const ItsPduHeader *header() const {
    return GetPointer<const ItsPduHeader *>(VT_HEADER);
  }
  uint64_t generation_delta_time() const {
    return GetField<uint64_t>(VT_GENERATION_DELTA_TIME, 0);
  }
  StationType station_type() const {
    return static_cast<StationType>(GetField<int32_t>(VT_STATION_TYPE, 0));
  }
  const ReferencePosition *reference_position() const {
    return GetPointer<const ReferencePosition *>(VT_REFERENCE_POSITION);
  }
  const BasicVehicleContainerHighFrequency *high_frequency_container() const {
    return GetPointer<const BasicVehicleContainerHighFrequency *>(VT_HIGH_FREQUENCY_CONTAINER);
  }
  const BasicVehicleContainerLowFrequency *low_frequency_container() const {
    return GetPointer<const BasicVehicleContainerLowFrequency *>(VT_LOW_FREQUENCY_CONTAINER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint64_t>(verifier, VT_GENERATION_DELTA_TIME, 8) &&
           VerifyField<int32_t>(verifier, VT_STATION_TYPE, 4) &&
           VerifyOffsetRequired(verifier, VT_REFERENCE_POSITION) &&
           verifier.VerifyTable(reference_position()) &&
           VerifyOffsetRequired(verifier, VT_HIGH_FREQUENCY_CONTAINER) &&
           verifier.VerifyTable(high_frequency_container()) &&
           VerifyOffset(verifier, VT_LOW_FREQUENCY_CONTAINER) &&
           verifier.VerifyTable(low_frequency_container()) &&
           verifier.EndTable();
  }
};

struct CAMessageBuilder {
  typedef CAMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<ItsPduHeader> header) {
    fbb_.AddOffset(CAMessage::VT_HEADER, header);
  }
  void add_generation_delta_time(uint64_t generation_delta_time) {
    fbb_.AddElement<uint64_t>(CAMessage::VT_GENERATION_DELTA_TIME, generation_delta_time, 0);
  }
  void add_station_type(StationType station_type) {
    fbb_.AddElement<int32_t>(CAMessage::VT_STATION_TYPE, static_cast<int32_t>(station_type), 0);
  }
  void add_reference_position(::flatbuffers::Offset<ReferencePosition> reference_position) {
    fbb_.AddOffset(CAMessage::VT_REFERENCE_POSITION, reference_position);
  }
  void add_high_frequency_container(::flatbuffers::Offset<BasicVehicleContainerHighFrequency> high_frequency_container) {
    fbb_.AddOffset(CAMessage::VT_HIGH_FREQUENCY_CONTAINER, high_frequency_container);
  }
  void add_low_frequency_container(::flatbuffers::Offset<BasicVehicleContainerLowFrequency> low_frequency_container) {
    fbb_.AddOffset(CAMessage::VT_LOW_FREQUENCY_CONTAINER, low_frequency_container);
  }
  explicit CAMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CAMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CAMessage>(end);
    fbb_.Required(o, CAMessage::VT_HEADER);
    fbb_.Required(o, CAMessage::VT_REFERENCE_POSITION);
    fbb_.Required(o, CAMessage::VT_HIGH_FREQUENCY_CONTAINER);
    return o;
  }
};

inline ::flatbuffers::Offset<CAMessage> CreateCAMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ItsPduHeader> header = 0,
    uint64_t generation_delta_time = 0,
    StationType station_type = StationType_STN_TYPE_UNKNOWN,
    ::flatbuffers::Offset<ReferencePosition> reference_position = 0,
    ::flatbuffers::Offset<BasicVehicleContainerHighFrequency> high_frequency_container = 0,
    ::flatbuffers::Offset<BasicVehicleContainerLowFrequency> low_frequency_container = 0) {
  CAMessageBuilder builder_(_fbb);
  builder_.add_generation_delta_time(generation_delta_time);
  builder_.add_low_frequency_container(low_frequency_container);
  builder_.add_high_frequency_container(high_frequency_container);
  builder_.add_reference_position(reference_position);
  builder_.add_station_type(station_type);
  builder_.add_header(header);
  return builder_.Finish();
}

struct BasicVehicleContainerHighFrequency FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BasicVehicleContainerHighFrequencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADING = 4,
    VT_SPEED = 6,
    VT_DRIVE_DIRECTION = 8,
    VT_VEHICLE_LENGTH = 10,
    VT_VEHICLE_WIDTH = 12,
    VT_LONGITUDINAL_ACCELERATION = 14,
    VT_CURVATURE = 16,
    VT_CURVATURE_CALCULATION_MODE = 18,
    VT_YAW_RATE = 20
  };
  const Heading *heading() const {
    return GetPointer<const Heading *>(VT_HEADING);
  }
  const Speed *speed() const {
    return GetPointer<const Speed *>(VT_SPEED);
  }
  DriveDirection drive_direction() const {
    return static_cast<DriveDirection>(GetField<int32_t>(VT_DRIVE_DIRECTION, 0));
  }
  const VehicleLength *vehicle_length() const {
    return GetPointer<const VehicleLength *>(VT_VEHICLE_LENGTH);
  }
  const VehicleWidth *vehicle_width() const {
    return GetPointer<const VehicleWidth *>(VT_VEHICLE_WIDTH);
  }
  const LongitudinalAcceleration *longitudinal_acceleration() const {
    return GetPointer<const LongitudinalAcceleration *>(VT_LONGITUDINAL_ACCELERATION);
  }
  const Curvature *curvature() const {
    return GetPointer<const Curvature *>(VT_CURVATURE);
  }
  CurvatureCalculationMode curvature_calculation_mode() const {
    return static_cast<CurvatureCalculationMode>(GetField<int32_t>(VT_CURVATURE_CALCULATION_MODE, 0));
  }
  const YawRate *yaw_rate() const {
    return GetPointer<const YawRate *>(VT_YAW_RATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADING) &&
           verifier.VerifyTable(heading()) &&
           VerifyOffsetRequired(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           VerifyField<int32_t>(verifier, VT_DRIVE_DIRECTION, 4) &&
           VerifyOffsetRequired(verifier, VT_VEHICLE_LENGTH) &&
           verifier.VerifyTable(vehicle_length()) &&
           VerifyOffsetRequired(verifier, VT_VEHICLE_WIDTH) &&
           verifier.VerifyTable(vehicle_width()) &&
           VerifyOffsetRequired(verifier, VT_LONGITUDINAL_ACCELERATION) &&
           verifier.VerifyTable(longitudinal_acceleration()) &&
           VerifyOffsetRequired(verifier, VT_CURVATURE) &&
           verifier.VerifyTable(curvature()) &&
           VerifyField<int32_t>(verifier, VT_CURVATURE_CALCULATION_MODE, 4) &&
           VerifyOffsetRequired(verifier, VT_YAW_RATE) &&
           verifier.VerifyTable(yaw_rate()) &&
           verifier.EndTable();
  }
};

struct BasicVehicleContainerHighFrequencyBuilder {
  typedef BasicVehicleContainerHighFrequency Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_heading(::flatbuffers::Offset<Heading> heading) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_HEADING, heading);
  }
  void add_speed(::flatbuffers::Offset<Speed> speed) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_SPEED, speed);
  }
  void add_drive_direction(DriveDirection drive_direction) {
    fbb_.AddElement<int32_t>(BasicVehicleContainerHighFrequency::VT_DRIVE_DIRECTION, static_cast<int32_t>(drive_direction), 0);
  }
  void add_vehicle_length(::flatbuffers::Offset<VehicleLength> vehicle_length) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_VEHICLE_LENGTH, vehicle_length);
  }
  void add_vehicle_width(::flatbuffers::Offset<VehicleWidth> vehicle_width) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_VEHICLE_WIDTH, vehicle_width);
  }
  void add_longitudinal_acceleration(::flatbuffers::Offset<LongitudinalAcceleration> longitudinal_acceleration) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_LONGITUDINAL_ACCELERATION, longitudinal_acceleration);
  }
  void add_curvature(::flatbuffers::Offset<Curvature> curvature) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_CURVATURE, curvature);
  }
  void add_curvature_calculation_mode(CurvatureCalculationMode curvature_calculation_mode) {
    fbb_.AddElement<int32_t>(BasicVehicleContainerHighFrequency::VT_CURVATURE_CALCULATION_MODE, static_cast<int32_t>(curvature_calculation_mode), 0);
  }
  void add_yaw_rate(::flatbuffers::Offset<YawRate> yaw_rate) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_YAW_RATE, yaw_rate);
  }
  explicit BasicVehicleContainerHighFrequencyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BasicVehicleContainerHighFrequency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BasicVehicleContainerHighFrequency>(end);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_HEADING);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_SPEED);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_VEHICLE_LENGTH);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_VEHICLE_WIDTH);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_LONGITUDINAL_ACCELERATION);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_CURVATURE);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_YAW_RATE);
    return o;
  }
};

inline ::flatbuffers::Offset<BasicVehicleContainerHighFrequency> CreateBasicVehicleContainerHighFrequency(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Heading> heading = 0,
    ::flatbuffers::Offset<Speed> speed = 0,
    DriveDirection drive_direction = DriveDirection_DD_FORWARD,
    ::flatbuffers::Offset<VehicleLength> vehicle_length = 0,
    ::flatbuffers::Offset<VehicleWidth> vehicle_width = 0,
    ::flatbuffers::Offset<LongitudinalAcceleration> longitudinal_acceleration = 0,
    ::flatbuffers::Offset<Curvature> curvature = 0,
    CurvatureCalculationMode curvature_calculation_mode = CurvatureCalculationMode_CCM_YAWRATEUSED,
    ::flatbuffers::Offset<YawRate> yaw_rate = 0) {
  BasicVehicleContainerHighFrequencyBuilder builder_(_fbb);
  builder_.add_yaw_rate(yaw_rate);
  builder_.add_curvature_calculation_mode(curvature_calculation_mode);
  builder_.add_curvature(curvature);
  builder_.add_longitudinal_acceleration(longitudinal_acceleration);
  builder_.add_vehicle_width(vehicle_width);
  builder_.add_vehicle_length(vehicle_length);
  builder_.add_drive_direction(drive_direction);
  builder_.add_speed(speed);
  builder_.add_heading(heading);
  return builder_.Finish();
}

struct BasicVehicleContainerLowFrequency FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BasicVehicleContainerLowFrequencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMP2 = 4
  };
  uint32_t temp2() const {
    return GetField<uint32_t>(VT_TEMP2, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TEMP2, 4) &&
           verifier.EndTable();
  }
};

struct BasicVehicleContainerLowFrequencyBuilder {
  typedef BasicVehicleContainerLowFrequency Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_temp2(uint32_t temp2) {
    fbb_.AddElement<uint32_t>(BasicVehicleContainerLowFrequency::VT_TEMP2, temp2, 0);
  }
  explicit BasicVehicleContainerLowFrequencyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BasicVehicleContainerLowFrequency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BasicVehicleContainerLowFrequency>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BasicVehicleContainerLowFrequency> CreateBasicVehicleContainerLowFrequency(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t temp2 = 0) {
  BasicVehicleContainerLowFrequencyBuilder builder_(_fbb);
  builder_.add_temp2(temp2);
  return builder_.Finish();
}

#endif  // FLATBUFFERS_GENERATED_CAMINTERFACE_H_
