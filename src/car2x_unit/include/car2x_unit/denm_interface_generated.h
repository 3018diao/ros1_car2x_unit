// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DENMINTERFACE_H_
#define FLATBUFFERS_GENERATED_DENMINTERFACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

#include "etsi_its_cdd_generated.h"
#include "itspduheader_interface_generated.h"

struct DENMessage;
struct DENMessageBuilder;

struct DecentralizedEnvironmentalNotificationMessage;
struct DecentralizedEnvironmentalNotificationMessageBuilder;

struct AlacarteContainer;
struct AlacarteContainerBuilder;

struct ImpactReductionContainer;
struct ImpactReductionContainerBuilder;

struct LocationContainer;
struct LocationContainerBuilder;

struct ManagementContainer;
struct ManagementContainerBuilder;

struct RoadWorksContainerExtended;
struct RoadWorksContainerExtendedBuilder;

struct SituationContainer;
struct SituationContainerBuilder;

struct StationaryVehicleContainer;
struct StationaryVehicleContainerBuilder;

enum Termination : int32_t {
  Termination_TRMNTN_IS_CANCELLATION = 0,
  Termination_TRMNTN_IS_NEGATION = 1,
  Termination_MIN = Termination_TRMNTN_IS_CANCELLATION,
  Termination_MAX = Termination_TRMNTN_IS_NEGATION
};

inline const Termination (&EnumValuesTermination())[2] {
  static const Termination values[] = {
    Termination_TRMNTN_IS_CANCELLATION,
    Termination_TRMNTN_IS_NEGATION
  };
  return values;
}

inline const char * const *EnumNamesTermination() {
  static const char * const names[3] = {
    "TRMNTN_IS_CANCELLATION",
    "TRMNTN_IS_NEGATION",
    nullptr
  };
  return names;
}

inline const char *EnumNameTermination(Termination e) {
  if (::flatbuffers::IsOutRange(e, Termination_TRMNTN_IS_CANCELLATION, Termination_TRMNTN_IS_NEGATION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTermination()[index];
}

struct DENMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DENMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_DENM = 6
  };
  const ItsPduHeader *header() const {
    return GetPointer<const ItsPduHeader *>(VT_HEADER);
  }
  const DecentralizedEnvironmentalNotificationMessage *denm() const {
    return GetPointer<const DecentralizedEnvironmentalNotificationMessage *>(VT_DENM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_DENM) &&
           verifier.VerifyTable(denm()) &&
           verifier.EndTable();
  }
};

struct DENMessageBuilder {
  typedef DENMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<ItsPduHeader> header) {
    fbb_.AddOffset(DENMessage::VT_HEADER, header);
  }
  void add_denm(::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage> denm) {
    fbb_.AddOffset(DENMessage::VT_DENM, denm);
  }
  explicit DENMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DENMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DENMessage>(end);
    fbb_.Required(o, DENMessage::VT_HEADER);
    fbb_.Required(o, DENMessage::VT_DENM);
    return o;
  }
};

inline ::flatbuffers::Offset<DENMessage> CreateDENMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ItsPduHeader> header = 0,
    ::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage> denm = 0) {
  DENMessageBuilder builder_(_fbb);
  builder_.add_denm(denm);
  builder_.add_header(header);
  return builder_.Finish();
}

struct DecentralizedEnvironmentalNotificationMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DecentralizedEnvironmentalNotificationMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MANAGEMENT = 4,
    VT_SITUATION = 6,
    VT_LOCATION = 8,
    VT_ALACARTE = 10
  };
  const ManagementContainer *management() const {
    return GetPointer<const ManagementContainer *>(VT_MANAGEMENT);
  }
  const SituationContainer *situation() const {
    return GetPointer<const SituationContainer *>(VT_SITUATION);
  }
  const LocationContainer *location() const {
    return GetPointer<const LocationContainer *>(VT_LOCATION);
  }
  const AlacarteContainer *alacarte() const {
    return GetPointer<const AlacarteContainer *>(VT_ALACARTE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MANAGEMENT) &&
           verifier.VerifyTable(management()) &&
           VerifyOffset(verifier, VT_SITUATION) &&
           verifier.VerifyTable(situation()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_ALACARTE) &&
           verifier.VerifyTable(alacarte()) &&
           verifier.EndTable();
  }
};

struct DecentralizedEnvironmentalNotificationMessageBuilder {
  typedef DecentralizedEnvironmentalNotificationMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_management(::flatbuffers::Offset<ManagementContainer> management) {
    fbb_.AddOffset(DecentralizedEnvironmentalNotificationMessage::VT_MANAGEMENT, management);
  }
  void add_situation(::flatbuffers::Offset<SituationContainer> situation) {
    fbb_.AddOffset(DecentralizedEnvironmentalNotificationMessage::VT_SITUATION, situation);
  }
  void add_location(::flatbuffers::Offset<LocationContainer> location) {
    fbb_.AddOffset(DecentralizedEnvironmentalNotificationMessage::VT_LOCATION, location);
  }
  void add_alacarte(::flatbuffers::Offset<AlacarteContainer> alacarte) {
    fbb_.AddOffset(DecentralizedEnvironmentalNotificationMessage::VT_ALACARTE, alacarte);
  }
  explicit DecentralizedEnvironmentalNotificationMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage>(end);
    fbb_.Required(o, DecentralizedEnvironmentalNotificationMessage::VT_MANAGEMENT);
    return o;
  }
};

inline ::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage> CreateDecentralizedEnvironmentalNotificationMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ManagementContainer> management = 0,
    ::flatbuffers::Offset<SituationContainer> situation = 0,
    ::flatbuffers::Offset<LocationContainer> location = 0,
    ::flatbuffers::Offset<AlacarteContainer> alacarte = 0) {
  DecentralizedEnvironmentalNotificationMessageBuilder builder_(_fbb);
  builder_.add_alacarte(alacarte);
  builder_.add_location(location);
  builder_.add_situation(situation);
  builder_.add_management(management);
  return builder_.Finish();
}

struct AlacarteContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlacarteContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANEPOSITION = 4,
    VT_IMPACTREDUCTION = 6,
    VT_EXTERNALTEMPERATURE = 8,
    VT_ROADWORKS = 10,
    VT_POSITIONINGSOLUTION = 12,
    VT_STATIONARYVEHICLE = 14
  };
  int32_t lanePosition() const {
    return GetField<int32_t>(VT_LANEPOSITION, 0);
  }
  const ImpactReductionContainer *impactReduction() const {
    return GetPointer<const ImpactReductionContainer *>(VT_IMPACTREDUCTION);
  }
  int32_t externalTemperature() const {
    return GetField<int32_t>(VT_EXTERNALTEMPERATURE, 0);
  }
  const RoadWorksContainerExtended *roadWorks() const {
    return GetPointer<const RoadWorksContainerExtended *>(VT_ROADWORKS);
  }
  PositioningSolutionType positioningSolution() const {
    return static_cast<PositioningSolutionType>(GetField<int32_t>(VT_POSITIONINGSOLUTION, 0));
  }
  const StationaryVehicleContainer *stationaryVehicle() const {
    return GetPointer<const StationaryVehicleContainer *>(VT_STATIONARYVEHICLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LANEPOSITION, 4) &&
           VerifyOffset(verifier, VT_IMPACTREDUCTION) &&
           verifier.VerifyTable(impactReduction()) &&
           VerifyField<int32_t>(verifier, VT_EXTERNALTEMPERATURE, 4) &&
           VerifyOffset(verifier, VT_ROADWORKS) &&
           verifier.VerifyTable(roadWorks()) &&
           VerifyField<int32_t>(verifier, VT_POSITIONINGSOLUTION, 4) &&
           VerifyOffset(verifier, VT_STATIONARYVEHICLE) &&
           verifier.VerifyTable(stationaryVehicle()) &&
           verifier.EndTable();
  }
};

struct AlacarteContainerBuilder {
  typedef AlacarteContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lanePosition(int32_t lanePosition) {
    fbb_.AddElement<int32_t>(AlacarteContainer::VT_LANEPOSITION, lanePosition, 0);
  }
  void add_impactReduction(::flatbuffers::Offset<ImpactReductionContainer> impactReduction) {
    fbb_.AddOffset(AlacarteContainer::VT_IMPACTREDUCTION, impactReduction);
  }
  void add_externalTemperature(int32_t externalTemperature) {
    fbb_.AddElement<int32_t>(AlacarteContainer::VT_EXTERNALTEMPERATURE, externalTemperature, 0);
  }
  void add_roadWorks(::flatbuffers::Offset<RoadWorksContainerExtended> roadWorks) {
    fbb_.AddOffset(AlacarteContainer::VT_ROADWORKS, roadWorks);
  }
  void add_positioningSolution(PositioningSolutionType positioningSolution) {
    fbb_.AddElement<int32_t>(AlacarteContainer::VT_POSITIONINGSOLUTION, static_cast<int32_t>(positioningSolution), 0);
  }
  void add_stationaryVehicle(::flatbuffers::Offset<StationaryVehicleContainer> stationaryVehicle) {
    fbb_.AddOffset(AlacarteContainer::VT_STATIONARYVEHICLE, stationaryVehicle);
  }
  explicit AlacarteContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlacarteContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlacarteContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlacarteContainer> CreateAlacarteContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lanePosition = 0,
    ::flatbuffers::Offset<ImpactReductionContainer> impactReduction = 0,
    int32_t externalTemperature = 0,
    ::flatbuffers::Offset<RoadWorksContainerExtended> roadWorks = 0,
    PositioningSolutionType positioningSolution = PositioningSolutionType_PST_NOPOSITIONINGSOLUTION,
    ::flatbuffers::Offset<StationaryVehicleContainer> stationaryVehicle = 0) {
  AlacarteContainerBuilder builder_(_fbb);
  builder_.add_stationaryVehicle(stationaryVehicle);
  builder_.add_positioningSolution(positioningSolution);
  builder_.add_roadWorks(roadWorks);
  builder_.add_externalTemperature(externalTemperature);
  builder_.add_impactReduction(impactReduction);
  builder_.add_lanePosition(lanePosition);
  return builder_.Finish();
}

struct ImpactReductionContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImpactReductionContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHTLONCARRLEFT = 4,
    VT_HEIGHTLONCARRRIGHT = 6,
    VT_POSLONCARRLEFT = 8,
    VT_POSLONCARRRIGHT = 10,
    VT_POSITIONOFPILLARS = 12,
    VT_POSCENTMASS = 14,
    VT_WHEELBASEVEHICLE = 16,
    VT_TURNINGRADIUS = 18,
    VT_POSFRONTAX = 20,
    VT_POSITIONOFOCCUPANTS = 22,
    VT_VEHICLEMASS = 24,
    VT_REQUESTRESPONSEINDICATION = 26
  };
  uint32_t heightLonCarrLeft() const {
    return GetField<uint32_t>(VT_HEIGHTLONCARRLEFT, 0);
  }
  uint32_t heightLonCarrRight() const {
    return GetField<uint32_t>(VT_HEIGHTLONCARRRIGHT, 0);
  }
  uint32_t posLonCarrLeft() const {
    return GetField<uint32_t>(VT_POSLONCARRLEFT, 0);
  }
  uint32_t posLonCarrRight() const {
    return GetField<uint32_t>(VT_POSLONCARRRIGHT, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *positionOfPillars() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_POSITIONOFPILLARS);
  }
  uint32_t posCentMass() const {
    return GetField<uint32_t>(VT_POSCENTMASS, 0);
  }
  uint32_t wheelBaseVehicle() const {
    return GetField<uint32_t>(VT_WHEELBASEVEHICLE, 0);
  }
  uint32_t turningRadius() const {
    return GetField<uint32_t>(VT_TURNINGRADIUS, 0);
  }
  uint32_t posFrontAx() const {
    return GetField<uint32_t>(VT_POSFRONTAX, 0);
  }
  PositionOfOccupants positionOfOccupants() const {
    return static_cast<PositionOfOccupants>(GetField<int32_t>(VT_POSITIONOFOCCUPANTS, 0));
  }
  uint32_t vehicleMass() const {
    return GetField<uint32_t>(VT_VEHICLEMASS, 0);
  }
  RequestResponseIndication requestResponseIndication() const {
    return static_cast<RequestResponseIndication>(GetField<int32_t>(VT_REQUESTRESPONSEINDICATION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHTLONCARRLEFT, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHTLONCARRRIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_POSLONCARRLEFT, 4) &&
           VerifyField<uint32_t>(verifier, VT_POSLONCARRRIGHT, 4) &&
           VerifyOffset(verifier, VT_POSITIONOFPILLARS) &&
           verifier.VerifyVector(positionOfPillars()) &&
           VerifyField<uint32_t>(verifier, VT_POSCENTMASS, 4) &&
           VerifyField<uint32_t>(verifier, VT_WHEELBASEVEHICLE, 4) &&
           VerifyField<uint32_t>(verifier, VT_TURNINGRADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_POSFRONTAX, 4) &&
           VerifyField<int32_t>(verifier, VT_POSITIONOFOCCUPANTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_VEHICLEMASS, 4) &&
           VerifyField<int32_t>(verifier, VT_REQUESTRESPONSEINDICATION, 4) &&
           verifier.EndTable();
  }
};

struct ImpactReductionContainerBuilder {
  typedef ImpactReductionContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_heightLonCarrLeft(uint32_t heightLonCarrLeft) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_HEIGHTLONCARRLEFT, heightLonCarrLeft, 0);
  }
  void add_heightLonCarrRight(uint32_t heightLonCarrRight) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_HEIGHTLONCARRRIGHT, heightLonCarrRight, 0);
  }
  void add_posLonCarrLeft(uint32_t posLonCarrLeft) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_POSLONCARRLEFT, posLonCarrLeft, 0);
  }
  void add_posLonCarrRight(uint32_t posLonCarrRight) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_POSLONCARRRIGHT, posLonCarrRight, 0);
  }
  void add_positionOfPillars(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> positionOfPillars) {
    fbb_.AddOffset(ImpactReductionContainer::VT_POSITIONOFPILLARS, positionOfPillars);
  }
  void add_posCentMass(uint32_t posCentMass) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_POSCENTMASS, posCentMass, 0);
  }
  void add_wheelBaseVehicle(uint32_t wheelBaseVehicle) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_WHEELBASEVEHICLE, wheelBaseVehicle, 0);
  }
  void add_turningRadius(uint32_t turningRadius) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_TURNINGRADIUS, turningRadius, 0);
  }
  void add_posFrontAx(uint32_t posFrontAx) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_POSFRONTAX, posFrontAx, 0);
  }
  void add_positionOfOccupants(PositionOfOccupants positionOfOccupants) {
    fbb_.AddElement<int32_t>(ImpactReductionContainer::VT_POSITIONOFOCCUPANTS, static_cast<int32_t>(positionOfOccupants), 0);
  }
  void add_vehicleMass(uint32_t vehicleMass) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_VEHICLEMASS, vehicleMass, 0);
  }
  void add_requestResponseIndication(RequestResponseIndication requestResponseIndication) {
    fbb_.AddElement<int32_t>(ImpactReductionContainer::VT_REQUESTRESPONSEINDICATION, static_cast<int32_t>(requestResponseIndication), 0);
  }
  explicit ImpactReductionContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImpactReductionContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImpactReductionContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImpactReductionContainer> CreateImpactReductionContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t heightLonCarrLeft = 0,
    uint32_t heightLonCarrRight = 0,
    uint32_t posLonCarrLeft = 0,
    uint32_t posLonCarrRight = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> positionOfPillars = 0,
    uint32_t posCentMass = 0,
    uint32_t wheelBaseVehicle = 0,
    uint32_t turningRadius = 0,
    uint32_t posFrontAx = 0,
    PositionOfOccupants positionOfOccupants = PositionOfOccupants_POS_OCC_ROW1LEFTOCCUPIED,
    uint32_t vehicleMass = 0,
    RequestResponseIndication requestResponseIndication = RequestResponseIndication_RRI_REQUEST) {
  ImpactReductionContainerBuilder builder_(_fbb);
  builder_.add_requestResponseIndication(requestResponseIndication);
  builder_.add_vehicleMass(vehicleMass);
  builder_.add_positionOfOccupants(positionOfOccupants);
  builder_.add_posFrontAx(posFrontAx);
  builder_.add_turningRadius(turningRadius);
  builder_.add_wheelBaseVehicle(wheelBaseVehicle);
  builder_.add_posCentMass(posCentMass);
  builder_.add_positionOfPillars(positionOfPillars);
  builder_.add_posLonCarrRight(posLonCarrRight);
  builder_.add_posLonCarrLeft(posLonCarrLeft);
  builder_.add_heightLonCarrRight(heightLonCarrRight);
  builder_.add_heightLonCarrLeft(heightLonCarrLeft);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ImpactReductionContainer> CreateImpactReductionContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t heightLonCarrLeft = 0,
    uint32_t heightLonCarrRight = 0,
    uint32_t posLonCarrLeft = 0,
    uint32_t posLonCarrRight = 0,
    const std::vector<uint32_t> *positionOfPillars = nullptr,
    uint32_t posCentMass = 0,
    uint32_t wheelBaseVehicle = 0,
    uint32_t turningRadius = 0,
    uint32_t posFrontAx = 0,
    PositionOfOccupants positionOfOccupants = PositionOfOccupants_POS_OCC_ROW1LEFTOCCUPIED,
    uint32_t vehicleMass = 0,
    RequestResponseIndication requestResponseIndication = RequestResponseIndication_RRI_REQUEST) {
  auto positionOfPillars__ = positionOfPillars ? _fbb.CreateVector<uint32_t>(*positionOfPillars) : 0;
  return CreateImpactReductionContainer(
      _fbb,
      heightLonCarrLeft,
      heightLonCarrRight,
      posLonCarrLeft,
      posLonCarrRight,
      positionOfPillars__,
      posCentMass,
      wheelBaseVehicle,
      turningRadius,
      posFrontAx,
      positionOfOccupants,
      vehicleMass,
      requestResponseIndication);
}

struct LocationContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LocationContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENTSPEED = 4,
    VT_EVENTPOSITIONHEADING = 6,
    VT_TRACES = 8,
    VT_ROADTYPE = 10
  };
  const Speed *eventSpeed() const {
    return GetPointer<const Speed *>(VT_EVENTSPEED);
  }
  const Heading *eventPositionHeading() const {
    return GetPointer<const Heading *>(VT_EVENTPOSITIONHEADING);
  }
  uint32_t traces() const {
    return GetField<uint32_t>(VT_TRACES, 0);
  }
  RoadType roadType() const {
    return static_cast<RoadType>(GetField<int32_t>(VT_ROADTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENTSPEED) &&
           verifier.VerifyTable(eventSpeed()) &&
           VerifyOffset(verifier, VT_EVENTPOSITIONHEADING) &&
           verifier.VerifyTable(eventPositionHeading()) &&
           VerifyField<uint32_t>(verifier, VT_TRACES, 4) &&
           VerifyField<int32_t>(verifier, VT_ROADTYPE, 4) &&
           verifier.EndTable();
  }
};

struct LocationContainerBuilder {
  typedef LocationContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_eventSpeed(::flatbuffers::Offset<Speed> eventSpeed) {
    fbb_.AddOffset(LocationContainer::VT_EVENTSPEED, eventSpeed);
  }
  void add_eventPositionHeading(::flatbuffers::Offset<Heading> eventPositionHeading) {
    fbb_.AddOffset(LocationContainer::VT_EVENTPOSITIONHEADING, eventPositionHeading);
  }
  void add_traces(uint32_t traces) {
    fbb_.AddElement<uint32_t>(LocationContainer::VT_TRACES, traces, 0);
  }
  void add_roadType(RoadType roadType) {
    fbb_.AddElement<int32_t>(LocationContainer::VT_ROADTYPE, static_cast<int32_t>(roadType), 0);
  }
  explicit LocationContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LocationContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LocationContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LocationContainer> CreateLocationContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Speed> eventSpeed = 0,
    ::flatbuffers::Offset<Heading> eventPositionHeading = 0,
    uint32_t traces = 0,
    RoadType roadType = RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES) {
  LocationContainerBuilder builder_(_fbb);
  builder_.add_roadType(roadType);
  builder_.add_traces(traces);
  builder_.add_eventPositionHeading(eventPositionHeading);
  builder_.add_eventSpeed(eventSpeed);
  return builder_.Finish();
}

struct ManagementContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ManagementContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIONID = 4,
    VT_DETECTIONTIME = 6,
    VT_REFERENCETIME = 8,
    VT_TERMINATION = 10,
    VT_EVENTPOSITION = 12,
    VT_RELEVANCEDISTANCE = 14,
    VT_RELEVANCETRAFFICDIRECTION = 16,
    VT_VALIDITYDURATION = 18,
    VT_TRANSMISSIONINTERVAL = 20,
    VT_STATIONTYPE = 22
  };
  const ActionID *actionID() const {
    return GetPointer<const ActionID *>(VT_ACTIONID);
  }
  uint64_t detectionTime() const {
    return GetField<uint64_t>(VT_DETECTIONTIME, 0);
  }
  uint64_t referenceTime() const {
    return GetField<uint64_t>(VT_REFERENCETIME, 0);
  }
  Termination termination() const {
    return static_cast<Termination>(GetField<int32_t>(VT_TERMINATION, 0));
  }
  const ReferencePosition *eventPosition() const {
    return GetPointer<const ReferencePosition *>(VT_EVENTPOSITION);
  }
  RelevanceDistance relevanceDistance() const {
    return static_cast<RelevanceDistance>(GetField<int32_t>(VT_RELEVANCEDISTANCE, 0));
  }
  RelevanceTrafficDirection relevanceTrafficDirection() const {
    return static_cast<RelevanceTrafficDirection>(GetField<int32_t>(VT_RELEVANCETRAFFICDIRECTION, 0));
  }
  uint32_t validityDuration() const {
    return GetField<uint32_t>(VT_VALIDITYDURATION, 600);
  }
  uint32_t transmissionInterval() const {
    return GetField<uint32_t>(VT_TRANSMISSIONINTERVAL, 0);
  }
  StationType stationType() const {
    return static_cast<StationType>(GetField<int32_t>(VT_STATIONTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ACTIONID) &&
           verifier.VerifyTable(actionID()) &&
           VerifyField<uint64_t>(verifier, VT_DETECTIONTIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_REFERENCETIME, 8) &&
           VerifyField<int32_t>(verifier, VT_TERMINATION, 4) &&
           VerifyOffsetRequired(verifier, VT_EVENTPOSITION) &&
           verifier.VerifyTable(eventPosition()) &&
           VerifyField<int32_t>(verifier, VT_RELEVANCEDISTANCE, 4) &&
           VerifyField<int32_t>(verifier, VT_RELEVANCETRAFFICDIRECTION, 4) &&
           VerifyField<uint32_t>(verifier, VT_VALIDITYDURATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_TRANSMISSIONINTERVAL, 4) &&
           VerifyField<int32_t>(verifier, VT_STATIONTYPE, 4) &&
           verifier.EndTable();
  }
};

struct ManagementContainerBuilder {
  typedef ManagementContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_actionID(::flatbuffers::Offset<ActionID> actionID) {
    fbb_.AddOffset(ManagementContainer::VT_ACTIONID, actionID);
  }
  void add_detectionTime(uint64_t detectionTime) {
    fbb_.AddElement<uint64_t>(ManagementContainer::VT_DETECTIONTIME, detectionTime, 0);
  }
  void add_referenceTime(uint64_t referenceTime) {
    fbb_.AddElement<uint64_t>(ManagementContainer::VT_REFERENCETIME, referenceTime, 0);
  }
  void add_termination(Termination termination) {
    fbb_.AddElement<int32_t>(ManagementContainer::VT_TERMINATION, static_cast<int32_t>(termination), 0);
  }
  void add_eventPosition(::flatbuffers::Offset<ReferencePosition> eventPosition) {
    fbb_.AddOffset(ManagementContainer::VT_EVENTPOSITION, eventPosition);
  }
  void add_relevanceDistance(RelevanceDistance relevanceDistance) {
    fbb_.AddElement<int32_t>(ManagementContainer::VT_RELEVANCEDISTANCE, static_cast<int32_t>(relevanceDistance), 0);
  }
  void add_relevanceTrafficDirection(RelevanceTrafficDirection relevanceTrafficDirection) {
    fbb_.AddElement<int32_t>(ManagementContainer::VT_RELEVANCETRAFFICDIRECTION, static_cast<int32_t>(relevanceTrafficDirection), 0);
  }
  void add_validityDuration(uint32_t validityDuration) {
    fbb_.AddElement<uint32_t>(ManagementContainer::VT_VALIDITYDURATION, validityDuration, 600);
  }
  void add_transmissionInterval(uint32_t transmissionInterval) {
    fbb_.AddElement<uint32_t>(ManagementContainer::VT_TRANSMISSIONINTERVAL, transmissionInterval, 0);
  }
  void add_stationType(StationType stationType) {
    fbb_.AddElement<int32_t>(ManagementContainer::VT_STATIONTYPE, static_cast<int32_t>(stationType), 0);
  }
  explicit ManagementContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ManagementContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ManagementContainer>(end);
    fbb_.Required(o, ManagementContainer::VT_ACTIONID);
    fbb_.Required(o, ManagementContainer::VT_EVENTPOSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<ManagementContainer> CreateManagementContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ActionID> actionID = 0,
    uint64_t detectionTime = 0,
    uint64_t referenceTime = 0,
    Termination termination = Termination_TRMNTN_IS_CANCELLATION,
    ::flatbuffers::Offset<ReferencePosition> eventPosition = 0,
    RelevanceDistance relevanceDistance = RelevanceDistance_REL_DIST_LESSTHAN50M,
    RelevanceTrafficDirection relevanceTrafficDirection = RelevanceTrafficDirection_REL_TD_ALLTRAFFICDIRECTIONS,
    uint32_t validityDuration = 600,
    uint32_t transmissionInterval = 0,
    StationType stationType = StationType_STN_TYPE_UNKNOWN) {
  ManagementContainerBuilder builder_(_fbb);
  builder_.add_referenceTime(referenceTime);
  builder_.add_detectionTime(detectionTime);
  builder_.add_stationType(stationType);
  builder_.add_transmissionInterval(transmissionInterval);
  builder_.add_validityDuration(validityDuration);
  builder_.add_relevanceTrafficDirection(relevanceTrafficDirection);
  builder_.add_relevanceDistance(relevanceDistance);
  builder_.add_eventPosition(eventPosition);
  builder_.add_termination(termination);
  builder_.add_actionID(actionID);
  return builder_.Finish();
}

struct RoadWorksContainerExtended FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoadWorksContainerExtendedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIGHTBARSIRENINUSE = 4,
    VT_CLOSEDLANES = 6,
    VT_RESTRICTION = 8,
    VT_SPEEDLIMIT = 10,
    VT_INCIDENTINDICATION = 12,
    VT_RECOMMENDEDPATH = 14,
    VT_STARTINGPOINTSPEEDLIMIT = 16,
    VT_TRAFFICFLOWRULE = 18,
    VT_REFERENCEDENMS = 20
  };
  LightBarSirenInUse lightBarSirenInUse() const {
    return static_cast<LightBarSirenInUse>(GetField<int32_t>(VT_LIGHTBARSIRENINUSE, 0));
  }
  const ClosedLanes *closedLanes() const {
    return GetPointer<const ClosedLanes *>(VT_CLOSEDLANES);
  }
  const RestrictedTypes *restriction() const {
    return GetPointer<const RestrictedTypes *>(VT_RESTRICTION);
  }
  uint32_t speedLimit() const {
    return GetField<uint32_t>(VT_SPEEDLIMIT, 0);
  }
  const CauseCode *incidentIndication() const {
    return GetPointer<const CauseCode *>(VT_INCIDENTINDICATION);
  }
  const ItineraryPath *recommendedPath() const {
    return GetPointer<const ItineraryPath *>(VT_RECOMMENDEDPATH);
  }
  const DeltaReferencePosition *startingPointSpeedLimit() const {
    return GetPointer<const DeltaReferencePosition *>(VT_STARTINGPOINTSPEEDLIMIT);
  }
  TrafficRule trafficFlowRule() const {
    return static_cast<TrafficRule>(GetField<int32_t>(VT_TRAFFICFLOWRULE, 0));
  }
  const ReferenceDenms *referenceDenms() const {
    return GetPointer<const ReferenceDenms *>(VT_REFERENCEDENMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LIGHTBARSIRENINUSE, 4) &&
           VerifyOffset(verifier, VT_CLOSEDLANES) &&
           verifier.VerifyTable(closedLanes()) &&
           VerifyOffset(verifier, VT_RESTRICTION) &&
           verifier.VerifyTable(restriction()) &&
           VerifyField<uint32_t>(verifier, VT_SPEEDLIMIT, 4) &&
           VerifyOffset(verifier, VT_INCIDENTINDICATION) &&
           verifier.VerifyTable(incidentIndication()) &&
           VerifyOffset(verifier, VT_RECOMMENDEDPATH) &&
           verifier.VerifyTable(recommendedPath()) &&
           VerifyOffset(verifier, VT_STARTINGPOINTSPEEDLIMIT) &&
           verifier.VerifyTable(startingPointSpeedLimit()) &&
           VerifyField<int32_t>(verifier, VT_TRAFFICFLOWRULE, 4) &&
           VerifyOffset(verifier, VT_REFERENCEDENMS) &&
           verifier.VerifyTable(referenceDenms()) &&
           verifier.EndTable();
  }
};

struct RoadWorksContainerExtendedBuilder {
  typedef RoadWorksContainerExtended Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lightBarSirenInUse(LightBarSirenInUse lightBarSirenInUse) {
    fbb_.AddElement<int32_t>(RoadWorksContainerExtended::VT_LIGHTBARSIRENINUSE, static_cast<int32_t>(lightBarSirenInUse), 0);
  }
  void add_closedLanes(::flatbuffers::Offset<ClosedLanes> closedLanes) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_CLOSEDLANES, closedLanes);
  }
  void add_restriction(::flatbuffers::Offset<RestrictedTypes> restriction) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_RESTRICTION, restriction);
  }
  void add_speedLimit(uint32_t speedLimit) {
    fbb_.AddElement<uint32_t>(RoadWorksContainerExtended::VT_SPEEDLIMIT, speedLimit, 0);
  }
  void add_incidentIndication(::flatbuffers::Offset<CauseCode> incidentIndication) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_INCIDENTINDICATION, incidentIndication);
  }
  void add_recommendedPath(::flatbuffers::Offset<ItineraryPath> recommendedPath) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_RECOMMENDEDPATH, recommendedPath);
  }
  void add_startingPointSpeedLimit(::flatbuffers::Offset<DeltaReferencePosition> startingPointSpeedLimit) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_STARTINGPOINTSPEEDLIMIT, startingPointSpeedLimit);
  }
  void add_trafficFlowRule(TrafficRule trafficFlowRule) {
    fbb_.AddElement<int32_t>(RoadWorksContainerExtended::VT_TRAFFICFLOWRULE, static_cast<int32_t>(trafficFlowRule), 0);
  }
  void add_referenceDenms(::flatbuffers::Offset<ReferenceDenms> referenceDenms) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_REFERENCEDENMS, referenceDenms);
  }
  explicit RoadWorksContainerExtendedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoadWorksContainerExtended> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoadWorksContainerExtended>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoadWorksContainerExtended> CreateRoadWorksContainerExtended(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LightBarSirenInUse lightBarSirenInUse = LightBarSirenInUse_LS_LIGHTBARACTIVATED,
    ::flatbuffers::Offset<ClosedLanes> closedLanes = 0,
    ::flatbuffers::Offset<RestrictedTypes> restriction = 0,
    uint32_t speedLimit = 0,
    ::flatbuffers::Offset<CauseCode> incidentIndication = 0,
    ::flatbuffers::Offset<ItineraryPath> recommendedPath = 0,
    ::flatbuffers::Offset<DeltaReferencePosition> startingPointSpeedLimit = 0,
    TrafficRule trafficFlowRule = TrafficRule_TR_NOPASSING,
    ::flatbuffers::Offset<ReferenceDenms> referenceDenms = 0) {
  RoadWorksContainerExtendedBuilder builder_(_fbb);
  builder_.add_referenceDenms(referenceDenms);
  builder_.add_trafficFlowRule(trafficFlowRule);
  builder_.add_startingPointSpeedLimit(startingPointSpeedLimit);
  builder_.add_recommendedPath(recommendedPath);
  builder_.add_incidentIndication(incidentIndication);
  builder_.add_speedLimit(speedLimit);
  builder_.add_restriction(restriction);
  builder_.add_closedLanes(closedLanes);
  builder_.add_lightBarSirenInUse(lightBarSirenInUse);
  return builder_.Finish();
}

struct SituationContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SituationContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFORMATIONQUALITY = 4,
    VT_EVENTTYPE = 6,
    VT_LINKEDCAUSE = 8,
    VT_EVENTHISTORY = 10
  };
  uint32_t informationQuality() const {
    return GetField<uint32_t>(VT_INFORMATIONQUALITY, 0);
  }
  const CauseCode *eventType() const {
    return GetPointer<const CauseCode *>(VT_EVENTTYPE);
  }
  const CauseCode *linkedCause() const {
    return GetPointer<const CauseCode *>(VT_LINKEDCAUSE);
  }
  const EventHistory *eventHistory() const {
    return GetPointer<const EventHistory *>(VT_EVENTHISTORY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INFORMATIONQUALITY, 4) &&
           VerifyOffsetRequired(verifier, VT_EVENTTYPE) &&
           verifier.VerifyTable(eventType()) &&
           VerifyOffset(verifier, VT_LINKEDCAUSE) &&
           verifier.VerifyTable(linkedCause()) &&
           VerifyOffset(verifier, VT_EVENTHISTORY) &&
           verifier.VerifyTable(eventHistory()) &&
           verifier.EndTable();
  }
};

struct SituationContainerBuilder {
  typedef SituationContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_informationQuality(uint32_t informationQuality) {
    fbb_.AddElement<uint32_t>(SituationContainer::VT_INFORMATIONQUALITY, informationQuality, 0);
  }
  void add_eventType(::flatbuffers::Offset<CauseCode> eventType) {
    fbb_.AddOffset(SituationContainer::VT_EVENTTYPE, eventType);
  }
  void add_linkedCause(::flatbuffers::Offset<CauseCode> linkedCause) {
    fbb_.AddOffset(SituationContainer::VT_LINKEDCAUSE, linkedCause);
  }
  void add_eventHistory(::flatbuffers::Offset<EventHistory> eventHistory) {
    fbb_.AddOffset(SituationContainer::VT_EVENTHISTORY, eventHistory);
  }
  explicit SituationContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SituationContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SituationContainer>(end);
    fbb_.Required(o, SituationContainer::VT_EVENTTYPE);
    return o;
  }
};

inline ::flatbuffers::Offset<SituationContainer> CreateSituationContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t informationQuality = 0,
    ::flatbuffers::Offset<CauseCode> eventType = 0,
    ::flatbuffers::Offset<CauseCode> linkedCause = 0,
    ::flatbuffers::Offset<EventHistory> eventHistory = 0) {
  SituationContainerBuilder builder_(_fbb);
  builder_.add_eventHistory(eventHistory);
  builder_.add_linkedCause(linkedCause);
  builder_.add_eventType(eventType);
  builder_.add_informationQuality(informationQuality);
  return builder_.Finish();
}

struct StationaryVehicleContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StationaryVehicleContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATIONARYSINCE = 4,
    VT_STATIONARYCAUSE = 6,
    VT_CARRYINGDANGEROUSGOODS = 8,
    VT_NUMBEROFOCCUPANTS = 10,
    VT_VEHICLEIDENTIFICATION = 12,
    VT_ENERGYSTORAGETYPE = 14
  };
  StationarySince stationarySince() const {
    return static_cast<StationarySince>(GetField<int32_t>(VT_STATIONARYSINCE, 0));
  }
  const CauseCode *stationaryCause() const {
    return GetPointer<const CauseCode *>(VT_STATIONARYCAUSE);
  }
  const DangerousGoodsExtended *carryingDangerousGoods() const {
    return GetPointer<const DangerousGoodsExtended *>(VT_CARRYINGDANGEROUSGOODS);
  }
  uint32_t numberOfOccupants() const {
    return GetField<uint32_t>(VT_NUMBEROFOCCUPANTS, 0);
  }
  const VehicleIdentification *vehicleIdentification() const {
    return GetPointer<const VehicleIdentification *>(VT_VEHICLEIDENTIFICATION);
  }
  const EnergyStorageType *energyStorageType() const {
    return GetPointer<const EnergyStorageType *>(VT_ENERGYSTORAGETYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATIONARYSINCE, 4) &&
           VerifyOffset(verifier, VT_STATIONARYCAUSE) &&
           verifier.VerifyTable(stationaryCause()) &&
           VerifyOffset(verifier, VT_CARRYINGDANGEROUSGOODS) &&
           verifier.VerifyTable(carryingDangerousGoods()) &&
           VerifyField<uint32_t>(verifier, VT_NUMBEROFOCCUPANTS, 4) &&
           VerifyOffset(verifier, VT_VEHICLEIDENTIFICATION) &&
           verifier.VerifyTable(vehicleIdentification()) &&
           VerifyOffset(verifier, VT_ENERGYSTORAGETYPE) &&
           verifier.VerifyTable(energyStorageType()) &&
           verifier.EndTable();
  }
};

struct StationaryVehicleContainerBuilder {
  typedef StationaryVehicleContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stationarySince(StationarySince stationarySince) {
    fbb_.AddElement<int32_t>(StationaryVehicleContainer::VT_STATIONARYSINCE, static_cast<int32_t>(stationarySince), 0);
  }
  void add_stationaryCause(::flatbuffers::Offset<CauseCode> stationaryCause) {
    fbb_.AddOffset(StationaryVehicleContainer::VT_STATIONARYCAUSE, stationaryCause);
  }
  void add_carryingDangerousGoods(::flatbuffers::Offset<DangerousGoodsExtended> carryingDangerousGoods) {
    fbb_.AddOffset(StationaryVehicleContainer::VT_CARRYINGDANGEROUSGOODS, carryingDangerousGoods);
  }
  void add_numberOfOccupants(uint32_t numberOfOccupants) {
    fbb_.AddElement<uint32_t>(StationaryVehicleContainer::VT_NUMBEROFOCCUPANTS, numberOfOccupants, 0);
  }
  void add_vehicleIdentification(::flatbuffers::Offset<VehicleIdentification> vehicleIdentification) {
    fbb_.AddOffset(StationaryVehicleContainer::VT_VEHICLEIDENTIFICATION, vehicleIdentification);
  }
  void add_energyStorageType(::flatbuffers::Offset<EnergyStorageType> energyStorageType) {
    fbb_.AddOffset(StationaryVehicleContainer::VT_ENERGYSTORAGETYPE, energyStorageType);
  }
  explicit StationaryVehicleContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StationaryVehicleContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StationaryVehicleContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StationaryVehicleContainer> CreateStationaryVehicleContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    StationarySince stationarySince = StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE,
    ::flatbuffers::Offset<CauseCode> stationaryCause = 0,
    ::flatbuffers::Offset<DangerousGoodsExtended> carryingDangerousGoods = 0,
    uint32_t numberOfOccupants = 0,
    ::flatbuffers::Offset<VehicleIdentification> vehicleIdentification = 0,
    ::flatbuffers::Offset<EnergyStorageType> energyStorageType = 0) {
  StationaryVehicleContainerBuilder builder_(_fbb);
  builder_.add_energyStorageType(energyStorageType);
  builder_.add_vehicleIdentification(vehicleIdentification);
  builder_.add_numberOfOccupants(numberOfOccupants);
  builder_.add_carryingDangerousGoods(carryingDangerousGoods);
  builder_.add_stationaryCause(stationaryCause);
  builder_.add_stationarySince(stationarySince);
  return builder_.Finish();
}

#endif  // FLATBUFFERS_GENERATED_DENMINTERFACE_H_
