// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALLINTERFACENEW_GOS_H_
#define FLATBUFFERS_GENERATED_ALLINTERFACENEW_GOS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

namespace Gos {

struct CommandRequest;
struct CommandRequestBuilder;

struct CommandResponse;
struct CommandResponseBuilder;

struct CommandResponseData;
struct CommandResponseDataBuilder;

struct RadioConfiguration;
struct RadioConfigurationBuilder;

struct LinkLayerTransmission;
struct LinkLayerTransmissionBuilder;

struct LinkLayerReception;
struct LinkLayerReceptionBuilder;

struct FacilityLayerTransmission;
struct FacilityLayerTransmissionBuilder;

struct FacilityLayerReception;
struct FacilityLayerReceptionBuilder;

struct ChannelBusyRatio;
struct ChannelBusyRatioBuilder;

struct GossipMessage;
struct GossipMessageBuilder;

struct ItsPduHeader;
struct ItsPduHeaderBuilder;

struct CAMessage;
struct CAMessageBuilder;

struct BasicVehicleContainerHighFrequency;
struct BasicVehicleContainerHighFrequencyBuilder;

struct BasicVehicleContainerLowFrequency;
struct BasicVehicleContainerLowFrequencyBuilder;

struct CPMessage;
struct CPMessageBuilder;

struct CpmPayload;
struct CpmPayloadBuilder;

struct ManagementContainer;
struct ManagementContainerBuilder;

struct MessageRateRange;
struct MessageRateRangeBuilder;

struct OriginatingStationsContainer;
struct OriginatingStationsContainerBuilder;

struct OriginatingVehicleContainer;
struct OriginatingVehicleContainerBuilder;

struct OriginatingRSUContainer;
struct OriginatingRSUContainerBuilder;

struct SensorInformationContainer;
struct SensorInformationContainerBuilder;

struct SensorInformation;
struct SensorInformationBuilder;

struct PerceptionRegionContainer;
struct PerceptionRegionContainerBuilder;

struct PerceptionRegion;
struct PerceptionRegionBuilder;

struct PerceivedObjectContainer;
struct PerceivedObjectContainerBuilder;

struct PerceivedObject;
struct PerceivedObjectBuilder;

struct DENMessage;
struct DENMessageBuilder;

struct DecentralizedEnvironmentalNotificationMessage;
struct DecentralizedEnvironmentalNotificationMessageBuilder;

struct AlacarteContainer;
struct AlacarteContainerBuilder;

struct ImpactReductionContainer;
struct ImpactReductionContainerBuilder;

struct LocationContainer;
struct LocationContainerBuilder;

struct DenmManagementContainer;
struct DenmManagementContainerBuilder;

struct RoadWorksContainerExtended;
struct RoadWorksContainerExtendedBuilder;

struct SituationContainer;
struct SituationContainerBuilder;

struct StationaryVehicleContainer;
struct StationaryVehicleContainerBuilder;

struct Acceleration3dWithConfidence;
struct Acceleration3dWithConfidenceBuilder;

struct AccelerationComponent;

struct AccelerationCartesian;
struct AccelerationCartesianBuilder;

struct AccelerationMagnitude;
struct AccelerationMagnitudeBuilder;

struct AccelerationPolarWithZ;
struct AccelerationPolarWithZBuilder;

struct ActionID;
struct ActionIDBuilder;

struct Altitude;
struct AltitudeBuilder;

struct CartesianAngle;
struct CartesianAngleBuilder;

struct CartesianAngularVelocityComponent;
struct CartesianAngularVelocityComponentBuilder;

struct CartesianPosition3d;
struct CartesianPosition3dBuilder;

struct CartesianCoordinateWithConfidence;
struct CartesianCoordinateWithConfidenceBuilder;

struct CartesianPosition3dWithConfidence;
struct CartesianPosition3dWithConfidenceBuilder;

struct CircularShape;
struct CircularShapeBuilder;

struct ClosedLanes;
struct ClosedLanesBuilder;

struct CorrelationColumn;
struct CorrelationColumnBuilder;

struct Curvature;
struct CurvatureBuilder;

struct CauseCode;
struct CauseCodeBuilder;

struct DangerousGoodsExtended;
struct DangerousGoodsExtendedBuilder;

struct DeltaReferencePosition;
struct DeltaReferencePositionBuilder;

struct EnergyStorageType;
struct EnergyStorageTypeBuilder;

struct EllipticalShape;
struct EllipticalShapeBuilder;

struct EulerAnglesWithConfidence;
struct EulerAnglesWithConfidenceBuilder;

struct EventHistory;
struct EventHistoryBuilder;

struct EventPoint;
struct EventPointBuilder;

struct Heading;
struct HeadingBuilder;

struct IntersectionReferenceID;
struct IntersectionReferenceIDBuilder;

struct ItineraryPath;
struct ItineraryPathBuilder;

struct LongitudinalAcceleration;
struct LongitudinalAccelerationBuilder;

struct LongitudinalLanePosition;
struct LongitudinalLanePositionBuilder;

struct LowerTriangularPositiveSemidefiniteMatrix;
struct LowerTriangularPositiveSemidefiniteMatrixBuilder;

struct LowerTriangularPositiveSemidefiniteMatrixColumns;
struct LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder;

struct MapPosition;
struct MapPositionBuilder;

struct MapReference;
struct MapReferenceBuilder;

struct MatrixIncludedComponents;
struct MatrixIncludedComponentsBuilder;

struct MessageRateHz;
struct MessageRateHzBuilder;

struct MessageSegmentationInfo;
struct MessageSegmentationInfoBuilder;

struct ObjectClass;
struct ObjectClassBuilder;

struct ObjectClassWithConfidence;
struct ObjectClassWithConfidenceBuilder;

struct ObjectDimension;
struct ObjectDimensionBuilder;

struct OtherSubClass;
struct OtherSubClassBuilder;

struct PolygonalShape;
struct PolygonalShapeBuilder;

struct PositionConfidenceEllipse;
struct PositionConfidenceEllipseBuilder;

struct RadialShape;
struct RadialShapeBuilder;

struct RadialShapes;
struct RadialShapesBuilder;

struct RadialShapeDetails;
struct RadialShapeDetailsBuilder;

struct RectangularShape;
struct RectangularShapeBuilder;

struct ReferenceDenms;
struct ReferenceDenmsBuilder;

struct ReferencePosition;
struct ReferencePositionBuilder;

struct RestrictedTypes;
struct RestrictedTypesBuilder;

struct RoadSegmentReferenceID;
struct RoadSegmentReferenceIDBuilder;

struct Shape;
struct ShapeBuilder;

struct Speed;
struct SpeedBuilder;

struct VehicleIdentification;
struct VehicleIdentificationBuilder;

struct VehicleLength;
struct VehicleLengthBuilder;

struct VehicleWidth;
struct VehicleWidthBuilder;

struct VelocityCartesian;
struct VelocityCartesianBuilder;

struct VelocityComponent;
struct VelocityComponentBuilder;

struct VelocityPolarWithZ;
struct VelocityPolarWithZBuilder;

struct Velocity3dWithConfidence;
struct Velocity3dWithConfidenceBuilder;

struct VruClusterProfiles;
struct VruClusterProfilesBuilder;

struct VruClusterInformation;
struct VruClusterInformationBuilder;

struct VruProfileAndSubprofile;
struct VruProfileAndSubprofileBuilder;

struct Wgs84Angle;
struct Wgs84AngleBuilder;

struct YawRate;
struct YawRateBuilder;

enum Status : int32_t {
  Status_SUCCESS = 0,
  Status_FAILURE = 1,
  Status_UNKNOWN = 2,
  Status_NOT_IMPLEMENTED = 3,
  Status_MIN = Status_SUCCESS,
  Status_MAX = Status_NOT_IMPLEMENTED
};

inline const Status (&EnumValuesStatus())[4] {
  static const Status values[] = {
    Status_SUCCESS,
    Status_FAILURE,
    Status_UNKNOWN,
    Status_NOT_IMPLEMENTED
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[5] = {
    "SUCCESS",
    "FAILURE",
    "UNKNOWN",
    "NOT_IMPLEMENTED",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (::flatbuffers::IsOutRange(e, Status_SUCCESS, Status_NOT_IMPLEMENTED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

enum LifecycleAction : int32_t {
  LifecycleAction_SOFT_RESET = 0,
  LifecycleAction_HARD_RESET = 1,
  LifecycleAction_MIN = LifecycleAction_SOFT_RESET,
  LifecycleAction_MAX = LifecycleAction_HARD_RESET
};

inline const LifecycleAction (&EnumValuesLifecycleAction())[2] {
  static const LifecycleAction values[] = {
    LifecycleAction_SOFT_RESET,
    LifecycleAction_HARD_RESET
  };
  return values;
}

inline const char * const *EnumNamesLifecycleAction() {
  static const char * const names[3] = {
    "SOFT_RESET",
    "HARD_RESET",
    nullptr
  };
  return names;
}

inline const char *EnumNameLifecycleAction(LifecycleAction e) {
  if (::flatbuffers::IsOutRange(e, LifecycleAction_SOFT_RESET, LifecycleAction_HARD_RESET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLifecycleAction()[index];
}

enum LinkLayerPriority : int32_t {
  LinkLayerPriority_BACKGROUND = 0,
  LinkLayerPriority_BEST_EFFORT = 1,
  LinkLayerPriority_VIDEO = 2,
  LinkLayerPriority_VOICE = 3,
  LinkLayerPriority_MIN = LinkLayerPriority_BACKGROUND,
  LinkLayerPriority_MAX = LinkLayerPriority_VOICE
};

inline const LinkLayerPriority (&EnumValuesLinkLayerPriority())[4] {
  static const LinkLayerPriority values[] = {
    LinkLayerPriority_BACKGROUND,
    LinkLayerPriority_BEST_EFFORT,
    LinkLayerPriority_VIDEO,
    LinkLayerPriority_VOICE
  };
  return values;
}

inline const char * const *EnumNamesLinkLayerPriority() {
  static const char * const names[5] = {
    "BACKGROUND",
    "BEST_EFFORT",
    "VIDEO",
    "VOICE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLinkLayerPriority(LinkLayerPriority e) {
  if (::flatbuffers::IsOutRange(e, LinkLayerPriority_BACKGROUND, LinkLayerPriority_VOICE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLinkLayerPriority()[index];
}

enum AngularSpeedConfidence : int32_t {
  AngularSpeedConfidence_ASC_DEGSEC_01 = 0,
  AngularSpeedConfidence_ASC_DEGSEC_02 = 1,
  AngularSpeedConfidence_ASC_DEGSEC_05 = 2,
  AngularSpeedConfidence_ASC_DEGSEC_10 = 3,
  AngularSpeedConfidence_ASC_DEGSEC_20 = 4,
  AngularSpeedConfidence_ASC_DEGSEC_50 = 5,
  AngularSpeedConfidence_ASC_OUTOFRANGE = 6,
  AngularSpeedConfidence_ASC_UNAVAILABLE = 7,
  AngularSpeedConfidence_MIN = AngularSpeedConfidence_ASC_DEGSEC_01,
  AngularSpeedConfidence_MAX = AngularSpeedConfidence_ASC_UNAVAILABLE
};

inline const AngularSpeedConfidence (&EnumValuesAngularSpeedConfidence())[8] {
  static const AngularSpeedConfidence values[] = {
    AngularSpeedConfidence_ASC_DEGSEC_01,
    AngularSpeedConfidence_ASC_DEGSEC_02,
    AngularSpeedConfidence_ASC_DEGSEC_05,
    AngularSpeedConfidence_ASC_DEGSEC_10,
    AngularSpeedConfidence_ASC_DEGSEC_20,
    AngularSpeedConfidence_ASC_DEGSEC_50,
    AngularSpeedConfidence_ASC_OUTOFRANGE,
    AngularSpeedConfidence_ASC_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesAngularSpeedConfidence() {
  static const char * const names[9] = {
    "ASC_DEGSEC_01",
    "ASC_DEGSEC_02",
    "ASC_DEGSEC_05",
    "ASC_DEGSEC_10",
    "ASC_DEGSEC_20",
    "ASC_DEGSEC_50",
    "ASC_OUTOFRANGE",
    "ASC_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAngularSpeedConfidence(AngularSpeedConfidence e) {
  if (::flatbuffers::IsOutRange(e, AngularSpeedConfidence_ASC_DEGSEC_01, AngularSpeedConfidence_ASC_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAngularSpeedConfidence()[index];
}

enum CurvatureCalculationMode : int32_t {
  CurvatureCalculationMode_CCM_YAWRATEUSED = 0,
  CurvatureCalculationMode_CCM_YAWRATENOTUSED = 1,
  CurvatureCalculationMode_CCM_UNAVAILABLE = 2,
  CurvatureCalculationMode_MIN = CurvatureCalculationMode_CCM_YAWRATEUSED,
  CurvatureCalculationMode_MAX = CurvatureCalculationMode_CCM_UNAVAILABLE
};

inline const CurvatureCalculationMode (&EnumValuesCurvatureCalculationMode())[3] {
  static const CurvatureCalculationMode values[] = {
    CurvatureCalculationMode_CCM_YAWRATEUSED,
    CurvatureCalculationMode_CCM_YAWRATENOTUSED,
    CurvatureCalculationMode_CCM_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesCurvatureCalculationMode() {
  static const char * const names[4] = {
    "CCM_YAWRATEUSED",
    "CCM_YAWRATENOTUSED",
    "CCM_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurvatureCalculationMode(CurvatureCalculationMode e) {
  if (::flatbuffers::IsOutRange(e, CurvatureCalculationMode_CCM_YAWRATEUSED, CurvatureCalculationMode_CCM_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurvatureCalculationMode()[index];
}

enum CauseCodeType : int32_t {
  CauseCodeType_CCT_UNKNOWN = 0,
  CauseCodeType_CCT_TRAFFICCONDITION = 1,
  CauseCodeType_CCT_ACCIDENT = 2,
  CauseCodeType_CCT_ROADWORKS = 3,
  CauseCodeType_CCT_IMPASSABILITY = 5,
  CauseCodeType_CCT_ADVERSEWEATHERCONDITION_ADHESION = 6,
  CauseCodeType_CCT_AQUAPLANING = 7,
  CauseCodeType_CCT_HAZARDOUSLOCATION_SURFACECONDITION = 9,
  CauseCodeType_CCT_HAZARDOUSLOCATION_OBSTACLEONTHEROAD = 10,
  CauseCodeType_CCT_HAZARDOUSLOCATION_ANIMALONTHEROAD = 11,
  CauseCodeType_CCT_HUMANPRESENCEONTHEROAD = 12,
  CauseCodeType_CCT_WRONGWAYDRIVING = 14,
  CauseCodeType_CCT_RESCUEANDRECOVERYWORKINPROGRESS = 15,
  CauseCodeType_CCT_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITION = 17,
  CauseCodeType_CCT_ADVERSEWEATHERCONDITION_VISIBILITY = 18,
  CauseCodeType_CCT_ADVERSEWEATHERCONDITION_PRECIPITATION = 19,
  CauseCodeType_CCT_VIOLENCE = 20,
  CauseCodeType_CCT_SLOWVEHICLE = 26,
  CauseCodeType_CCT_DANGEROUSENDOFQUEUE = 27,
  CauseCodeType_CCT_VEHICLEBREAKDOWN = 91,
  CauseCodeType_CCT_POSTCRASH = 92,
  CauseCodeType_CCT_HUMANPROBLEM = 93,
  CauseCodeType_CCT_STATIONARYVEHICLE = 94,
  CauseCodeType_CCT_EMERGENCYVEHICLEAPPROACHING = 95,
  CauseCodeType_CCT_HAZARDOUSLOCATION_DANGEROUSCURVE = 96,
  CauseCodeType_CCT_COLLISIONRISK = 97,
  CauseCodeType_CCT_SIGNALVIOLATION = 98,
  CauseCodeType_CCT_DANGEROUSSITUATION = 99,
  CauseCodeType_CCT_RAILWAYLEVELCROSSING = 100,
  CauseCodeType_MIN = CauseCodeType_CCT_UNKNOWN,
  CauseCodeType_MAX = CauseCodeType_CCT_RAILWAYLEVELCROSSING
};

inline const CauseCodeType (&EnumValuesCauseCodeType())[29] {
  static const CauseCodeType values[] = {
    CauseCodeType_CCT_UNKNOWN,
    CauseCodeType_CCT_TRAFFICCONDITION,
    CauseCodeType_CCT_ACCIDENT,
    CauseCodeType_CCT_ROADWORKS,
    CauseCodeType_CCT_IMPASSABILITY,
    CauseCodeType_CCT_ADVERSEWEATHERCONDITION_ADHESION,
    CauseCodeType_CCT_AQUAPLANING,
    CauseCodeType_CCT_HAZARDOUSLOCATION_SURFACECONDITION,
    CauseCodeType_CCT_HAZARDOUSLOCATION_OBSTACLEONTHEROAD,
    CauseCodeType_CCT_HAZARDOUSLOCATION_ANIMALONTHEROAD,
    CauseCodeType_CCT_HUMANPRESENCEONTHEROAD,
    CauseCodeType_CCT_WRONGWAYDRIVING,
    CauseCodeType_CCT_RESCUEANDRECOVERYWORKINPROGRESS,
    CauseCodeType_CCT_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITION,
    CauseCodeType_CCT_ADVERSEWEATHERCONDITION_VISIBILITY,
    CauseCodeType_CCT_ADVERSEWEATHERCONDITION_PRECIPITATION,
    CauseCodeType_CCT_VIOLENCE,
    CauseCodeType_CCT_SLOWVEHICLE,
    CauseCodeType_CCT_DANGEROUSENDOFQUEUE,
    CauseCodeType_CCT_VEHICLEBREAKDOWN,
    CauseCodeType_CCT_POSTCRASH,
    CauseCodeType_CCT_HUMANPROBLEM,
    CauseCodeType_CCT_STATIONARYVEHICLE,
    CauseCodeType_CCT_EMERGENCYVEHICLEAPPROACHING,
    CauseCodeType_CCT_HAZARDOUSLOCATION_DANGEROUSCURVE,
    CauseCodeType_CCT_COLLISIONRISK,
    CauseCodeType_CCT_SIGNALVIOLATION,
    CauseCodeType_CCT_DANGEROUSSITUATION,
    CauseCodeType_CCT_RAILWAYLEVELCROSSING
  };
  return values;
}

inline const char * const *EnumNamesCauseCodeType() {
  static const char * const names[102] = {
    "CCT_UNKNOWN",
    "CCT_TRAFFICCONDITION",
    "CCT_ACCIDENT",
    "CCT_ROADWORKS",
    "",
    "CCT_IMPASSABILITY",
    "CCT_ADVERSEWEATHERCONDITION_ADHESION",
    "CCT_AQUAPLANING",
    "",
    "CCT_HAZARDOUSLOCATION_SURFACECONDITION",
    "CCT_HAZARDOUSLOCATION_OBSTACLEONTHEROAD",
    "CCT_HAZARDOUSLOCATION_ANIMALONTHEROAD",
    "CCT_HUMANPRESENCEONTHEROAD",
    "",
    "CCT_WRONGWAYDRIVING",
    "CCT_RESCUEANDRECOVERYWORKINPROGRESS",
    "",
    "CCT_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITION",
    "CCT_ADVERSEWEATHERCONDITION_VISIBILITY",
    "CCT_ADVERSEWEATHERCONDITION_PRECIPITATION",
    "CCT_VIOLENCE",
    "",
    "",
    "",
    "",
    "",
    "CCT_SLOWVEHICLE",
    "CCT_DANGEROUSENDOFQUEUE",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "CCT_VEHICLEBREAKDOWN",
    "CCT_POSTCRASH",
    "CCT_HUMANPROBLEM",
    "CCT_STATIONARYVEHICLE",
    "CCT_EMERGENCYVEHICLEAPPROACHING",
    "CCT_HAZARDOUSLOCATION_DANGEROUSCURVE",
    "CCT_COLLISIONRISK",
    "CCT_SIGNALVIOLATION",
    "CCT_DANGEROUSSITUATION",
    "CCT_RAILWAYLEVELCROSSING",
    nullptr
  };
  return names;
}

inline const char *EnumNameCauseCodeType(CauseCodeType e) {
  if (::flatbuffers::IsOutRange(e, CauseCodeType_CCT_UNKNOWN, CauseCodeType_CCT_RAILWAYLEVELCROSSING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCauseCodeType()[index];
}

enum DangerousGoodsBasic : int32_t {
  DangerousGoodsBasic_DGB_EXPLOSIVES1 = 0,
  DangerousGoodsBasic_DGB_EXPLOSIVES2 = 1,
  DangerousGoodsBasic_DGB_EXPLOSIVES3 = 2,
  DangerousGoodsBasic_DGB_EXPLOSIVES4 = 3,
  DangerousGoodsBasic_DGB_EXPLOSIVES5 = 4,
  DangerousGoodsBasic_DGB_EXPLOSIVES6 = 5,
  DangerousGoodsBasic_DGB_FLAMMABLEGASES = 6,
  DangerousGoodsBasic_DGB_NONFLAMMABLEGASES = 7,
  DangerousGoodsBasic_DGB_TOXICGASES = 8,
  DangerousGoodsBasic_DGB_FLAMMABLELIQUIDS = 9,
  DangerousGoodsBasic_DGB_FLAMMABLESOLIDS = 10,
  DangerousGoodsBasic_DGB_SUBSTANCESLIABLETOSPONTANEOUSCOMBUSTION = 11,
  DangerousGoodsBasic_DGB_SUBSTANCESEMITTINGFLAMMABLEGASESUPONCONTACTWITHWATER = 12,
  DangerousGoodsBasic_DGB_OXIDIZINGSUBSTANCES = 13,
  DangerousGoodsBasic_DGB_ORGANICPEROXIDES = 14,
  DangerousGoodsBasic_DGB_TOXICSUBSTANCES = 15,
  DangerousGoodsBasic_DGB_INFECTIOUSSUBSTANCES = 16,
  DangerousGoodsBasic_DGB_RADIOACTIVEMATERIAL = 17,
  DangerousGoodsBasic_DGB_CORROSIVESUBSTANCES = 18,
  DangerousGoodsBasic_DGB_MISCELLANEOUSDANGEROUSSUBSTANCES = 19,
  DangerousGoodsBasic_MIN = DangerousGoodsBasic_DGB_EXPLOSIVES1,
  DangerousGoodsBasic_MAX = DangerousGoodsBasic_DGB_MISCELLANEOUSDANGEROUSSUBSTANCES
};

inline const DangerousGoodsBasic (&EnumValuesDangerousGoodsBasic())[20] {
  static const DangerousGoodsBasic values[] = {
    DangerousGoodsBasic_DGB_EXPLOSIVES1,
    DangerousGoodsBasic_DGB_EXPLOSIVES2,
    DangerousGoodsBasic_DGB_EXPLOSIVES3,
    DangerousGoodsBasic_DGB_EXPLOSIVES4,
    DangerousGoodsBasic_DGB_EXPLOSIVES5,
    DangerousGoodsBasic_DGB_EXPLOSIVES6,
    DangerousGoodsBasic_DGB_FLAMMABLEGASES,
    DangerousGoodsBasic_DGB_NONFLAMMABLEGASES,
    DangerousGoodsBasic_DGB_TOXICGASES,
    DangerousGoodsBasic_DGB_FLAMMABLELIQUIDS,
    DangerousGoodsBasic_DGB_FLAMMABLESOLIDS,
    DangerousGoodsBasic_DGB_SUBSTANCESLIABLETOSPONTANEOUSCOMBUSTION,
    DangerousGoodsBasic_DGB_SUBSTANCESEMITTINGFLAMMABLEGASESUPONCONTACTWITHWATER,
    DangerousGoodsBasic_DGB_OXIDIZINGSUBSTANCES,
    DangerousGoodsBasic_DGB_ORGANICPEROXIDES,
    DangerousGoodsBasic_DGB_TOXICSUBSTANCES,
    DangerousGoodsBasic_DGB_INFECTIOUSSUBSTANCES,
    DangerousGoodsBasic_DGB_RADIOACTIVEMATERIAL,
    DangerousGoodsBasic_DGB_CORROSIVESUBSTANCES,
    DangerousGoodsBasic_DGB_MISCELLANEOUSDANGEROUSSUBSTANCES
  };
  return values;
}

inline const char * const *EnumNamesDangerousGoodsBasic() {
  static const char * const names[21] = {
    "DGB_EXPLOSIVES1",
    "DGB_EXPLOSIVES2",
    "DGB_EXPLOSIVES3",
    "DGB_EXPLOSIVES4",
    "DGB_EXPLOSIVES5",
    "DGB_EXPLOSIVES6",
    "DGB_FLAMMABLEGASES",
    "DGB_NONFLAMMABLEGASES",
    "DGB_TOXICGASES",
    "DGB_FLAMMABLELIQUIDS",
    "DGB_FLAMMABLESOLIDS",
    "DGB_SUBSTANCESLIABLETOSPONTANEOUSCOMBUSTION",
    "DGB_SUBSTANCESEMITTINGFLAMMABLEGASESUPONCONTACTWITHWATER",
    "DGB_OXIDIZINGSUBSTANCES",
    "DGB_ORGANICPEROXIDES",
    "DGB_TOXICSUBSTANCES",
    "DGB_INFECTIOUSSUBSTANCES",
    "DGB_RADIOACTIVEMATERIAL",
    "DGB_CORROSIVESUBSTANCES",
    "DGB_MISCELLANEOUSDANGEROUSSUBSTANCES",
    nullptr
  };
  return names;
}

inline const char *EnumNameDangerousGoodsBasic(DangerousGoodsBasic e) {
  if (::flatbuffers::IsOutRange(e, DangerousGoodsBasic_DGB_EXPLOSIVES1, DangerousGoodsBasic_DGB_MISCELLANEOUSDANGEROUSSUBSTANCES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDangerousGoodsBasic()[index];
}

enum DriveDirection : int32_t {
  DriveDirection_DD_FORWARD = 0,
  DriveDirection_DD_BACKWARD = 1,
  DriveDirection_DD_UNAVAILABLE = 2,
  DriveDirection_MIN = DriveDirection_DD_FORWARD,
  DriveDirection_MAX = DriveDirection_DD_UNAVAILABLE
};

inline const DriveDirection (&EnumValuesDriveDirection())[3] {
  static const DriveDirection values[] = {
    DriveDirection_DD_FORWARD,
    DriveDirection_DD_BACKWARD,
    DriveDirection_DD_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesDriveDirection() {
  static const char * const names[4] = {
    "DD_FORWARD",
    "DD_BACKWARD",
    "DD_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDriveDirection(DriveDirection e) {
  if (::flatbuffers::IsOutRange(e, DriveDirection_DD_FORWARD, DriveDirection_DD_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDriveDirection()[index];
}

enum HardShoulderStatus : int32_t {
  HardShoulderStatus_HSS_AVAILABLE_FOR_STOPPING = 0,
  HardShoulderStatus_HSS_CLOSED = 1,
  HardShoulderStatus_HSS_AVAILABLE_FOR_DRIVING = 2,
  HardShoulderStatus_MIN = HardShoulderStatus_HSS_AVAILABLE_FOR_STOPPING,
  HardShoulderStatus_MAX = HardShoulderStatus_HSS_AVAILABLE_FOR_DRIVING
};

inline const HardShoulderStatus (&EnumValuesHardShoulderStatus())[3] {
  static const HardShoulderStatus values[] = {
    HardShoulderStatus_HSS_AVAILABLE_FOR_STOPPING,
    HardShoulderStatus_HSS_CLOSED,
    HardShoulderStatus_HSS_AVAILABLE_FOR_DRIVING
  };
  return values;
}

inline const char * const *EnumNamesHardShoulderStatus() {
  static const char * const names[4] = {
    "HSS_AVAILABLE_FOR_STOPPING",
    "HSS_CLOSED",
    "HSS_AVAILABLE_FOR_DRIVING",
    nullptr
  };
  return names;
}

inline const char *EnumNameHardShoulderStatus(HardShoulderStatus e) {
  if (::flatbuffers::IsOutRange(e, HardShoulderStatus_HSS_AVAILABLE_FOR_STOPPING, HardShoulderStatus_HSS_AVAILABLE_FOR_DRIVING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHardShoulderStatus()[index];
}

enum LightBarSirenInUse : int32_t {
  LightBarSirenInUse_LS_LIGHTBAR_ACTIVATED = 0,
  LightBarSirenInUse_LS_SIREN_ACTIVATED = 1,
  LightBarSirenInUse_MIN = LightBarSirenInUse_LS_LIGHTBAR_ACTIVATED,
  LightBarSirenInUse_MAX = LightBarSirenInUse_LS_SIREN_ACTIVATED
};

inline const LightBarSirenInUse (&EnumValuesLightBarSirenInUse())[2] {
  static const LightBarSirenInUse values[] = {
    LightBarSirenInUse_LS_LIGHTBAR_ACTIVATED,
    LightBarSirenInUse_LS_SIREN_ACTIVATED
  };
  return values;
}

inline const char * const *EnumNamesLightBarSirenInUse() {
  static const char * const names[3] = {
    "LS_LIGHTBAR_ACTIVATED",
    "LS_SIREN_ACTIVATED",
    nullptr
  };
  return names;
}

inline const char *EnumNameLightBarSirenInUse(LightBarSirenInUse e) {
  if (::flatbuffers::IsOutRange(e, LightBarSirenInUse_LS_LIGHTBAR_ACTIVATED, LightBarSirenInUse_LS_SIREN_ACTIVATED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLightBarSirenInUse()[index];
}

enum PositioningSolutionType : int32_t {
  PositioningSolutionType_PST_NO_POSITIONING_SOLUTION = 0,
  PositioningSolutionType_PST_SGNSS = 1,
  PositioningSolutionType_PST_DGNSS = 2,
  PositioningSolutionType_PST_SGNSS_PLUS_DR = 3,
  PositioningSolutionType_PST_DGNSS_PLUS_DR = 4,
  PositioningSolutionType_PST_DR = 5,
  PositioningSolutionType_MIN = PositioningSolutionType_PST_NO_POSITIONING_SOLUTION,
  PositioningSolutionType_MAX = PositioningSolutionType_PST_DR
};

inline const PositioningSolutionType (&EnumValuesPositioningSolutionType())[6] {
  static const PositioningSolutionType values[] = {
    PositioningSolutionType_PST_NO_POSITIONING_SOLUTION,
    PositioningSolutionType_PST_SGNSS,
    PositioningSolutionType_PST_DGNSS,
    PositioningSolutionType_PST_SGNSS_PLUS_DR,
    PositioningSolutionType_PST_DGNSS_PLUS_DR,
    PositioningSolutionType_PST_DR
  };
  return values;
}

inline const char * const *EnumNamesPositioningSolutionType() {
  static const char * const names[7] = {
    "PST_NO_POSITIONING_SOLUTION",
    "PST_SGNSS",
    "PST_DGNSS",
    "PST_SGNSS_PLUS_DR",
    "PST_DGNSS_PLUS_DR",
    "PST_DR",
    nullptr
  };
  return names;
}

inline const char *EnumNamePositioningSolutionType(PositioningSolutionType e) {
  if (::flatbuffers::IsOutRange(e, PositioningSolutionType_PST_NO_POSITIONING_SOLUTION, PositioningSolutionType_PST_DR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPositioningSolutionType()[index];
}

enum PositionOfOccupants : int32_t {
  PositionOfOccupants_POS_OCC_ROW1_LEFT_OCCUPIED = 0,
  PositionOfOccupants_POS_OCC_ROW1_RIGHT_OCCUPIED = 1,
  PositionOfOccupants_POS_OCC_ROW1_MID_OCCUPIED = 2,
  PositionOfOccupants_POS_OCC_ROW1_NOT_DETECTABLE = 3,
  PositionOfOccupants_POS_OCC_ROW1_NOT_PRESENT = 4,
  PositionOfOccupants_POS_OCC_ROW2_LEFT_OCCUPIED = 5,
  PositionOfOccupants_POS_OCC_ROW2_RIGHT_OCCUPIED = 6,
  PositionOfOccupants_POS_OCC_ROW2_MID_OCCUPIED = 7,
  PositionOfOccupants_POS_OCC_ROW2_NOT_DETECTABLE = 8,
  PositionOfOccupants_POS_OCC_ROW2_NOT_PRESENT = 9,
  PositionOfOccupants_POS_OCC_ROW3_LEFT_OCCUPIED = 10,
  PositionOfOccupants_POS_OCC_ROW3_RIGHT_OCCUPIED = 11,
  PositionOfOccupants_POS_OCC_ROW3_MID_OCCUPIED = 12,
  PositionOfOccupants_POS_OCC_ROW3_NOT_DETECTABLE = 13,
  PositionOfOccupants_POS_OCC_ROW3_NOT_PRESENT = 14,
  PositionOfOccupants_POS_OCC_ROW4_LEFT_OCCUPIED = 15,
  PositionOfOccupants_POS_OCC_ROW4_RIGHT_OCCUPIED = 16,
  PositionOfOccupants_POS_OCC_ROW4_MID_OCCUPIED = 17,
  PositionOfOccupants_POS_OCC_ROW4_NOT_DETECTABLE = 18,
  PositionOfOccupants_POS_OCC_ROW4_NOT_PRESENT = 19,
  PositionOfOccupants_MIN = PositionOfOccupants_POS_OCC_ROW1_LEFT_OCCUPIED,
  PositionOfOccupants_MAX = PositionOfOccupants_POS_OCC_ROW4_NOT_PRESENT
};

inline const PositionOfOccupants (&EnumValuesPositionOfOccupants())[20] {
  static const PositionOfOccupants values[] = {
    PositionOfOccupants_POS_OCC_ROW1_LEFT_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW1_RIGHT_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW1_MID_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW1_NOT_DETECTABLE,
    PositionOfOccupants_POS_OCC_ROW1_NOT_PRESENT,
    PositionOfOccupants_POS_OCC_ROW2_LEFT_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW2_RIGHT_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW2_MID_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW2_NOT_DETECTABLE,
    PositionOfOccupants_POS_OCC_ROW2_NOT_PRESENT,
    PositionOfOccupants_POS_OCC_ROW3_LEFT_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW3_RIGHT_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW3_MID_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW3_NOT_DETECTABLE,
    PositionOfOccupants_POS_OCC_ROW3_NOT_PRESENT,
    PositionOfOccupants_POS_OCC_ROW4_LEFT_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW4_RIGHT_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW4_MID_OCCUPIED,
    PositionOfOccupants_POS_OCC_ROW4_NOT_DETECTABLE,
    PositionOfOccupants_POS_OCC_ROW4_NOT_PRESENT
  };
  return values;
}

inline const char * const *EnumNamesPositionOfOccupants() {
  static const char * const names[21] = {
    "POS_OCC_ROW1_LEFT_OCCUPIED",
    "POS_OCC_ROW1_RIGHT_OCCUPIED",
    "POS_OCC_ROW1_MID_OCCUPIED",
    "POS_OCC_ROW1_NOT_DETECTABLE",
    "POS_OCC_ROW1_NOT_PRESENT",
    "POS_OCC_ROW2_LEFT_OCCUPIED",
    "POS_OCC_ROW2_RIGHT_OCCUPIED",
    "POS_OCC_ROW2_MID_OCCUPIED",
    "POS_OCC_ROW2_NOT_DETECTABLE",
    "POS_OCC_ROW2_NOT_PRESENT",
    "POS_OCC_ROW3_LEFT_OCCUPIED",
    "POS_OCC_ROW3_RIGHT_OCCUPIED",
    "POS_OCC_ROW3_MID_OCCUPIED",
    "POS_OCC_ROW3_NOT_DETECTABLE",
    "POS_OCC_ROW3_NOT_PRESENT",
    "POS_OCC_ROW4_LEFT_OCCUPIED",
    "POS_OCC_ROW4_RIGHT_OCCUPIED",
    "POS_OCC_ROW4_MID_OCCUPIED",
    "POS_OCC_ROW4_NOT_DETECTABLE",
    "POS_OCC_ROW4_NOT_PRESENT",
    nullptr
  };
  return names;
}

inline const char *EnumNamePositionOfOccupants(PositionOfOccupants e) {
  if (::flatbuffers::IsOutRange(e, PositionOfOccupants_POS_OCC_ROW1_LEFT_OCCUPIED, PositionOfOccupants_POS_OCC_ROW4_NOT_PRESENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPositionOfOccupants()[index];
}

enum RelevanceDistance : int32_t {
  RelevanceDistance_REL_DIST_LESS_THAN_50M = 0,
  RelevanceDistance_REL_DIST_LESS_THAN_100M = 1,
  RelevanceDistance_REL_DIST_LESS_THAN_200M = 2,
  RelevanceDistance_REL_DIST_LESS_THAN_500M = 3,
  RelevanceDistance_REL_DIST_LESS_THAN_1000M = 4,
  RelevanceDistance_REL_DIST_LESS_THAN_5KM = 5,
  RelevanceDistance_REL_DIST_LESS_THAN_10KM = 6,
  RelevanceDistance_REL_DIST_OVER_10KM = 7,
  RelevanceDistance_MIN = RelevanceDistance_REL_DIST_LESS_THAN_50M,
  RelevanceDistance_MAX = RelevanceDistance_REL_DIST_OVER_10KM
};

inline const RelevanceDistance (&EnumValuesRelevanceDistance())[8] {
  static const RelevanceDistance values[] = {
    RelevanceDistance_REL_DIST_LESS_THAN_50M,
    RelevanceDistance_REL_DIST_LESS_THAN_100M,
    RelevanceDistance_REL_DIST_LESS_THAN_200M,
    RelevanceDistance_REL_DIST_LESS_THAN_500M,
    RelevanceDistance_REL_DIST_LESS_THAN_1000M,
    RelevanceDistance_REL_DIST_LESS_THAN_5KM,
    RelevanceDistance_REL_DIST_LESS_THAN_10KM,
    RelevanceDistance_REL_DIST_OVER_10KM
  };
  return values;
}

inline const char * const *EnumNamesRelevanceDistance() {
  static const char * const names[9] = {
    "REL_DIST_LESS_THAN_50M",
    "REL_DIST_LESS_THAN_100M",
    "REL_DIST_LESS_THAN_200M",
    "REL_DIST_LESS_THAN_500M",
    "REL_DIST_LESS_THAN_1000M",
    "REL_DIST_LESS_THAN_5KM",
    "REL_DIST_LESS_THAN_10KM",
    "REL_DIST_OVER_10KM",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelevanceDistance(RelevanceDistance e) {
  if (::flatbuffers::IsOutRange(e, RelevanceDistance_REL_DIST_LESS_THAN_50M, RelevanceDistance_REL_DIST_OVER_10KM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelevanceDistance()[index];
}

enum RelevanceTrafficDirection : int32_t {
  RelevanceTrafficDirection_REL_TD_ALL_TRAFFIC_DIRECTIONS = 0,
  RelevanceTrafficDirection_REL_TD_UPSTREAM_TRAFFIC = 1,
  RelevanceTrafficDirection_REL_TD_DOWNSTREAM_TRAFFIC = 2,
  RelevanceTrafficDirection_REL_TD_OPPOSITE_TRAFFIC = 3,
  RelevanceTrafficDirection_MIN = RelevanceTrafficDirection_REL_TD_ALL_TRAFFIC_DIRECTIONS,
  RelevanceTrafficDirection_MAX = RelevanceTrafficDirection_REL_TD_OPPOSITE_TRAFFIC
};

inline const RelevanceTrafficDirection (&EnumValuesRelevanceTrafficDirection())[4] {
  static const RelevanceTrafficDirection values[] = {
    RelevanceTrafficDirection_REL_TD_ALL_TRAFFIC_DIRECTIONS,
    RelevanceTrafficDirection_REL_TD_UPSTREAM_TRAFFIC,
    RelevanceTrafficDirection_REL_TD_DOWNSTREAM_TRAFFIC,
    RelevanceTrafficDirection_REL_TD_OPPOSITE_TRAFFIC
  };
  return values;
}

inline const char * const *EnumNamesRelevanceTrafficDirection() {
  static const char * const names[5] = {
    "REL_TD_ALL_TRAFFIC_DIRECTIONS",
    "REL_TD_UPSTREAM_TRAFFIC",
    "REL_TD_DOWNSTREAM_TRAFFIC",
    "REL_TD_OPPOSITE_TRAFFIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelevanceTrafficDirection(RelevanceTrafficDirection e) {
  if (::flatbuffers::IsOutRange(e, RelevanceTrafficDirection_REL_TD_ALL_TRAFFIC_DIRECTIONS, RelevanceTrafficDirection_REL_TD_OPPOSITE_TRAFFIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRelevanceTrafficDirection()[index];
}

enum RequestResponseIndication : int32_t {
  RequestResponseIndication_RRI_REQUEST = 0,
  RequestResponseIndication_RRI_RESPONSE = 1,
  RequestResponseIndication_MIN = RequestResponseIndication_RRI_REQUEST,
  RequestResponseIndication_MAX = RequestResponseIndication_RRI_RESPONSE
};

inline const RequestResponseIndication (&EnumValuesRequestResponseIndication())[2] {
  static const RequestResponseIndication values[] = {
    RequestResponseIndication_RRI_REQUEST,
    RequestResponseIndication_RRI_RESPONSE
  };
  return values;
}

inline const char * const *EnumNamesRequestResponseIndication() {
  static const char * const names[3] = {
    "RRI_REQUEST",
    "RRI_RESPONSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestResponseIndication(RequestResponseIndication e) {
  if (::flatbuffers::IsOutRange(e, RequestResponseIndication_RRI_REQUEST, RequestResponseIndication_RRI_RESPONSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestResponseIndication()[index];
}

enum RoadType : int32_t {
  RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES = 0,
  RoadType_RT_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES = 1,
  RoadType_RT_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES = 2,
  RoadType_RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES = 3,
  RoadType_MIN = RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES,
  RoadType_MAX = RoadType_RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES
};

inline const RoadType (&EnumValuesRoadType())[4] {
  static const RoadType values[] = {
    RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES,
    RoadType_RT_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES,
    RoadType_RT_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES,
    RoadType_RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES
  };
  return values;
}

inline const char * const *EnumNamesRoadType() {
  static const char * const names[5] = {
    "RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES",
    "RT_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES",
    "RT_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES",
    "RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoadType(RoadType e) {
  if (::flatbuffers::IsOutRange(e, RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES, RoadType_RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoadType()[index];
}

enum SensorType : int32_t {
  SensorType_SNSR_UNDEFINED = 0,
  SensorType_SNSR_RADAR = 1,
  SensorType_SNSR_LIDAR = 2,
  SensorType_SNSR_MONOVIDEO = 3,
  SensorType_SNSR_STEROVISION = 4,
  SensorType_SNSR_NIGHTVISION = 5,
  SensorType_SNSR_ULTRASONIC = 6,
  SensorType_SNSR_PMD = 7,
  SensorType_SNSR_INDUCTIONLOOP = 8,
  SensorType_SNSR_SPHERICALCAMERA = 9,
  SensorType_SNSR_UWB = 10,
  SensorType_SNSR_ACOUSTIC = 11,
  SensorType_SNSR_LOCALAGGREGATION = 12,
  SensorType_SNSR_ITSAGGREGATION = 13,
  SensorType_MIN = SensorType_SNSR_UNDEFINED,
  SensorType_MAX = SensorType_SNSR_ITSAGGREGATION
};

inline const SensorType (&EnumValuesSensorType())[14] {
  static const SensorType values[] = {
    SensorType_SNSR_UNDEFINED,
    SensorType_SNSR_RADAR,
    SensorType_SNSR_LIDAR,
    SensorType_SNSR_MONOVIDEO,
    SensorType_SNSR_STEROVISION,
    SensorType_SNSR_NIGHTVISION,
    SensorType_SNSR_ULTRASONIC,
    SensorType_SNSR_PMD,
    SensorType_SNSR_INDUCTIONLOOP,
    SensorType_SNSR_SPHERICALCAMERA,
    SensorType_SNSR_UWB,
    SensorType_SNSR_ACOUSTIC,
    SensorType_SNSR_LOCALAGGREGATION,
    SensorType_SNSR_ITSAGGREGATION
  };
  return values;
}

inline const char * const *EnumNamesSensorType() {
  static const char * const names[15] = {
    "SNSR_UNDEFINED",
    "SNSR_RADAR",
    "SNSR_LIDAR",
    "SNSR_MONOVIDEO",
    "SNSR_STEROVISION",
    "SNSR_NIGHTVISION",
    "SNSR_ULTRASONIC",
    "SNSR_PMD",
    "SNSR_INDUCTIONLOOP",
    "SNSR_SPHERICALCAMERA",
    "SNSR_UWB",
    "SNSR_ACOUSTIC",
    "SNSR_LOCALAGGREGATION",
    "SNSR_ITSAGGREGATION",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorType(SensorType e) {
  if (::flatbuffers::IsOutRange(e, SensorType_SNSR_UNDEFINED, SensorType_SNSR_ITSAGGREGATION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorType()[index];
}

enum StationarySince : int32_t {
  StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE = 0,
  StationarySince_STATIONARY_SINCE_LESSTHAN2MINUTES = 1,
  StationarySince_STATIONARY_SINCE_LESSTHAN15MINUTES = 2,
  StationarySince_STATIONARY_SINCE_EQUALORGREATER15MINUTES = 3,
  StationarySince_MIN = StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE,
  StationarySince_MAX = StationarySince_STATIONARY_SINCE_EQUALORGREATER15MINUTES
};

inline const StationarySince (&EnumValuesStationarySince())[4] {
  static const StationarySince values[] = {
    StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE,
    StationarySince_STATIONARY_SINCE_LESSTHAN2MINUTES,
    StationarySince_STATIONARY_SINCE_LESSTHAN15MINUTES,
    StationarySince_STATIONARY_SINCE_EQUALORGREATER15MINUTES
  };
  return values;
}

inline const char * const *EnumNamesStationarySince() {
  static const char * const names[5] = {
    "STATIONARY_SINCE_LESSTHAN1MINUTE",
    "STATIONARY_SINCE_LESSTHAN2MINUTES",
    "STATIONARY_SINCE_LESSTHAN15MINUTES",
    "STATIONARY_SINCE_EQUALORGREATER15MINUTES",
    nullptr
  };
  return names;
}

inline const char *EnumNameStationarySince(StationarySince e) {
  if (::flatbuffers::IsOutRange(e, StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE, StationarySince_STATIONARY_SINCE_EQUALORGREATER15MINUTES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStationarySince()[index];
}

enum StationType : int32_t {
  StationType_STN_TYPE_UNKNOWN = 0,
  StationType_STN_TYPE_PEDESTRIAN = 1,
  StationType_STN_TYPE_CYCLIST = 2,
  StationType_STN_TYPE_MOPED = 3,
  StationType_STN_TYPE_MOTORCYCLE = 4,
  StationType_STN_TYPE_PASSENGER_CAR = 5,
  StationType_STN_TYPE_BUS = 6,
  StationType_STN_TYPE_LIGHT_TRUCK = 7,
  StationType_STN_TYPE_HEAVY_TRUCK = 8,
  StationType_STN_TYPE_TRAILER = 9,
  StationType_STN_TYPE_SPECIAL_VEHICLE = 10,
  StationType_STN_TYPE_TRAM = 11,
  StationType_STN_TYPE_ROAD_SIDE_UNIT = 15,
  StationType_MIN = StationType_STN_TYPE_UNKNOWN,
  StationType_MAX = StationType_STN_TYPE_ROAD_SIDE_UNIT
};

inline const StationType (&EnumValuesStationType())[13] {
  static const StationType values[] = {
    StationType_STN_TYPE_UNKNOWN,
    StationType_STN_TYPE_PEDESTRIAN,
    StationType_STN_TYPE_CYCLIST,
    StationType_STN_TYPE_MOPED,
    StationType_STN_TYPE_MOTORCYCLE,
    StationType_STN_TYPE_PASSENGER_CAR,
    StationType_STN_TYPE_BUS,
    StationType_STN_TYPE_LIGHT_TRUCK,
    StationType_STN_TYPE_HEAVY_TRUCK,
    StationType_STN_TYPE_TRAILER,
    StationType_STN_TYPE_SPECIAL_VEHICLE,
    StationType_STN_TYPE_TRAM,
    StationType_STN_TYPE_ROAD_SIDE_UNIT
  };
  return values;
}

inline const char * const *EnumNamesStationType() {
  static const char * const names[17] = {
    "STN_TYPE_UNKNOWN",
    "STN_TYPE_PEDESTRIAN",
    "STN_TYPE_CYCLIST",
    "STN_TYPE_MOPED",
    "STN_TYPE_MOTORCYCLE",
    "STN_TYPE_PASSENGER_CAR",
    "STN_TYPE_BUS",
    "STN_TYPE_LIGHT_TRUCK",
    "STN_TYPE_HEAVY_TRUCK",
    "STN_TYPE_TRAILER",
    "STN_TYPE_SPECIAL_VEHICLE",
    "STN_TYPE_TRAM",
    "",
    "",
    "",
    "STN_TYPE_ROAD_SIDE_UNIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameStationType(StationType e) {
  if (::flatbuffers::IsOutRange(e, StationType_STN_TYPE_UNKNOWN, StationType_STN_TYPE_ROAD_SIDE_UNIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStationType()[index];
}

enum TrafficParticipantType : int32_t {
  TrafficParticipantType_TP_TYPE_UNKNOWN = 0,
  TrafficParticipantType_TP_TYPE_PEDESTRIAN = 1,
  TrafficParticipantType_TP_TYPE_CYCLIST = 2,
  TrafficParticipantType_TP_TYPE_MOPED = 3,
  TrafficParticipantType_TP_TYPE_MOTORCYCLE = 4,
  TrafficParticipantType_TP_TYPE_PASSENGERCAR = 5,
  TrafficParticipantType_TP_TYPE_BUS = 6,
  TrafficParticipantType_TP_TYPE_LIGHTTRUCK = 7,
  TrafficParticipantType_TP_TYPE_HEAVYTRUCK = 8,
  TrafficParticipantType_TP_TYPE_TRAILER = 9,
  TrafficParticipantType_TP_TYPE_SPECIALVEHICLE = 10,
  TrafficParticipantType_TP_TYPE_TRAM = 11,
  TrafficParticipantType_TP_TYPE_LIGHTVRUVEHICLE = 12,
  TrafficParticipantType_TP_TYPE_ANIMAL = 13,
  TrafficParticipantType_TP_TYPE_AGRICULTURAL = 14,
  TrafficParticipantType_TP_TYPE_ROADSIDEUNIT = 15,
  TrafficParticipantType_MIN = TrafficParticipantType_TP_TYPE_UNKNOWN,
  TrafficParticipantType_MAX = TrafficParticipantType_TP_TYPE_ROADSIDEUNIT
};

inline const TrafficParticipantType (&EnumValuesTrafficParticipantType())[16] {
  static const TrafficParticipantType values[] = {
    TrafficParticipantType_TP_TYPE_UNKNOWN,
    TrafficParticipantType_TP_TYPE_PEDESTRIAN,
    TrafficParticipantType_TP_TYPE_CYCLIST,
    TrafficParticipantType_TP_TYPE_MOPED,
    TrafficParticipantType_TP_TYPE_MOTORCYCLE,
    TrafficParticipantType_TP_TYPE_PASSENGERCAR,
    TrafficParticipantType_TP_TYPE_BUS,
    TrafficParticipantType_TP_TYPE_LIGHTTRUCK,
    TrafficParticipantType_TP_TYPE_HEAVYTRUCK,
    TrafficParticipantType_TP_TYPE_TRAILER,
    TrafficParticipantType_TP_TYPE_SPECIALVEHICLE,
    TrafficParticipantType_TP_TYPE_TRAM,
    TrafficParticipantType_TP_TYPE_LIGHTVRUVEHICLE,
    TrafficParticipantType_TP_TYPE_ANIMAL,
    TrafficParticipantType_TP_TYPE_AGRICULTURAL,
    TrafficParticipantType_TP_TYPE_ROADSIDEUNIT
  };
  return values;
}

inline const char * const *EnumNamesTrafficParticipantType() {
  static const char * const names[17] = {
    "TP_TYPE_UNKNOWN",
    "TP_TYPE_PEDESTRIAN",
    "TP_TYPE_CYCLIST",
    "TP_TYPE_MOPED",
    "TP_TYPE_MOTORCYCLE",
    "TP_TYPE_PASSENGERCAR",
    "TP_TYPE_BUS",
    "TP_TYPE_LIGHTTRUCK",
    "TP_TYPE_HEAVYTRUCK",
    "TP_TYPE_TRAILER",
    "TP_TYPE_SPECIALVEHICLE",
    "TP_TYPE_TRAM",
    "TP_TYPE_LIGHTVRUVEHICLE",
    "TP_TYPE_ANIMAL",
    "TP_TYPE_AGRICULTURAL",
    "TP_TYPE_ROADSIDEUNIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrafficParticipantType(TrafficParticipantType e) {
  if (::flatbuffers::IsOutRange(e, TrafficParticipantType_TP_TYPE_UNKNOWN, TrafficParticipantType_TP_TYPE_ROADSIDEUNIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrafficParticipantType()[index];
}

enum TrafficRule : int32_t {
  TrafficRule_TR_NOPASSING = 0,
  TrafficRule_TR_NOPASSINGFORTRUCKS = 1,
  TrafficRule_TR_PASSTORIGHT = 2,
  TrafficRule_TR_PASSTOLEFT = 3,
  TrafficRule_MIN = TrafficRule_TR_NOPASSING,
  TrafficRule_MAX = TrafficRule_TR_PASSTOLEFT
};

inline const TrafficRule (&EnumValuesTrafficRule())[4] {
  static const TrafficRule values[] = {
    TrafficRule_TR_NOPASSING,
    TrafficRule_TR_NOPASSINGFORTRUCKS,
    TrafficRule_TR_PASSTORIGHT,
    TrafficRule_TR_PASSTOLEFT
  };
  return values;
}

inline const char * const *EnumNamesTrafficRule() {
  static const char * const names[5] = {
    "TR_NOPASSING",
    "TR_NOPASSINGFORTRUCKS",
    "TR_PASSTORIGHT",
    "TR_PASSTOLEFT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrafficRule(TrafficRule e) {
  if (::flatbuffers::IsOutRange(e, TrafficRule_TR_NOPASSING, TrafficRule_TR_PASSTOLEFT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrafficRule()[index];
}

enum VehicleLengthConfidenceIndication : int32_t {
  VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT = 0,
  VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENT_WITH_KNOWN_LENGTH = 1,
  VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENT_WITH_UNKNOWN_LENGTH = 2,
  VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENCE_IS_UNKNOWN = 3,
  VehicleLengthConfidenceIndication_VLCI_UNAVAILABLE = 4,
  VehicleLengthConfidenceIndication_MIN = VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT,
  VehicleLengthConfidenceIndication_MAX = VehicleLengthConfidenceIndication_VLCI_UNAVAILABLE
};

inline const VehicleLengthConfidenceIndication (&EnumValuesVehicleLengthConfidenceIndication())[5] {
  static const VehicleLengthConfidenceIndication values[] = {
    VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT,
    VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENT_WITH_KNOWN_LENGTH,
    VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENT_WITH_UNKNOWN_LENGTH,
    VehicleLengthConfidenceIndication_VLCI_TRAILER_PRESENCE_IS_UNKNOWN,
    VehicleLengthConfidenceIndication_VLCI_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesVehicleLengthConfidenceIndication() {
  static const char * const names[6] = {
    "VLCI_NO_TRAILER_PRESENT",
    "VLCI_TRAILER_PRESENT_WITH_KNOWN_LENGTH",
    "VLCI_TRAILER_PRESENT_WITH_UNKNOWN_LENGTH",
    "VLCI_TRAILER_PRESENCE_IS_UNKNOWN",
    "VLCI_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameVehicleLengthConfidenceIndication(VehicleLengthConfidenceIndication e) {
  if (::flatbuffers::IsOutRange(e, VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT, VehicleLengthConfidenceIndication_VLCI_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVehicleLengthConfidenceIndication()[index];
}

enum VruSubProfilePedestrian : int32_t {
  VruSubProfilePedestrian_PED_UNAVAILABLE = 0,
  VruSubProfilePedestrian_PED_ORDINARY_PEDESTRIAN = 1,
  VruSubProfilePedestrian_PED_ROAD_WORKER = 2,
  VruSubProfilePedestrian_PED_FIRST_RESPONDER = 3,
  VruSubProfilePedestrian_PED_MAX = 15,
  VruSubProfilePedestrian_MIN = VruSubProfilePedestrian_PED_UNAVAILABLE,
  VruSubProfilePedestrian_MAX = VruSubProfilePedestrian_PED_MAX
};

inline const VruSubProfilePedestrian (&EnumValuesVruSubProfilePedestrian())[5] {
  static const VruSubProfilePedestrian values[] = {
    VruSubProfilePedestrian_PED_UNAVAILABLE,
    VruSubProfilePedestrian_PED_ORDINARY_PEDESTRIAN,
    VruSubProfilePedestrian_PED_ROAD_WORKER,
    VruSubProfilePedestrian_PED_FIRST_RESPONDER,
    VruSubProfilePedestrian_PED_MAX
  };
  return values;
}

inline const char * const *EnumNamesVruSubProfilePedestrian() {
  static const char * const names[17] = {
    "PED_UNAVAILABLE",
    "PED_ORDINARY_PEDESTRIAN",
    "PED_ROAD_WORKER",
    "PED_FIRST_RESPONDER",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "PED_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameVruSubProfilePedestrian(VruSubProfilePedestrian e) {
  if (::flatbuffers::IsOutRange(e, VruSubProfilePedestrian_PED_UNAVAILABLE, VruSubProfilePedestrian_PED_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVruSubProfilePedestrian()[index];
}

enum VruSubProfileBicyclist : int32_t {
  VruSubProfileBicyclist_BC_UNAVAILABLE = 0,
  VruSubProfileBicyclist_BC_BICYCLIST = 1,
  VruSubProfileBicyclist_BC_WHEELCHAIR_USER = 2,
  VruSubProfileBicyclist_BC_HORSE_AND_RIDER = 3,
  VruSubProfileBicyclist_BC_ROLLERSKATER = 4,
  VruSubProfileBicyclist_BC_E_SCOOTER = 5,
  VruSubProfileBicyclist_BC_PERSONAL_TRANSPORTER = 6,
  VruSubProfileBicyclist_BC_PEDELEC = 7,
  VruSubProfileBicyclist_BC_SPEED_PEDELEC = 8,
  VruSubProfileBicyclist_BC_MAX = 15,
  VruSubProfileBicyclist_MIN = VruSubProfileBicyclist_BC_UNAVAILABLE,
  VruSubProfileBicyclist_MAX = VruSubProfileBicyclist_BC_MAX
};

inline const VruSubProfileBicyclist (&EnumValuesVruSubProfileBicyclist())[10] {
  static const VruSubProfileBicyclist values[] = {
    VruSubProfileBicyclist_BC_UNAVAILABLE,
    VruSubProfileBicyclist_BC_BICYCLIST,
    VruSubProfileBicyclist_BC_WHEELCHAIR_USER,
    VruSubProfileBicyclist_BC_HORSE_AND_RIDER,
    VruSubProfileBicyclist_BC_ROLLERSKATER,
    VruSubProfileBicyclist_BC_E_SCOOTER,
    VruSubProfileBicyclist_BC_PERSONAL_TRANSPORTER,
    VruSubProfileBicyclist_BC_PEDELEC,
    VruSubProfileBicyclist_BC_SPEED_PEDELEC,
    VruSubProfileBicyclist_BC_MAX
  };
  return values;
}

inline const char * const *EnumNamesVruSubProfileBicyclist() {
  static const char * const names[17] = {
    "BC_UNAVAILABLE",
    "BC_BICYCLIST",
    "BC_WHEELCHAIR_USER",
    "BC_HORSE_AND_RIDER",
    "BC_ROLLERSKATER",
    "BC_E_SCOOTER",
    "BC_PERSONAL_TRANSPORTER",
    "BC_PEDELEC",
    "BC_SPEED_PEDELEC",
    "",
    "",
    "",
    "",
    "",
    "",
    "BC_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameVruSubProfileBicyclist(VruSubProfileBicyclist e) {
  if (::flatbuffers::IsOutRange(e, VruSubProfileBicyclist_BC_UNAVAILABLE, VruSubProfileBicyclist_BC_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVruSubProfileBicyclist()[index];
}

enum VruSubProfileMotorcyclist : int32_t {
  VruSubProfileMotorcyclist_MC_UNAVAILABLE = 0,
  VruSubProfileMotorcyclist_MC_MOPED = 1,
  VruSubProfileMotorcyclist_MC_MOTORCYCLE = 2,
  VruSubProfileMotorcyclist_MC_MOTORCYCLE_AND_SIDECAR_RIGHT = 3,
  VruSubProfileMotorcyclist_MC_MOTORCYCLE_AND_SIDECAR_LEFT = 4,
  VruSubProfileMotorcyclist_MC_MAX = 15,
  VruSubProfileMotorcyclist_MIN = VruSubProfileMotorcyclist_MC_UNAVAILABLE,
  VruSubProfileMotorcyclist_MAX = VruSubProfileMotorcyclist_MC_MAX
};

inline const VruSubProfileMotorcyclist (&EnumValuesVruSubProfileMotorcyclist())[6] {
  static const VruSubProfileMotorcyclist values[] = {
    VruSubProfileMotorcyclist_MC_UNAVAILABLE,
    VruSubProfileMotorcyclist_MC_MOPED,
    VruSubProfileMotorcyclist_MC_MOTORCYCLE,
    VruSubProfileMotorcyclist_MC_MOTORCYCLE_AND_SIDECAR_RIGHT,
    VruSubProfileMotorcyclist_MC_MOTORCYCLE_AND_SIDECAR_LEFT,
    VruSubProfileMotorcyclist_MC_MAX
  };
  return values;
}

inline const char * const *EnumNamesVruSubProfileMotorcyclist() {
  static const char * const names[17] = {
    "MC_UNAVAILABLE",
    "MC_MOPED",
    "MC_MOTORCYCLE",
    "MC_MOTORCYCLE_AND_SIDECAR_RIGHT",
    "MC_MOTORCYCLE_AND_SIDECAR_LEFT",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "MC_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameVruSubProfileMotorcyclist(VruSubProfileMotorcyclist e) {
  if (::flatbuffers::IsOutRange(e, VruSubProfileMotorcyclist_MC_UNAVAILABLE, VruSubProfileMotorcyclist_MC_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVruSubProfileMotorcyclist()[index];
}

enum VruSubProfileAnimal : int32_t {
  VruSubProfileAnimal_AN_UNAVAILABLE = 0,
  VruSubProfileAnimal_AN_WILD_ANIMAL = 1,
  VruSubProfileAnimal_AN_FARM_ANIMAL = 2,
  VruSubProfileAnimal_AN_SERVICE_ANIMAL = 3,
  VruSubProfileAnimal_AN_MAX = 15,
  VruSubProfileAnimal_MIN = VruSubProfileAnimal_AN_UNAVAILABLE,
  VruSubProfileAnimal_MAX = VruSubProfileAnimal_AN_MAX
};

inline const VruSubProfileAnimal (&EnumValuesVruSubProfileAnimal())[5] {
  static const VruSubProfileAnimal values[] = {
    VruSubProfileAnimal_AN_UNAVAILABLE,
    VruSubProfileAnimal_AN_WILD_ANIMAL,
    VruSubProfileAnimal_AN_FARM_ANIMAL,
    VruSubProfileAnimal_AN_SERVICE_ANIMAL,
    VruSubProfileAnimal_AN_MAX
  };
  return values;
}

inline const char * const *EnumNamesVruSubProfileAnimal() {
  static const char * const names[17] = {
    "AN_UNAVAILABLE",
    "AN_WILD_ANIMAL",
    "AN_FARM_ANIMAL",
    "AN_SERVICE_ANIMAL",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "AN_MAX",
    nullptr
  };
  return names;
}

inline const char *EnumNameVruSubProfileAnimal(VruSubProfileAnimal e) {
  if (::flatbuffers::IsOutRange(e, VruSubProfileAnimal_AN_UNAVAILABLE, VruSubProfileAnimal_AN_MAX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVruSubProfileAnimal()[index];
}

enum YawRateConfidence : int32_t {
  YawRateConfidence_YRC_DEGSEC_000_01 = 0,
  YawRateConfidence_YRC_DEGSEC_000_05 = 1,
  YawRateConfidence_YRC_DEGSEC_000_10 = 2,
  YawRateConfidence_YRC_DEGSEC_001_00 = 3,
  YawRateConfidence_YRC_DEGSEC_005_00 = 4,
  YawRateConfidence_YRC_DEGSEC_010_00 = 5,
  YawRateConfidence_YRC_DEGSEC_100_00 = 6,
  YawRateConfidence_YRC_OUTOFRANGE = 7,
  YawRateConfidence_YRC_UNAVAILABLE = 8,
  YawRateConfidence_MIN = YawRateConfidence_YRC_DEGSEC_000_01,
  YawRateConfidence_MAX = YawRateConfidence_YRC_UNAVAILABLE
};

inline const YawRateConfidence (&EnumValuesYawRateConfidence())[9] {
  static const YawRateConfidence values[] = {
    YawRateConfidence_YRC_DEGSEC_000_01,
    YawRateConfidence_YRC_DEGSEC_000_05,
    YawRateConfidence_YRC_DEGSEC_000_10,
    YawRateConfidence_YRC_DEGSEC_001_00,
    YawRateConfidence_YRC_DEGSEC_005_00,
    YawRateConfidence_YRC_DEGSEC_010_00,
    YawRateConfidence_YRC_DEGSEC_100_00,
    YawRateConfidence_YRC_OUTOFRANGE,
    YawRateConfidence_YRC_UNAVAILABLE
  };
  return values;
}

inline const char * const *EnumNamesYawRateConfidence() {
  static const char * const names[10] = {
    "YRC_DEGSEC_000_01",
    "YRC_DEGSEC_000_05",
    "YRC_DEGSEC_000_10",
    "YRC_DEGSEC_001_00",
    "YRC_DEGSEC_005_00",
    "YRC_DEGSEC_010_00",
    "YRC_DEGSEC_100_00",
    "YRC_OUTOFRANGE",
    "YRC_UNAVAILABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameYawRateConfidence(YawRateConfidence e) {
  if (::flatbuffers::IsOutRange(e, YawRateConfidence_YRC_DEGSEC_000_01, YawRateConfidence_YRC_UNAVAILABLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesYawRateConfidence()[index];
}

enum FacilityLayerMessage : uint8_t {
  FacilityLayerMessage_NONE = 0,
  FacilityLayerMessage_CAMessage = 1,
  FacilityLayerMessage_CPMessage = 2,
  FacilityLayerMessage_MIN = FacilityLayerMessage_NONE,
  FacilityLayerMessage_MAX = FacilityLayerMessage_CPMessage
};

inline const FacilityLayerMessage (&EnumValuesFacilityLayerMessage())[3] {
  static const FacilityLayerMessage values[] = {
    FacilityLayerMessage_NONE,
    FacilityLayerMessage_CAMessage,
    FacilityLayerMessage_CPMessage
  };
  return values;
}

inline const char * const *EnumNamesFacilityLayerMessage() {
  static const char * const names[4] = {
    "NONE",
    "CAMessage",
    "CPMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameFacilityLayerMessage(FacilityLayerMessage e) {
  if (::flatbuffers::IsOutRange(e, FacilityLayerMessage_NONE, FacilityLayerMessage_CPMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFacilityLayerMessage()[index];
}

template<typename T> struct FacilityLayerMessageTraits {
  static const FacilityLayerMessage enum_value = FacilityLayerMessage_NONE;
};

template<> struct FacilityLayerMessageTraits<Gos::CAMessage> {
  static const FacilityLayerMessage enum_value = FacilityLayerMessage_CAMessage;
};

template<> struct FacilityLayerMessageTraits<Gos::CPMessage> {
  static const FacilityLayerMessage enum_value = FacilityLayerMessage_CPMessage;
};

bool VerifyFacilityLayerMessage(::flatbuffers::Verifier &verifier, const void *obj, FacilityLayerMessage type);
bool VerifyFacilityLayerMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum GossipType : uint8_t {
  GossipType_NONE = 0,
  GossipType_ChannelBusyRatio = 1,
  GossipType_LinkLayerReception = 2,
  GossipType_FacilityLayerReception = 3,
  GossipType_MIN = GossipType_NONE,
  GossipType_MAX = GossipType_FacilityLayerReception
};

inline const GossipType (&EnumValuesGossipType())[4] {
  static const GossipType values[] = {
    GossipType_NONE,
    GossipType_ChannelBusyRatio,
    GossipType_LinkLayerReception,
    GossipType_FacilityLayerReception
  };
  return values;
}

inline const char * const *EnumNamesGossipType() {
  static const char * const names[5] = {
    "NONE",
    "ChannelBusyRatio",
    "LinkLayerReception",
    "FacilityLayerReception",
    nullptr
  };
  return names;
}

inline const char *EnumNameGossipType(GossipType e) {
  if (::flatbuffers::IsOutRange(e, GossipType_NONE, GossipType_FacilityLayerReception)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGossipType()[index];
}

template<typename T> struct GossipTypeTraits {
  static const GossipType enum_value = GossipType_NONE;
};

template<> struct GossipTypeTraits<Gos::ChannelBusyRatio> {
  static const GossipType enum_value = GossipType_ChannelBusyRatio;
};

template<> struct GossipTypeTraits<Gos::LinkLayerReception> {
  static const GossipType enum_value = GossipType_LinkLayerReception;
};

template<> struct GossipTypeTraits<Gos::FacilityLayerReception> {
  static const GossipType enum_value = GossipType_FacilityLayerReception;
};

bool VerifyGossipType(::flatbuffers::Verifier &verifier, const void *obj, GossipType type);
bool VerifyGossipTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Termination : int32_t {
  Termination_TRMNTN_IS_CANCELLATION = 0,
  Termination_TRMNTN_IS_NEGATION = 1,
  Termination_MIN = Termination_TRMNTN_IS_CANCELLATION,
  Termination_MAX = Termination_TRMNTN_IS_NEGATION
};

inline const Termination (&EnumValuesTermination())[2] {
  static const Termination values[] = {
    Termination_TRMNTN_IS_CANCELLATION,
    Termination_TRMNTN_IS_NEGATION
  };
  return values;
}

inline const char * const *EnumNamesTermination() {
  static const char * const names[3] = {
    "TRMNTN_IS_CANCELLATION",
    "TRMNTN_IS_NEGATION",
    nullptr
  };
  return names;
}

inline const char *EnumNameTermination(Termination e) {
  if (::flatbuffers::IsOutRange(e, Termination_TRMNTN_IS_CANCELLATION, Termination_TRMNTN_IS_NEGATION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTermination()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AccelerationComponent FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_;
  uint32_t confidence_;

 public:
  AccelerationComponent()
      : value_(0),
        confidence_(0) {
  }
  AccelerationComponent(int32_t _value, uint32_t _confidence)
      : value_(::flatbuffers::EndianScalar(_value)),
        confidence_(::flatbuffers::EndianScalar(_confidence)) {
  }
  int32_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
  uint32_t confidence() const {
    return ::flatbuffers::EndianScalar(confidence_);
  }
};
FLATBUFFERS_STRUCT_END(AccelerationComponent, 8);

struct CommandRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIFECYCLE = 4,
    VT_LINK_LAYER_TX = 6,
    VT_RADIO_CFG = 8,
    VT_FACILITIES_LAYER_TX = 10
  };
  Gos::LifecycleAction lifecycle() const {
    return static_cast<Gos::LifecycleAction>(GetField<int32_t>(VT_LIFECYCLE, 0));
  }
  const Gos::LinkLayerTransmission *link_layer_tx() const {
    return GetPointer<const Gos::LinkLayerTransmission *>(VT_LINK_LAYER_TX);
  }
  const Gos::RadioConfiguration *radio_cfg() const {
    return GetPointer<const Gos::RadioConfiguration *>(VT_RADIO_CFG);
  }
  const Gos::FacilityLayerTransmission *facilities_layer_tx() const {
    return GetPointer<const Gos::FacilityLayerTransmission *>(VT_FACILITIES_LAYER_TX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LIFECYCLE, 4) &&
           VerifyOffset(verifier, VT_LINK_LAYER_TX) &&
           verifier.VerifyTable(link_layer_tx()) &&
           VerifyOffset(verifier, VT_RADIO_CFG) &&
           verifier.VerifyTable(radio_cfg()) &&
           VerifyOffset(verifier, VT_FACILITIES_LAYER_TX) &&
           verifier.VerifyTable(facilities_layer_tx()) &&
           verifier.EndTable();
  }
};

struct CommandRequestBuilder {
  typedef CommandRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lifecycle(Gos::LifecycleAction lifecycle) {
    fbb_.AddElement<int32_t>(CommandRequest::VT_LIFECYCLE, static_cast<int32_t>(lifecycle), 0);
  }
  void add_link_layer_tx(::flatbuffers::Offset<Gos::LinkLayerTransmission> link_layer_tx) {
    fbb_.AddOffset(CommandRequest::VT_LINK_LAYER_TX, link_layer_tx);
  }
  void add_radio_cfg(::flatbuffers::Offset<Gos::RadioConfiguration> radio_cfg) {
    fbb_.AddOffset(CommandRequest::VT_RADIO_CFG, radio_cfg);
  }
  void add_facilities_layer_tx(::flatbuffers::Offset<Gos::FacilityLayerTransmission> facilities_layer_tx) {
    fbb_.AddOffset(CommandRequest::VT_FACILITIES_LAYER_TX, facilities_layer_tx);
  }
  explicit CommandRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandRequest> CreateCommandRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::LifecycleAction lifecycle = Gos::LifecycleAction_SOFT_RESET,
    ::flatbuffers::Offset<Gos::LinkLayerTransmission> link_layer_tx = 0,
    ::flatbuffers::Offset<Gos::RadioConfiguration> radio_cfg = 0,
    ::flatbuffers::Offset<Gos::FacilityLayerTransmission> facilities_layer_tx = 0) {
  CommandRequestBuilder builder_(_fbb);
  builder_.add_facilities_layer_tx(facilities_layer_tx);
  builder_.add_radio_cfg(radio_cfg);
  builder_.add_link_layer_tx(link_layer_tx);
  builder_.add_lifecycle(lifecycle);
  return builder_.Finish();
}

struct CommandResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_MESSAGE = 6,
    VT_DATA = 8
  };
  Gos::Status status() const {
    return static_cast<Gos::Status>(GetField<int32_t>(VT_STATUS, 0));
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  const Gos::CommandResponseData *data() const {
    return GetPointer<const Gos::CommandResponseData *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct CommandResponseBuilder {
  typedef CommandResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(Gos::Status status) {
    fbb_.AddElement<int32_t>(CommandResponse::VT_STATUS, static_cast<int32_t>(status), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(CommandResponse::VT_MESSAGE, message);
  }
  void add_data(::flatbuffers::Offset<Gos::CommandResponseData> data) {
    fbb_.AddOffset(CommandResponse::VT_DATA, data);
  }
  explicit CommandResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandResponse> CreateCommandResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::Status status = Gos::Status_SUCCESS,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    ::flatbuffers::Offset<Gos::CommandResponseData> data = 0) {
  CommandResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CommandResponse> CreateCommandResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::Status status = Gos::Status_SUCCESS,
    const char *message = nullptr,
    ::flatbuffers::Offset<Gos::CommandResponseData> data = 0) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return Gos::CreateCommandResponse(
      _fbb,
      status,
      message__,
      data);
}

struct CommandResponseData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandResponseDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIO_CFG = 4
  };
  const Gos::RadioConfiguration *radio_cfg() const {
    return GetPointer<const Gos::RadioConfiguration *>(VT_RADIO_CFG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RADIO_CFG) &&
           verifier.VerifyTable(radio_cfg()) &&
           verifier.EndTable();
  }
};

struct CommandResponseDataBuilder {
  typedef CommandResponseData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_radio_cfg(::flatbuffers::Offset<Gos::RadioConfiguration> radio_cfg) {
    fbb_.AddOffset(CommandResponseData::VT_RADIO_CFG, radio_cfg);
  }
  explicit CommandResponseDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandResponseData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandResponseData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandResponseData> CreateCommandResponseData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::RadioConfiguration> radio_cfg = 0) {
  CommandResponseDataBuilder builder_(_fbb);
  builder_.add_radio_cfg(radio_cfg);
  return builder_.Finish();
}

struct RadioConfiguration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadioConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_CHANNEL_FREQUENCY_MHZ = 6,
    VT_FILTER_UNICAST_DESTINATION = 8,
    VT_DEFAULT_TX_POWER_CBM = 10,
    VT_DEFAULT_TX_DATARATE_500KBPS = 12
  };
  const ::flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  uint32_t channel_frequency_mhz() const {
    return GetField<uint32_t>(VT_CHANNEL_FREQUENCY_MHZ, 0);
  }
  bool filter_unicast_destination() const {
    return GetField<uint8_t>(VT_FILTER_UNICAST_DESTINATION, 0) != 0;
  }
  int32_t default_tx_power_cbm() const {
    return GetField<int32_t>(VT_DEFAULT_TX_POWER_CBM, 0);
  }
  uint32_t default_tx_datarate_500kbps() const {
    return GetField<uint32_t>(VT_DEFAULT_TX_DATARATE_500KBPS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyVector(address()) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL_FREQUENCY_MHZ, 4) &&
           VerifyField<uint8_t>(verifier, VT_FILTER_UNICAST_DESTINATION, 1) &&
           VerifyField<int32_t>(verifier, VT_DEFAULT_TX_POWER_CBM, 4) &&
           VerifyField<uint32_t>(verifier, VT_DEFAULT_TX_DATARATE_500KBPS, 4) &&
           verifier.EndTable();
  }
};

struct RadioConfigurationBuilder {
  typedef RadioConfiguration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(RadioConfiguration::VT_ADDRESS, address);
  }
  void add_channel_frequency_mhz(uint32_t channel_frequency_mhz) {
    fbb_.AddElement<uint32_t>(RadioConfiguration::VT_CHANNEL_FREQUENCY_MHZ, channel_frequency_mhz, 0);
  }
  void add_filter_unicast_destination(bool filter_unicast_destination) {
    fbb_.AddElement<uint8_t>(RadioConfiguration::VT_FILTER_UNICAST_DESTINATION, static_cast<uint8_t>(filter_unicast_destination), 0);
  }
  void add_default_tx_power_cbm(int32_t default_tx_power_cbm) {
    fbb_.AddElement<int32_t>(RadioConfiguration::VT_DEFAULT_TX_POWER_CBM, default_tx_power_cbm, 0);
  }
  void add_default_tx_datarate_500kbps(uint32_t default_tx_datarate_500kbps) {
    fbb_.AddElement<uint32_t>(RadioConfiguration::VT_DEFAULT_TX_DATARATE_500KBPS, default_tx_datarate_500kbps, 0);
  }
  explicit RadioConfigurationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadioConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadioConfiguration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadioConfiguration> CreateRadioConfiguration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> address = 0,
    uint32_t channel_frequency_mhz = 0,
    bool filter_unicast_destination = false,
    int32_t default_tx_power_cbm = 0,
    uint32_t default_tx_datarate_500kbps = 0) {
  RadioConfigurationBuilder builder_(_fbb);
  builder_.add_default_tx_datarate_500kbps(default_tx_datarate_500kbps);
  builder_.add_default_tx_power_cbm(default_tx_power_cbm);
  builder_.add_channel_frequency_mhz(channel_frequency_mhz);
  builder_.add_address(address);
  builder_.add_filter_unicast_destination(filter_unicast_destination);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RadioConfiguration> CreateRadioConfigurationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *address = nullptr,
    uint32_t channel_frequency_mhz = 0,
    bool filter_unicast_destination = false,
    int32_t default_tx_power_cbm = 0,
    uint32_t default_tx_datarate_500kbps = 0) {
  auto address__ = address ? _fbb.CreateVector<uint8_t>(*address) : 0;
  return Gos::CreateRadioConfiguration(
      _fbb,
      address__,
      channel_frequency_mhz,
      filter_unicast_destination,
      default_tx_power_cbm,
      default_tx_datarate_500kbps);
}

struct LinkLayerTransmission FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinkLayerTransmissionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_DESTINATION = 6,
    VT_PRIORITY = 8,
    VT_CHANNEL = 10,
    VT_DATARATE_500KBPS = 12,
    VT_POWER_CBM = 14,
    VT_PAYLOAD = 16
  };
  const ::flatbuffers::Vector<uint8_t> *source() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SOURCE);
  }
  const ::flatbuffers::Vector<uint8_t> *destination() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DESTINATION);
  }
  Gos::LinkLayerPriority priority() const {
    return static_cast<Gos::LinkLayerPriority>(GetField<int32_t>(VT_PRIORITY, 0));
  }
  uint32_t channel() const {
    return GetField<uint32_t>(VT_CHANNEL, 0);
  }
  uint32_t datarate_500kbps() const {
    return GetField<uint32_t>(VT_DATARATE_500KBPS, 0);
  }
  int32_t power_cbm() const {
    return GetField<int32_t>(VT_POWER_CBM, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyVector(source()) &&
           VerifyOffsetRequired(verifier, VT_DESTINATION) &&
           verifier.VerifyVector(destination()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL, 4) &&
           VerifyField<uint32_t>(verifier, VT_DATARATE_500KBPS, 4) &&
           VerifyField<int32_t>(verifier, VT_POWER_CBM, 4) &&
           VerifyOffsetRequired(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct LinkLayerTransmissionBuilder {
  typedef LinkLayerTransmission Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source) {
    fbb_.AddOffset(LinkLayerTransmission::VT_SOURCE, source);
  }
  void add_destination(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination) {
    fbb_.AddOffset(LinkLayerTransmission::VT_DESTINATION, destination);
  }
  void add_priority(Gos::LinkLayerPriority priority) {
    fbb_.AddElement<int32_t>(LinkLayerTransmission::VT_PRIORITY, static_cast<int32_t>(priority), 0);
  }
  void add_channel(uint32_t channel) {
    fbb_.AddElement<uint32_t>(LinkLayerTransmission::VT_CHANNEL, channel, 0);
  }
  void add_datarate_500kbps(uint32_t datarate_500kbps) {
    fbb_.AddElement<uint32_t>(LinkLayerTransmission::VT_DATARATE_500KBPS, datarate_500kbps, 0);
  }
  void add_power_cbm(int32_t power_cbm) {
    fbb_.AddElement<int32_t>(LinkLayerTransmission::VT_POWER_CBM, power_cbm, 0);
  }
  void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(LinkLayerTransmission::VT_PAYLOAD, payload);
  }
  explicit LinkLayerTransmissionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinkLayerTransmission> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinkLayerTransmission>(end);
    fbb_.Required(o, LinkLayerTransmission::VT_DESTINATION);
    fbb_.Required(o, LinkLayerTransmission::VT_PAYLOAD);
    return o;
  }
};

inline ::flatbuffers::Offset<LinkLayerTransmission> CreateLinkLayerTransmission(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination = 0,
    Gos::LinkLayerPriority priority = Gos::LinkLayerPriority_BACKGROUND,
    uint32_t channel = 0,
    uint32_t datarate_500kbps = 0,
    int32_t power_cbm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
  LinkLayerTransmissionBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_power_cbm(power_cbm);
  builder_.add_datarate_500kbps(datarate_500kbps);
  builder_.add_channel(channel);
  builder_.add_priority(priority);
  builder_.add_destination(destination);
  builder_.add_source(source);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LinkLayerTransmission> CreateLinkLayerTransmissionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *source = nullptr,
    const std::vector<uint8_t> *destination = nullptr,
    Gos::LinkLayerPriority priority = Gos::LinkLayerPriority_BACKGROUND,
    uint32_t channel = 0,
    uint32_t datarate_500kbps = 0,
    int32_t power_cbm = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  auto source__ = source ? _fbb.CreateVector<uint8_t>(*source) : 0;
  auto destination__ = destination ? _fbb.CreateVector<uint8_t>(*destination) : 0;
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return Gos::CreateLinkLayerTransmission(
      _fbb,
      source__,
      destination__,
      priority,
      channel,
      datarate_500kbps,
      power_cbm,
      payload__);
}

struct LinkLayerReception FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinkLayerReceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_DESTINATION = 6,
    VT_CHANNEL = 8,
    VT_POWER_CBM = 10,
    VT_PAYLOAD = 12
  };
  const ::flatbuffers::Vector<uint8_t> *source() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SOURCE);
  }
  const ::flatbuffers::Vector<uint8_t> *destination() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DESTINATION);
  }
  uint32_t channel() const {
    return GetField<uint32_t>(VT_CHANNEL, 0);
  }
  int32_t power_cbm() const {
    return GetField<int32_t>(VT_POWER_CBM, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           verifier.VerifyVector(source()) &&
           VerifyOffsetRequired(verifier, VT_DESTINATION) &&
           verifier.VerifyVector(destination()) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL, 4) &&
           VerifyField<int32_t>(verifier, VT_POWER_CBM, 4) &&
           VerifyOffsetRequired(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct LinkLayerReceptionBuilder {
  typedef LinkLayerReception Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source) {
    fbb_.AddOffset(LinkLayerReception::VT_SOURCE, source);
  }
  void add_destination(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination) {
    fbb_.AddOffset(LinkLayerReception::VT_DESTINATION, destination);
  }
  void add_channel(uint32_t channel) {
    fbb_.AddElement<uint32_t>(LinkLayerReception::VT_CHANNEL, channel, 0);
  }
  void add_power_cbm(int32_t power_cbm) {
    fbb_.AddElement<int32_t>(LinkLayerReception::VT_POWER_CBM, power_cbm, 0);
  }
  void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(LinkLayerReception::VT_PAYLOAD, payload);
  }
  explicit LinkLayerReceptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinkLayerReception> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinkLayerReception>(end);
    fbb_.Required(o, LinkLayerReception::VT_SOURCE);
    fbb_.Required(o, LinkLayerReception::VT_DESTINATION);
    fbb_.Required(o, LinkLayerReception::VT_PAYLOAD);
    return o;
  }
};

inline ::flatbuffers::Offset<LinkLayerReception> CreateLinkLayerReception(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> source = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> destination = 0,
    uint32_t channel = 0,
    int32_t power_cbm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
  LinkLayerReceptionBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_power_cbm(power_cbm);
  builder_.add_channel(channel);
  builder_.add_destination(destination);
  builder_.add_source(source);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LinkLayerReception> CreateLinkLayerReceptionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *source = nullptr,
    const std::vector<uint8_t> *destination = nullptr,
    uint32_t channel = 0,
    int32_t power_cbm = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  auto source__ = source ? _fbb.CreateVector<uint8_t>(*source) : 0;
  auto destination__ = destination ? _fbb.CreateVector<uint8_t>(*destination) : 0;
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return Gos::CreateLinkLayerReception(
      _fbb,
      source__,
      destination__,
      channel,
      power_cbm,
      payload__);
}

struct FacilityLayerTransmission FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FacilityLayerTransmissionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  Gos::FacilityLayerMessage msg_type() const {
    return static_cast<Gos::FacilityLayerMessage>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const Gos::CAMessage *msg_as_CAMessage() const {
    return msg_type() == Gos::FacilityLayerMessage_CAMessage ? static_cast<const Gos::CAMessage *>(msg()) : nullptr;
  }
  const Gos::CPMessage *msg_as_CPMessage() const {
    return msg_type() == Gos::FacilityLayerMessage_CPMessage ? static_cast<const Gos::CPMessage *>(msg()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MSG) &&
           VerifyFacilityLayerMessage(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Gos::CAMessage *FacilityLayerTransmission::msg_as<Gos::CAMessage>() const {
  return msg_as_CAMessage();
}

template<> inline const Gos::CPMessage *FacilityLayerTransmission::msg_as<Gos::CPMessage>() const {
  return msg_as_CPMessage();
}

struct FacilityLayerTransmissionBuilder {
  typedef FacilityLayerTransmission Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_type(Gos::FacilityLayerMessage msg_type) {
    fbb_.AddElement<uint8_t>(FacilityLayerTransmission::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(::flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(FacilityLayerTransmission::VT_MSG, msg);
  }
  explicit FacilityLayerTransmissionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FacilityLayerTransmission> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FacilityLayerTransmission>(end);
    fbb_.Required(o, FacilityLayerTransmission::VT_MSG);
    return o;
  }
};

inline ::flatbuffers::Offset<FacilityLayerTransmission> CreateFacilityLayerTransmission(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::FacilityLayerMessage msg_type = Gos::FacilityLayerMessage_NONE,
    ::flatbuffers::Offset<void> msg = 0) {
  FacilityLayerTransmissionBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

struct FacilityLayerReception FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FacilityLayerReceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  Gos::FacilityLayerMessage msg_type() const {
    return static_cast<Gos::FacilityLayerMessage>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const Gos::CAMessage *msg_as_CAMessage() const {
    return msg_type() == Gos::FacilityLayerMessage_CAMessage ? static_cast<const Gos::CAMessage *>(msg()) : nullptr;
  }
  const Gos::CPMessage *msg_as_CPMessage() const {
    return msg_type() == Gos::FacilityLayerMessage_CPMessage ? static_cast<const Gos::CPMessage *>(msg()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MSG) &&
           VerifyFacilityLayerMessage(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Gos::CAMessage *FacilityLayerReception::msg_as<Gos::CAMessage>() const {
  return msg_as_CAMessage();
}

template<> inline const Gos::CPMessage *FacilityLayerReception::msg_as<Gos::CPMessage>() const {
  return msg_as_CPMessage();
}

struct FacilityLayerReceptionBuilder {
  typedef FacilityLayerReception Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_type(Gos::FacilityLayerMessage msg_type) {
    fbb_.AddElement<uint8_t>(FacilityLayerReception::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(::flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(FacilityLayerReception::VT_MSG, msg);
  }
  explicit FacilityLayerReceptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FacilityLayerReception> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FacilityLayerReception>(end);
    fbb_.Required(o, FacilityLayerReception::VT_MSG);
    return o;
  }
};

inline ::flatbuffers::Offset<FacilityLayerReception> CreateFacilityLayerReception(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::FacilityLayerMessage msg_type = Gos::FacilityLayerMessage_NONE,
    ::flatbuffers::Offset<void> msg = 0) {
  FacilityLayerReceptionBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

struct ChannelBusyRatio FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChannelBusyRatioBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUSY = 4,
    VT_TOTAL = 6
  };
  uint32_t busy() const {
    return GetField<uint32_t>(VT_BUSY, 0);
  }
  uint32_t total() const {
    return GetField<uint32_t>(VT_TOTAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BUSY, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL, 4) &&
           verifier.EndTable();
  }
};

struct ChannelBusyRatioBuilder {
  typedef ChannelBusyRatio Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_busy(uint32_t busy) {
    fbb_.AddElement<uint32_t>(ChannelBusyRatio::VT_BUSY, busy, 0);
  }
  void add_total(uint32_t total) {
    fbb_.AddElement<uint32_t>(ChannelBusyRatio::VT_TOTAL, total, 0);
  }
  explicit ChannelBusyRatioBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChannelBusyRatio> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChannelBusyRatio>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChannelBusyRatio> CreateChannelBusyRatio(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t busy = 0,
    uint32_t total = 0) {
  ChannelBusyRatioBuilder builder_(_fbb);
  builder_.add_total(total);
  builder_.add_busy(busy);
  return builder_.Finish();
}

struct GossipMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GossipMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GOSSIP_TYPE = 4,
    VT_GOSSIP = 6
  };
  Gos::GossipType gossip_type() const {
    return static_cast<Gos::GossipType>(GetField<uint8_t>(VT_GOSSIP_TYPE, 0));
  }
  const void *gossip() const {
    return GetPointer<const void *>(VT_GOSSIP);
  }
  template<typename T> const T *gossip_as() const;
  const Gos::ChannelBusyRatio *gossip_as_ChannelBusyRatio() const {
    return gossip_type() == Gos::GossipType_ChannelBusyRatio ? static_cast<const Gos::ChannelBusyRatio *>(gossip()) : nullptr;
  }
  const Gos::LinkLayerReception *gossip_as_LinkLayerReception() const {
    return gossip_type() == Gos::GossipType_LinkLayerReception ? static_cast<const Gos::LinkLayerReception *>(gossip()) : nullptr;
  }
  const Gos::FacilityLayerReception *gossip_as_FacilityLayerReception() const {
    return gossip_type() == Gos::GossipType_FacilityLayerReception ? static_cast<const Gos::FacilityLayerReception *>(gossip()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GOSSIP_TYPE, 1) &&
           VerifyOffset(verifier, VT_GOSSIP) &&
           VerifyGossipType(verifier, gossip(), gossip_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Gos::ChannelBusyRatio *GossipMessage::gossip_as<Gos::ChannelBusyRatio>() const {
  return gossip_as_ChannelBusyRatio();
}

template<> inline const Gos::LinkLayerReception *GossipMessage::gossip_as<Gos::LinkLayerReception>() const {
  return gossip_as_LinkLayerReception();
}

template<> inline const Gos::FacilityLayerReception *GossipMessage::gossip_as<Gos::FacilityLayerReception>() const {
  return gossip_as_FacilityLayerReception();
}

struct GossipMessageBuilder {
  typedef GossipMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gossip_type(Gos::GossipType gossip_type) {
    fbb_.AddElement<uint8_t>(GossipMessage::VT_GOSSIP_TYPE, static_cast<uint8_t>(gossip_type), 0);
  }
  void add_gossip(::flatbuffers::Offset<void> gossip) {
    fbb_.AddOffset(GossipMessage::VT_GOSSIP, gossip);
  }
  explicit GossipMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GossipMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GossipMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GossipMessage> CreateGossipMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::GossipType gossip_type = Gos::GossipType_NONE,
    ::flatbuffers::Offset<void> gossip = 0) {
  GossipMessageBuilder builder_(_fbb);
  builder_.add_gossip(gossip);
  builder_.add_gossip_type(gossip_type);
  return builder_.Finish();
}

struct ItsPduHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItsPduHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_MESSAGE_ID = 6,
    VT_STATION_ID = 8
  };
  uint32_t protocol_version() const {
    return GetField<uint32_t>(VT_PROTOCOL_VERSION, 0);
  }
  uint32_t message_id() const {
    return GetField<uint32_t>(VT_MESSAGE_ID, 0);
  }
  uint32_t station_id() const {
    return GetField<uint32_t>(VT_STATION_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROTOCOL_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_STATION_ID, 4) &&
           verifier.EndTable();
  }
};

struct ItsPduHeaderBuilder {
  typedef ItsPduHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocol_version(uint32_t protocol_version) {
    fbb_.AddElement<uint32_t>(ItsPduHeader::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_message_id(uint32_t message_id) {
    fbb_.AddElement<uint32_t>(ItsPduHeader::VT_MESSAGE_ID, message_id, 0);
  }
  void add_station_id(uint32_t station_id) {
    fbb_.AddElement<uint32_t>(ItsPduHeader::VT_STATION_ID, station_id, 0);
  }
  explicit ItsPduHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ItsPduHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ItsPduHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ItsPduHeader> CreateItsPduHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_version = 0,
    uint32_t message_id = 0,
    uint32_t station_id = 0) {
  ItsPduHeaderBuilder builder_(_fbb);
  builder_.add_station_id(station_id);
  builder_.add_message_id(message_id);
  builder_.add_protocol_version(protocol_version);
  return builder_.Finish();
}

struct CAMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CAMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_GENERATION_DELTA_TIME = 6,
    VT_STATION_TYPE = 8,
    VT_REFERENCE_POSITION = 10,
    VT_HIGH_FREQUENCY_CONTAINER = 12,
    VT_LOW_FREQUENCY_CONTAINER = 14
  };
  const Gos::ItsPduHeader *header() const {
    return GetPointer<const Gos::ItsPduHeader *>(VT_HEADER);
  }
  uint64_t generation_delta_time() const {
    return GetField<uint64_t>(VT_GENERATION_DELTA_TIME, 0);
  }
  Gos::StationType station_type() const {
    return static_cast<Gos::StationType>(GetField<int32_t>(VT_STATION_TYPE, 0));
  }
  const Gos::ReferencePosition *reference_position() const {
    return GetPointer<const Gos::ReferencePosition *>(VT_REFERENCE_POSITION);
  }
  const Gos::BasicVehicleContainerHighFrequency *high_frequency_container() const {
    return GetPointer<const Gos::BasicVehicleContainerHighFrequency *>(VT_HIGH_FREQUENCY_CONTAINER);
  }
  const Gos::BasicVehicleContainerLowFrequency *low_frequency_container() const {
    return GetPointer<const Gos::BasicVehicleContainerLowFrequency *>(VT_LOW_FREQUENCY_CONTAINER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint64_t>(verifier, VT_GENERATION_DELTA_TIME, 8) &&
           VerifyField<int32_t>(verifier, VT_STATION_TYPE, 4) &&
           VerifyOffsetRequired(verifier, VT_REFERENCE_POSITION) &&
           verifier.VerifyTable(reference_position()) &&
           VerifyOffsetRequired(verifier, VT_HIGH_FREQUENCY_CONTAINER) &&
           verifier.VerifyTable(high_frequency_container()) &&
           VerifyOffset(verifier, VT_LOW_FREQUENCY_CONTAINER) &&
           verifier.VerifyTable(low_frequency_container()) &&
           verifier.EndTable();
  }
};

struct CAMessageBuilder {
  typedef CAMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<Gos::ItsPduHeader> header) {
    fbb_.AddOffset(CAMessage::VT_HEADER, header);
  }
  void add_generation_delta_time(uint64_t generation_delta_time) {
    fbb_.AddElement<uint64_t>(CAMessage::VT_GENERATION_DELTA_TIME, generation_delta_time, 0);
  }
  void add_station_type(Gos::StationType station_type) {
    fbb_.AddElement<int32_t>(CAMessage::VT_STATION_TYPE, static_cast<int32_t>(station_type), 0);
  }
  void add_reference_position(::flatbuffers::Offset<Gos::ReferencePosition> reference_position) {
    fbb_.AddOffset(CAMessage::VT_REFERENCE_POSITION, reference_position);
  }
  void add_high_frequency_container(::flatbuffers::Offset<Gos::BasicVehicleContainerHighFrequency> high_frequency_container) {
    fbb_.AddOffset(CAMessage::VT_HIGH_FREQUENCY_CONTAINER, high_frequency_container);
  }
  void add_low_frequency_container(::flatbuffers::Offset<Gos::BasicVehicleContainerLowFrequency> low_frequency_container) {
    fbb_.AddOffset(CAMessage::VT_LOW_FREQUENCY_CONTAINER, low_frequency_container);
  }
  explicit CAMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CAMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CAMessage>(end);
    fbb_.Required(o, CAMessage::VT_HEADER);
    fbb_.Required(o, CAMessage::VT_REFERENCE_POSITION);
    fbb_.Required(o, CAMessage::VT_HIGH_FREQUENCY_CONTAINER);
    return o;
  }
};

inline ::flatbuffers::Offset<CAMessage> CreateCAMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::ItsPduHeader> header = 0,
    uint64_t generation_delta_time = 0,
    Gos::StationType station_type = Gos::StationType_STN_TYPE_UNKNOWN,
    ::flatbuffers::Offset<Gos::ReferencePosition> reference_position = 0,
    ::flatbuffers::Offset<Gos::BasicVehicleContainerHighFrequency> high_frequency_container = 0,
    ::flatbuffers::Offset<Gos::BasicVehicleContainerLowFrequency> low_frequency_container = 0) {
  CAMessageBuilder builder_(_fbb);
  builder_.add_generation_delta_time(generation_delta_time);
  builder_.add_low_frequency_container(low_frequency_container);
  builder_.add_high_frequency_container(high_frequency_container);
  builder_.add_reference_position(reference_position);
  builder_.add_station_type(station_type);
  builder_.add_header(header);
  return builder_.Finish();
}

struct BasicVehicleContainerHighFrequency FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BasicVehicleContainerHighFrequencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADING = 4,
    VT_SPEED = 6,
    VT_DRIVE_DIRECTION = 8,
    VT_VEHICLE_LENGTH = 10,
    VT_VEHICLE_WIDTH = 12,
    VT_LONGITUDINAL_ACCELERATION = 14,
    VT_CURVATURE = 16,
    VT_CURVATURE_CALCULATION_MODE = 18,
    VT_YAW_RATE = 20
  };
  const Gos::Heading *heading() const {
    return GetPointer<const Gos::Heading *>(VT_HEADING);
  }
  const Gos::Speed *speed() const {
    return GetPointer<const Gos::Speed *>(VT_SPEED);
  }
  Gos::DriveDirection drive_direction() const {
    return static_cast<Gos::DriveDirection>(GetField<int32_t>(VT_DRIVE_DIRECTION, 0));
  }
  const Gos::VehicleLength *vehicle_length() const {
    return GetPointer<const Gos::VehicleLength *>(VT_VEHICLE_LENGTH);
  }
  const Gos::VehicleWidth *vehicle_width() const {
    return GetPointer<const Gos::VehicleWidth *>(VT_VEHICLE_WIDTH);
  }
  const Gos::LongitudinalAcceleration *longitudinal_acceleration() const {
    return GetPointer<const Gos::LongitudinalAcceleration *>(VT_LONGITUDINAL_ACCELERATION);
  }
  const Gos::Curvature *curvature() const {
    return GetPointer<const Gos::Curvature *>(VT_CURVATURE);
  }
  Gos::CurvatureCalculationMode curvature_calculation_mode() const {
    return static_cast<Gos::CurvatureCalculationMode>(GetField<int32_t>(VT_CURVATURE_CALCULATION_MODE, 0));
  }
  const Gos::YawRate *yaw_rate() const {
    return GetPointer<const Gos::YawRate *>(VT_YAW_RATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADING) &&
           verifier.VerifyTable(heading()) &&
           VerifyOffsetRequired(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           VerifyField<int32_t>(verifier, VT_DRIVE_DIRECTION, 4) &&
           VerifyOffsetRequired(verifier, VT_VEHICLE_LENGTH) &&
           verifier.VerifyTable(vehicle_length()) &&
           VerifyOffsetRequired(verifier, VT_VEHICLE_WIDTH) &&
           verifier.VerifyTable(vehicle_width()) &&
           VerifyOffsetRequired(verifier, VT_LONGITUDINAL_ACCELERATION) &&
           verifier.VerifyTable(longitudinal_acceleration()) &&
           VerifyOffsetRequired(verifier, VT_CURVATURE) &&
           verifier.VerifyTable(curvature()) &&
           VerifyField<int32_t>(verifier, VT_CURVATURE_CALCULATION_MODE, 4) &&
           VerifyOffsetRequired(verifier, VT_YAW_RATE) &&
           verifier.VerifyTable(yaw_rate()) &&
           verifier.EndTable();
  }
};

struct BasicVehicleContainerHighFrequencyBuilder {
  typedef BasicVehicleContainerHighFrequency Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_heading(::flatbuffers::Offset<Gos::Heading> heading) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_HEADING, heading);
  }
  void add_speed(::flatbuffers::Offset<Gos::Speed> speed) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_SPEED, speed);
  }
  void add_drive_direction(Gos::DriveDirection drive_direction) {
    fbb_.AddElement<int32_t>(BasicVehicleContainerHighFrequency::VT_DRIVE_DIRECTION, static_cast<int32_t>(drive_direction), 0);
  }
  void add_vehicle_length(::flatbuffers::Offset<Gos::VehicleLength> vehicle_length) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_VEHICLE_LENGTH, vehicle_length);
  }
  void add_vehicle_width(::flatbuffers::Offset<Gos::VehicleWidth> vehicle_width) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_VEHICLE_WIDTH, vehicle_width);
  }
  void add_longitudinal_acceleration(::flatbuffers::Offset<Gos::LongitudinalAcceleration> longitudinal_acceleration) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_LONGITUDINAL_ACCELERATION, longitudinal_acceleration);
  }
  void add_curvature(::flatbuffers::Offset<Gos::Curvature> curvature) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_CURVATURE, curvature);
  }
  void add_curvature_calculation_mode(Gos::CurvatureCalculationMode curvature_calculation_mode) {
    fbb_.AddElement<int32_t>(BasicVehicleContainerHighFrequency::VT_CURVATURE_CALCULATION_MODE, static_cast<int32_t>(curvature_calculation_mode), 0);
  }
  void add_yaw_rate(::flatbuffers::Offset<Gos::YawRate> yaw_rate) {
    fbb_.AddOffset(BasicVehicleContainerHighFrequency::VT_YAW_RATE, yaw_rate);
  }
  explicit BasicVehicleContainerHighFrequencyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BasicVehicleContainerHighFrequency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BasicVehicleContainerHighFrequency>(end);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_HEADING);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_SPEED);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_VEHICLE_LENGTH);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_VEHICLE_WIDTH);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_LONGITUDINAL_ACCELERATION);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_CURVATURE);
    fbb_.Required(o, BasicVehicleContainerHighFrequency::VT_YAW_RATE);
    return o;
  }
};

inline ::flatbuffers::Offset<BasicVehicleContainerHighFrequency> CreateBasicVehicleContainerHighFrequency(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::Heading> heading = 0,
    ::flatbuffers::Offset<Gos::Speed> speed = 0,
    Gos::DriveDirection drive_direction = Gos::DriveDirection_DD_FORWARD,
    ::flatbuffers::Offset<Gos::VehicleLength> vehicle_length = 0,
    ::flatbuffers::Offset<Gos::VehicleWidth> vehicle_width = 0,
    ::flatbuffers::Offset<Gos::LongitudinalAcceleration> longitudinal_acceleration = 0,
    ::flatbuffers::Offset<Gos::Curvature> curvature = 0,
    Gos::CurvatureCalculationMode curvature_calculation_mode = Gos::CurvatureCalculationMode_CCM_YAWRATEUSED,
    ::flatbuffers::Offset<Gos::YawRate> yaw_rate = 0) {
  BasicVehicleContainerHighFrequencyBuilder builder_(_fbb);
  builder_.add_yaw_rate(yaw_rate);
  builder_.add_curvature_calculation_mode(curvature_calculation_mode);
  builder_.add_curvature(curvature);
  builder_.add_longitudinal_acceleration(longitudinal_acceleration);
  builder_.add_vehicle_width(vehicle_width);
  builder_.add_vehicle_length(vehicle_length);
  builder_.add_drive_direction(drive_direction);
  builder_.add_speed(speed);
  builder_.add_heading(heading);
  return builder_.Finish();
}

struct BasicVehicleContainerLowFrequency FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BasicVehicleContainerLowFrequencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMP2 = 4
  };
  uint32_t temp2() const {
    return GetField<uint32_t>(VT_TEMP2, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TEMP2, 4) &&
           verifier.EndTable();
  }
};

struct BasicVehicleContainerLowFrequencyBuilder {
  typedef BasicVehicleContainerLowFrequency Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_temp2(uint32_t temp2) {
    fbb_.AddElement<uint32_t>(BasicVehicleContainerLowFrequency::VT_TEMP2, temp2, 0);
  }
  explicit BasicVehicleContainerLowFrequencyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BasicVehicleContainerLowFrequency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BasicVehicleContainerLowFrequency>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BasicVehicleContainerLowFrequency> CreateBasicVehicleContainerLowFrequency(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t temp2 = 0) {
  BasicVehicleContainerLowFrequencyBuilder builder_(_fbb);
  builder_.add_temp2(temp2);
  return builder_.Finish();
}

struct CPMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CPMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_GENERATION_DELTA_TIME = 6,
    VT_MGMT_CONTAINER = 8,
    VT_CPM_PAYLOAD = 10
  };
  const Gos::ItsPduHeader *header() const {
    return GetPointer<const Gos::ItsPduHeader *>(VT_HEADER);
  }
  uint64_t generation_delta_time() const {
    return GetField<uint64_t>(VT_GENERATION_DELTA_TIME, 0);
  }
  const Gos::ManagementContainer *mgmt_container() const {
    return GetPointer<const Gos::ManagementContainer *>(VT_MGMT_CONTAINER);
  }
  const Gos::CpmPayload *cpm_payload() const {
    return GetPointer<const Gos::CpmPayload *>(VT_CPM_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint64_t>(verifier, VT_GENERATION_DELTA_TIME, 8) &&
           VerifyOffset(verifier, VT_MGMT_CONTAINER) &&
           verifier.VerifyTable(mgmt_container()) &&
           VerifyOffset(verifier, VT_CPM_PAYLOAD) &&
           verifier.VerifyTable(cpm_payload()) &&
           verifier.EndTable();
  }
};

struct CPMessageBuilder {
  typedef CPMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<Gos::ItsPduHeader> header) {
    fbb_.AddOffset(CPMessage::VT_HEADER, header);
  }
  void add_generation_delta_time(uint64_t generation_delta_time) {
    fbb_.AddElement<uint64_t>(CPMessage::VT_GENERATION_DELTA_TIME, generation_delta_time, 0);
  }
  void add_mgmt_container(::flatbuffers::Offset<Gos::ManagementContainer> mgmt_container) {
    fbb_.AddOffset(CPMessage::VT_MGMT_CONTAINER, mgmt_container);
  }
  void add_cpm_payload(::flatbuffers::Offset<Gos::CpmPayload> cpm_payload) {
    fbb_.AddOffset(CPMessage::VT_CPM_PAYLOAD, cpm_payload);
  }
  explicit CPMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CPMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CPMessage>(end);
    fbb_.Required(o, CPMessage::VT_HEADER);
    return o;
  }
};

inline ::flatbuffers::Offset<CPMessage> CreateCPMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::ItsPduHeader> header = 0,
    uint64_t generation_delta_time = 0,
    ::flatbuffers::Offset<Gos::ManagementContainer> mgmt_container = 0,
    ::flatbuffers::Offset<Gos::CpmPayload> cpm_payload = 0) {
  CPMessageBuilder builder_(_fbb);
  builder_.add_generation_delta_time(generation_delta_time);
  builder_.add_cpm_payload(cpm_payload);
  builder_.add_mgmt_container(mgmt_container);
  builder_.add_header(header);
  return builder_.Finish();
}

struct CpmPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CpmPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGINATING_STATIONS_CONTAINER = 4,
    VT_SENSOR_INFORMATION_CONTAINER = 6,
    VT_PERCEPTION_REGION_CONTAINER = 8,
    VT_PERCEIVED_OBJECT_CONTAINER = 10
  };
  const Gos::OriginatingStationsContainer *originating_stations_container() const {
    return GetPointer<const Gos::OriginatingStationsContainer *>(VT_ORIGINATING_STATIONS_CONTAINER);
  }
  const Gos::SensorInformationContainer *sensor_information_container() const {
    return GetPointer<const Gos::SensorInformationContainer *>(VT_SENSOR_INFORMATION_CONTAINER);
  }
  const Gos::PerceptionRegionContainer *perception_region_container() const {
    return GetPointer<const Gos::PerceptionRegionContainer *>(VT_PERCEPTION_REGION_CONTAINER);
  }
  const Gos::PerceivedObjectContainer *perceived_object_container() const {
    return GetPointer<const Gos::PerceivedObjectContainer *>(VT_PERCEIVED_OBJECT_CONTAINER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGINATING_STATIONS_CONTAINER) &&
           verifier.VerifyTable(originating_stations_container()) &&
           VerifyOffset(verifier, VT_SENSOR_INFORMATION_CONTAINER) &&
           verifier.VerifyTable(sensor_information_container()) &&
           VerifyOffset(verifier, VT_PERCEPTION_REGION_CONTAINER) &&
           verifier.VerifyTable(perception_region_container()) &&
           VerifyOffset(verifier, VT_PERCEIVED_OBJECT_CONTAINER) &&
           verifier.VerifyTable(perceived_object_container()) &&
           verifier.EndTable();
  }
};

struct CpmPayloadBuilder {
  typedef CpmPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_originating_stations_container(::flatbuffers::Offset<Gos::OriginatingStationsContainer> originating_stations_container) {
    fbb_.AddOffset(CpmPayload::VT_ORIGINATING_STATIONS_CONTAINER, originating_stations_container);
  }
  void add_sensor_information_container(::flatbuffers::Offset<Gos::SensorInformationContainer> sensor_information_container) {
    fbb_.AddOffset(CpmPayload::VT_SENSOR_INFORMATION_CONTAINER, sensor_information_container);
  }
  void add_perception_region_container(::flatbuffers::Offset<Gos::PerceptionRegionContainer> perception_region_container) {
    fbb_.AddOffset(CpmPayload::VT_PERCEPTION_REGION_CONTAINER, perception_region_container);
  }
  void add_perceived_object_container(::flatbuffers::Offset<Gos::PerceivedObjectContainer> perceived_object_container) {
    fbb_.AddOffset(CpmPayload::VT_PERCEIVED_OBJECT_CONTAINER, perceived_object_container);
  }
  explicit CpmPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CpmPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CpmPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CpmPayload> CreateCpmPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::OriginatingStationsContainer> originating_stations_container = 0,
    ::flatbuffers::Offset<Gos::SensorInformationContainer> sensor_information_container = 0,
    ::flatbuffers::Offset<Gos::PerceptionRegionContainer> perception_region_container = 0,
    ::flatbuffers::Offset<Gos::PerceivedObjectContainer> perceived_object_container = 0) {
  CpmPayloadBuilder builder_(_fbb);
  builder_.add_perceived_object_container(perceived_object_container);
  builder_.add_perception_region_container(perception_region_container);
  builder_.add_sensor_information_container(sensor_information_container);
  builder_.add_originating_stations_container(originating_stations_container);
  return builder_.Finish();
}

struct ManagementContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ManagementContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_TIME = 4,
    VT_REFERENCE_POSITION = 6,
    VT_SEGMENTATION_INFO = 8,
    VT_MESSAGE_RATE_RANGE = 10,
    VT_STATION_TYPE = 12
  };
  uint64_t reference_time() const {
    return GetField<uint64_t>(VT_REFERENCE_TIME, 0);
  }
  const Gos::ReferencePosition *reference_position() const {
    return GetPointer<const Gos::ReferencePosition *>(VT_REFERENCE_POSITION);
  }
  const Gos::MessageSegmentationInfo *segmentation_info() const {
    return GetPointer<const Gos::MessageSegmentationInfo *>(VT_SEGMENTATION_INFO);
  }
  const Gos::MessageRateRange *message_rate_range() const {
    return GetPointer<const Gos::MessageRateRange *>(VT_MESSAGE_RATE_RANGE);
  }
  Gos::StationType station_type() const {
    return static_cast<Gos::StationType>(GetField<int32_t>(VT_STATION_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REFERENCE_TIME, 8) &&
           VerifyOffsetRequired(verifier, VT_REFERENCE_POSITION) &&
           verifier.VerifyTable(reference_position()) &&
           VerifyOffset(verifier, VT_SEGMENTATION_INFO) &&
           verifier.VerifyTable(segmentation_info()) &&
           VerifyOffset(verifier, VT_MESSAGE_RATE_RANGE) &&
           verifier.VerifyTable(message_rate_range()) &&
           VerifyField<int32_t>(verifier, VT_STATION_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct ManagementContainerBuilder {
  typedef ManagementContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reference_time(uint64_t reference_time) {
    fbb_.AddElement<uint64_t>(ManagementContainer::VT_REFERENCE_TIME, reference_time, 0);
  }
  void add_reference_position(::flatbuffers::Offset<Gos::ReferencePosition> reference_position) {
    fbb_.AddOffset(ManagementContainer::VT_REFERENCE_POSITION, reference_position);
  }
  void add_segmentation_info(::flatbuffers::Offset<Gos::MessageSegmentationInfo> segmentation_info) {
    fbb_.AddOffset(ManagementContainer::VT_SEGMENTATION_INFO, segmentation_info);
  }
  void add_message_rate_range(::flatbuffers::Offset<Gos::MessageRateRange> message_rate_range) {
    fbb_.AddOffset(ManagementContainer::VT_MESSAGE_RATE_RANGE, message_rate_range);
  }
  void add_station_type(Gos::StationType station_type) {
    fbb_.AddElement<int32_t>(ManagementContainer::VT_STATION_TYPE, static_cast<int32_t>(station_type), 0);
  }
  explicit ManagementContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ManagementContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ManagementContainer>(end);
    fbb_.Required(o, ManagementContainer::VT_REFERENCE_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<ManagementContainer> CreateManagementContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t reference_time = 0,
    ::flatbuffers::Offset<Gos::ReferencePosition> reference_position = 0,
    ::flatbuffers::Offset<Gos::MessageSegmentationInfo> segmentation_info = 0,
    ::flatbuffers::Offset<Gos::MessageRateRange> message_rate_range = 0,
    Gos::StationType station_type = Gos::StationType_STN_TYPE_UNKNOWN) {
  ManagementContainerBuilder builder_(_fbb);
  builder_.add_reference_time(reference_time);
  builder_.add_station_type(station_type);
  builder_.add_message_rate_range(message_rate_range);
  builder_.add_segmentation_info(segmentation_info);
  builder_.add_reference_position(reference_position);
  return builder_.Finish();
}

struct MessageRateRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageRateRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_RATE_MIN = 4,
    VT_MESSAGE_RATE_MAX = 6
  };
  const Gos::MessageRateHz *message_rate_min() const {
    return GetPointer<const Gos::MessageRateHz *>(VT_MESSAGE_RATE_MIN);
  }
  const Gos::MessageRateHz *message_rate_max() const {
    return GetPointer<const Gos::MessageRateHz *>(VT_MESSAGE_RATE_MAX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE_RATE_MIN) &&
           verifier.VerifyTable(message_rate_min()) &&
           VerifyOffset(verifier, VT_MESSAGE_RATE_MAX) &&
           verifier.VerifyTable(message_rate_max()) &&
           verifier.EndTable();
  }
};

struct MessageRateRangeBuilder {
  typedef MessageRateRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_rate_min(::flatbuffers::Offset<Gos::MessageRateHz> message_rate_min) {
    fbb_.AddOffset(MessageRateRange::VT_MESSAGE_RATE_MIN, message_rate_min);
  }
  void add_message_rate_max(::flatbuffers::Offset<Gos::MessageRateHz> message_rate_max) {
    fbb_.AddOffset(MessageRateRange::VT_MESSAGE_RATE_MAX, message_rate_max);
  }
  explicit MessageRateRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageRateRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageRateRange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageRateRange> CreateMessageRateRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::MessageRateHz> message_rate_min = 0,
    ::flatbuffers::Offset<Gos::MessageRateHz> message_rate_max = 0) {
  MessageRateRangeBuilder builder_(_fbb);
  builder_.add_message_rate_max(message_rate_max);
  builder_.add_message_rate_min(message_rate_min);
  return builder_.Finish();
}

struct OriginatingStationsContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OriginatingStationsContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGINATING_VEHICLE_CONTAINER = 4,
    VT_ORIGINATING_RSU_CONTAINER = 6
  };
  const Gos::OriginatingVehicleContainer *originating_vehicle_container() const {
    return GetPointer<const Gos::OriginatingVehicleContainer *>(VT_ORIGINATING_VEHICLE_CONTAINER);
  }
  const Gos::OriginatingRSUContainer *originating_rsu_container() const {
    return GetPointer<const Gos::OriginatingRSUContainer *>(VT_ORIGINATING_RSU_CONTAINER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGINATING_VEHICLE_CONTAINER) &&
           verifier.VerifyTable(originating_vehicle_container()) &&
           VerifyOffset(verifier, VT_ORIGINATING_RSU_CONTAINER) &&
           verifier.VerifyTable(originating_rsu_container()) &&
           verifier.EndTable();
  }
};

struct OriginatingStationsContainerBuilder {
  typedef OriginatingStationsContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_originating_vehicle_container(::flatbuffers::Offset<Gos::OriginatingVehicleContainer> originating_vehicle_container) {
    fbb_.AddOffset(OriginatingStationsContainer::VT_ORIGINATING_VEHICLE_CONTAINER, originating_vehicle_container);
  }
  void add_originating_rsu_container(::flatbuffers::Offset<Gos::OriginatingRSUContainer> originating_rsu_container) {
    fbb_.AddOffset(OriginatingStationsContainer::VT_ORIGINATING_RSU_CONTAINER, originating_rsu_container);
  }
  explicit OriginatingStationsContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OriginatingStationsContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OriginatingStationsContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OriginatingStationsContainer> CreateOriginatingStationsContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::OriginatingVehicleContainer> originating_vehicle_container = 0,
    ::flatbuffers::Offset<Gos::OriginatingRSUContainer> originating_rsu_container = 0) {
  OriginatingStationsContainerBuilder builder_(_fbb);
  builder_.add_originating_rsu_container(originating_rsu_container);
  builder_.add_originating_vehicle_container(originating_vehicle_container);
  return builder_.Finish();
}

struct OriginatingVehicleContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OriginatingVehicleContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIENTATION_ANGLE = 4,
    VT_PITCH_ANGLE = 6,
    VT_ROLL_ANGLE = 8,
    VT_TRAILER_DATASET = 10
  };
  const Gos::Wgs84Angle *orientation_angle() const {
    return GetPointer<const Gos::Wgs84Angle *>(VT_ORIENTATION_ANGLE);
  }
  const Gos::CartesianAngle *pitch_angle() const {
    return GetPointer<const Gos::CartesianAngle *>(VT_PITCH_ANGLE);
  }
  const Gos::CartesianAngle *roll_angle() const {
    return GetPointer<const Gos::CartesianAngle *>(VT_ROLL_ANGLE);
  }
  int64_t trailer_dataset() const {
    return GetField<int64_t>(VT_TRAILER_DATASET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION_ANGLE) &&
           verifier.VerifyTable(orientation_angle()) &&
           VerifyOffset(verifier, VT_PITCH_ANGLE) &&
           verifier.VerifyTable(pitch_angle()) &&
           VerifyOffset(verifier, VT_ROLL_ANGLE) &&
           verifier.VerifyTable(roll_angle()) &&
           VerifyField<int64_t>(verifier, VT_TRAILER_DATASET, 8) &&
           verifier.EndTable();
  }
};

struct OriginatingVehicleContainerBuilder {
  typedef OriginatingVehicleContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_orientation_angle(::flatbuffers::Offset<Gos::Wgs84Angle> orientation_angle) {
    fbb_.AddOffset(OriginatingVehicleContainer::VT_ORIENTATION_ANGLE, orientation_angle);
  }
  void add_pitch_angle(::flatbuffers::Offset<Gos::CartesianAngle> pitch_angle) {
    fbb_.AddOffset(OriginatingVehicleContainer::VT_PITCH_ANGLE, pitch_angle);
  }
  void add_roll_angle(::flatbuffers::Offset<Gos::CartesianAngle> roll_angle) {
    fbb_.AddOffset(OriginatingVehicleContainer::VT_ROLL_ANGLE, roll_angle);
  }
  void add_trailer_dataset(int64_t trailer_dataset) {
    fbb_.AddElement<int64_t>(OriginatingVehicleContainer::VT_TRAILER_DATASET, trailer_dataset, 0);
  }
  explicit OriginatingVehicleContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OriginatingVehicleContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OriginatingVehicleContainer>(end);
    fbb_.Required(o, OriginatingVehicleContainer::VT_ORIENTATION_ANGLE);
    return o;
  }
};

inline ::flatbuffers::Offset<OriginatingVehicleContainer> CreateOriginatingVehicleContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::Wgs84Angle> orientation_angle = 0,
    ::flatbuffers::Offset<Gos::CartesianAngle> pitch_angle = 0,
    ::flatbuffers::Offset<Gos::CartesianAngle> roll_angle = 0,
    int64_t trailer_dataset = 0) {
  OriginatingVehicleContainerBuilder builder_(_fbb);
  builder_.add_trailer_dataset(trailer_dataset);
  builder_.add_roll_angle(roll_angle);
  builder_.add_pitch_angle(pitch_angle);
  builder_.add_orientation_angle(orientation_angle);
  return builder_.Finish();
}

struct OriginatingRSUContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OriginatingRSUContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROAD_SEGMENT = 4,
    VT_INTERSECTION = 6
  };
  const Gos::RoadSegmentReferenceID *road_segment() const {
    return GetPointer<const Gos::RoadSegmentReferenceID *>(VT_ROAD_SEGMENT);
  }
  const Gos::IntersectionReferenceID *intersection() const {
    return GetPointer<const Gos::IntersectionReferenceID *>(VT_INTERSECTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROAD_SEGMENT) &&
           verifier.VerifyTable(road_segment()) &&
           VerifyOffset(verifier, VT_INTERSECTION) &&
           verifier.VerifyTable(intersection()) &&
           verifier.EndTable();
  }
};

struct OriginatingRSUContainerBuilder {
  typedef OriginatingRSUContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_road_segment(::flatbuffers::Offset<Gos::RoadSegmentReferenceID> road_segment) {
    fbb_.AddOffset(OriginatingRSUContainer::VT_ROAD_SEGMENT, road_segment);
  }
  void add_intersection(::flatbuffers::Offset<Gos::IntersectionReferenceID> intersection) {
    fbb_.AddOffset(OriginatingRSUContainer::VT_INTERSECTION, intersection);
  }
  explicit OriginatingRSUContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OriginatingRSUContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OriginatingRSUContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OriginatingRSUContainer> CreateOriginatingRSUContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::RoadSegmentReferenceID> road_segment = 0,
    ::flatbuffers::Offset<Gos::IntersectionReferenceID> intersection = 0) {
  OriginatingRSUContainerBuilder builder_(_fbb);
  builder_.add_intersection(intersection);
  builder_.add_road_segment(road_segment);
  return builder_.Finish();
}

struct SensorInformationContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorInformationContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSOR_INFORMATION = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::SensorInformation>> *sensor_information() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::SensorInformation>> *>(VT_SENSOR_INFORMATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SENSOR_INFORMATION) &&
           verifier.VerifyVector(sensor_information()) &&
           verifier.VerifyVectorOfTables(sensor_information()) &&
           verifier.EndTable();
  }
};

struct SensorInformationContainerBuilder {
  typedef SensorInformationContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sensor_information(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::SensorInformation>>> sensor_information) {
    fbb_.AddOffset(SensorInformationContainer::VT_SENSOR_INFORMATION, sensor_information);
  }
  explicit SensorInformationContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorInformationContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorInformationContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorInformationContainer> CreateSensorInformationContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::SensorInformation>>> sensor_information = 0) {
  SensorInformationContainerBuilder builder_(_fbb);
  builder_.add_sensor_information(sensor_information);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SensorInformationContainer> CreateSensorInformationContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Gos::SensorInformation>> *sensor_information = nullptr) {
  auto sensor_information__ = sensor_information ? _fbb.CreateVector<::flatbuffers::Offset<Gos::SensorInformation>>(*sensor_information) : 0;
  return Gos::CreateSensorInformationContainer(
      _fbb,
      sensor_information__);
}

struct SensorInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorInformationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSOR_ID = 4,
    VT_SENSOR_TYPE = 6,
    VT_PERCEPTION_REGION_SHAPE = 8,
    VT_PERCEPTION_REGION_CONFIDENCE = 10,
    VT_SHADOWING_APPLIES = 12
  };
  int64_t sensor_id() const {
    return GetField<int64_t>(VT_SENSOR_ID, 0);
  }
  Gos::SensorType sensor_type() const {
    return static_cast<Gos::SensorType>(GetField<int32_t>(VT_SENSOR_TYPE, 0));
  }
  const Gos::Shape *perception_region_shape() const {
    return GetPointer<const Gos::Shape *>(VT_PERCEPTION_REGION_SHAPE);
  }
  uint32_t perception_region_confidence() const {
    return GetField<uint32_t>(VT_PERCEPTION_REGION_CONFIDENCE, 0);
  }
  bool shadowing_applies() const {
    return GetField<uint8_t>(VT_SHADOWING_APPLIES, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SENSOR_ID, 8) &&
           VerifyField<int32_t>(verifier, VT_SENSOR_TYPE, 4) &&
           VerifyOffset(verifier, VT_PERCEPTION_REGION_SHAPE) &&
           verifier.VerifyTable(perception_region_shape()) &&
           VerifyField<uint32_t>(verifier, VT_PERCEPTION_REGION_CONFIDENCE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SHADOWING_APPLIES, 1) &&
           verifier.EndTable();
  }
};

struct SensorInformationBuilder {
  typedef SensorInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sensor_id(int64_t sensor_id) {
    fbb_.AddElement<int64_t>(SensorInformation::VT_SENSOR_ID, sensor_id, 0);
  }
  void add_sensor_type(Gos::SensorType sensor_type) {
    fbb_.AddElement<int32_t>(SensorInformation::VT_SENSOR_TYPE, static_cast<int32_t>(sensor_type), 0);
  }
  void add_perception_region_shape(::flatbuffers::Offset<Gos::Shape> perception_region_shape) {
    fbb_.AddOffset(SensorInformation::VT_PERCEPTION_REGION_SHAPE, perception_region_shape);
  }
  void add_perception_region_confidence(uint32_t perception_region_confidence) {
    fbb_.AddElement<uint32_t>(SensorInformation::VT_PERCEPTION_REGION_CONFIDENCE, perception_region_confidence, 0);
  }
  void add_shadowing_applies(bool shadowing_applies) {
    fbb_.AddElement<uint8_t>(SensorInformation::VT_SHADOWING_APPLIES, static_cast<uint8_t>(shadowing_applies), 0);
  }
  explicit SensorInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorInformation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorInformation> CreateSensorInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sensor_id = 0,
    Gos::SensorType sensor_type = Gos::SensorType_SNSR_UNDEFINED,
    ::flatbuffers::Offset<Gos::Shape> perception_region_shape = 0,
    uint32_t perception_region_confidence = 0,
    bool shadowing_applies = false) {
  SensorInformationBuilder builder_(_fbb);
  builder_.add_sensor_id(sensor_id);
  builder_.add_perception_region_confidence(perception_region_confidence);
  builder_.add_perception_region_shape(perception_region_shape);
  builder_.add_sensor_type(sensor_type);
  builder_.add_shadowing_applies(shadowing_applies);
  return builder_.Finish();
}

struct PerceptionRegionContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceptionRegionContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERCEPTION_REGION_LIST = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceptionRegion>> *perception_region_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceptionRegion>> *>(VT_PERCEPTION_REGION_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERCEPTION_REGION_LIST) &&
           verifier.VerifyVector(perception_region_list()) &&
           verifier.VerifyVectorOfTables(perception_region_list()) &&
           verifier.EndTable();
  }
};

struct PerceptionRegionContainerBuilder {
  typedef PerceptionRegionContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_perception_region_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceptionRegion>>> perception_region_list) {
    fbb_.AddOffset(PerceptionRegionContainer::VT_PERCEPTION_REGION_LIST, perception_region_list);
  }
  explicit PerceptionRegionContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceptionRegionContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceptionRegionContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceptionRegionContainer> CreatePerceptionRegionContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceptionRegion>>> perception_region_list = 0) {
  PerceptionRegionContainerBuilder builder_(_fbb);
  builder_.add_perception_region_list(perception_region_list);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceptionRegionContainer> CreatePerceptionRegionContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Gos::PerceptionRegion>> *perception_region_list = nullptr) {
  auto perception_region_list__ = perception_region_list ? _fbb.CreateVector<::flatbuffers::Offset<Gos::PerceptionRegion>>(*perception_region_list) : 0;
  return Gos::CreatePerceptionRegionContainer(
      _fbb,
      perception_region_list__);
}

struct PerceptionRegion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceptionRegionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEASUREMENT_DELTA_TIME = 4,
    VT_PERCEPTION_REGION_CONFIDENCE = 6,
    VT_PERCEPTION_REGION_SHAPE = 8,
    VT_SHADOWING_APPLIES = 10,
    VT_SENSOR_ID_LIST = 12,
    VT_NUMBER_OF_PERCEIVED_OBJECTS = 14,
    VT_PERCEIVED_OBJECT_IDS = 16
  };
  int32_t measurement_delta_time() const {
    return GetField<int32_t>(VT_MEASUREMENT_DELTA_TIME, 0);
  }
  uint32_t perception_region_confidence() const {
    return GetField<uint32_t>(VT_PERCEPTION_REGION_CONFIDENCE, 0);
  }
  const Gos::Shape *perception_region_shape() const {
    return GetPointer<const Gos::Shape *>(VT_PERCEPTION_REGION_SHAPE);
  }
  bool shadowing_applies() const {
    return GetField<uint8_t>(VT_SHADOWING_APPLIES, 0) != 0;
  }
  const ::flatbuffers::Vector<uint32_t> *sensor_id_list() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_SENSOR_ID_LIST);
  }
  uint32_t number_of_perceived_objects() const {
    return GetField<uint32_t>(VT_NUMBER_OF_PERCEIVED_OBJECTS, 0);
  }
  uint32_t perceived_object_ids() const {
    return GetField<uint32_t>(VT_PERCEIVED_OBJECT_IDS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MEASUREMENT_DELTA_TIME, 4) &&
           VerifyField<uint32_t>(verifier, VT_PERCEPTION_REGION_CONFIDENCE, 4) &&
           VerifyOffset(verifier, VT_PERCEPTION_REGION_SHAPE) &&
           verifier.VerifyTable(perception_region_shape()) &&
           VerifyField<uint8_t>(verifier, VT_SHADOWING_APPLIES, 1) &&
           VerifyOffset(verifier, VT_SENSOR_ID_LIST) &&
           verifier.VerifyVector(sensor_id_list()) &&
           VerifyField<uint32_t>(verifier, VT_NUMBER_OF_PERCEIVED_OBJECTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_PERCEIVED_OBJECT_IDS, 4) &&
           verifier.EndTable();
  }
};

struct PerceptionRegionBuilder {
  typedef PerceptionRegion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_measurement_delta_time(int32_t measurement_delta_time) {
    fbb_.AddElement<int32_t>(PerceptionRegion::VT_MEASUREMENT_DELTA_TIME, measurement_delta_time, 0);
  }
  void add_perception_region_confidence(uint32_t perception_region_confidence) {
    fbb_.AddElement<uint32_t>(PerceptionRegion::VT_PERCEPTION_REGION_CONFIDENCE, perception_region_confidence, 0);
  }
  void add_perception_region_shape(::flatbuffers::Offset<Gos::Shape> perception_region_shape) {
    fbb_.AddOffset(PerceptionRegion::VT_PERCEPTION_REGION_SHAPE, perception_region_shape);
  }
  void add_shadowing_applies(bool shadowing_applies) {
    fbb_.AddElement<uint8_t>(PerceptionRegion::VT_SHADOWING_APPLIES, static_cast<uint8_t>(shadowing_applies), 0);
  }
  void add_sensor_id_list(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> sensor_id_list) {
    fbb_.AddOffset(PerceptionRegion::VT_SENSOR_ID_LIST, sensor_id_list);
  }
  void add_number_of_perceived_objects(uint32_t number_of_perceived_objects) {
    fbb_.AddElement<uint32_t>(PerceptionRegion::VT_NUMBER_OF_PERCEIVED_OBJECTS, number_of_perceived_objects, 0);
  }
  void add_perceived_object_ids(uint32_t perceived_object_ids) {
    fbb_.AddElement<uint32_t>(PerceptionRegion::VT_PERCEIVED_OBJECT_IDS, perceived_object_ids, 0);
  }
  explicit PerceptionRegionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceptionRegion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceptionRegion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceptionRegion> CreatePerceptionRegion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t measurement_delta_time = 0,
    uint32_t perception_region_confidence = 0,
    ::flatbuffers::Offset<Gos::Shape> perception_region_shape = 0,
    bool shadowing_applies = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> sensor_id_list = 0,
    uint32_t number_of_perceived_objects = 0,
    uint32_t perceived_object_ids = 0) {
  PerceptionRegionBuilder builder_(_fbb);
  builder_.add_perceived_object_ids(perceived_object_ids);
  builder_.add_number_of_perceived_objects(number_of_perceived_objects);
  builder_.add_sensor_id_list(sensor_id_list);
  builder_.add_perception_region_shape(perception_region_shape);
  builder_.add_perception_region_confidence(perception_region_confidence);
  builder_.add_measurement_delta_time(measurement_delta_time);
  builder_.add_shadowing_applies(shadowing_applies);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceptionRegion> CreatePerceptionRegionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t measurement_delta_time = 0,
    uint32_t perception_region_confidence = 0,
    ::flatbuffers::Offset<Gos::Shape> perception_region_shape = 0,
    bool shadowing_applies = false,
    const std::vector<uint32_t> *sensor_id_list = nullptr,
    uint32_t number_of_perceived_objects = 0,
    uint32_t perceived_object_ids = 0) {
  auto sensor_id_list__ = sensor_id_list ? _fbb.CreateVector<uint32_t>(*sensor_id_list) : 0;
  return Gos::CreatePerceptionRegion(
      _fbb,
      measurement_delta_time,
      perception_region_confidence,
      perception_region_shape,
      shadowing_applies,
      sensor_id_list__,
      number_of_perceived_objects,
      perceived_object_ids);
}

struct PerceivedObjectContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceivedObjectContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER_OF_PERCEIVED_OBJECTS = 4,
    VT_PERCEIVED_OBJECTS = 6
  };
  uint32_t number_of_perceived_objects() const {
    return GetField<uint32_t>(VT_NUMBER_OF_PERCEIVED_OBJECTS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceivedObject>> *perceived_objects() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceivedObject>> *>(VT_PERCEIVED_OBJECTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NUMBER_OF_PERCEIVED_OBJECTS, 4) &&
           VerifyOffset(verifier, VT_PERCEIVED_OBJECTS) &&
           verifier.VerifyVector(perceived_objects()) &&
           verifier.VerifyVectorOfTables(perceived_objects()) &&
           verifier.EndTable();
  }
};

struct PerceivedObjectContainerBuilder {
  typedef PerceivedObjectContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_number_of_perceived_objects(uint32_t number_of_perceived_objects) {
    fbb_.AddElement<uint32_t>(PerceivedObjectContainer::VT_NUMBER_OF_PERCEIVED_OBJECTS, number_of_perceived_objects, 0);
  }
  void add_perceived_objects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceivedObject>>> perceived_objects) {
    fbb_.AddOffset(PerceivedObjectContainer::VT_PERCEIVED_OBJECTS, perceived_objects);
  }
  explicit PerceivedObjectContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceivedObjectContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceivedObjectContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceivedObjectContainer> CreatePerceivedObjectContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t number_of_perceived_objects = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::PerceivedObject>>> perceived_objects = 0) {
  PerceivedObjectContainerBuilder builder_(_fbb);
  builder_.add_perceived_objects(perceived_objects);
  builder_.add_number_of_perceived_objects(number_of_perceived_objects);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceivedObjectContainer> CreatePerceivedObjectContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t number_of_perceived_objects = 0,
    const std::vector<::flatbuffers::Offset<Gos::PerceivedObject>> *perceived_objects = nullptr) {
  auto perceived_objects__ = perceived_objects ? _fbb.CreateVector<::flatbuffers::Offset<Gos::PerceivedObject>>(*perceived_objects) : 0;
  return Gos::CreatePerceivedObjectContainer(
      _fbb,
      number_of_perceived_objects,
      perceived_objects__);
}

struct PerceivedObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceivedObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_ID = 4,
    VT_MEASUREMENT_DELTA_TIME = 6,
    VT_POSITION = 8,
    VT_VELOCITY = 10,
    VT_OBJECT_DIMENSION_Z = 12,
    VT_OBJECT_DIMENSION_Y = 14,
    VT_OBJECT_DIMENSION_X = 16,
    VT_OBJECT_AGE = 18,
    VT_CLASSIFICATION = 20,
    VT_MAP_POSITION = 22
  };
  uint32_t object_id() const {
    return GetField<uint32_t>(VT_OBJECT_ID, 0);
  }
  int32_t measurement_delta_time() const {
    return GetField<int32_t>(VT_MEASUREMENT_DELTA_TIME, 0);
  }
  const Gos::CartesianPosition3dWithConfidence *position() const {
    return GetPointer<const Gos::CartesianPosition3dWithConfidence *>(VT_POSITION);
  }
  const Gos::Velocity3dWithConfidence *velocity() const {
    return GetPointer<const Gos::Velocity3dWithConfidence *>(VT_VELOCITY);
  }
  const Gos::ObjectDimension *object_dimension_z() const {
    return GetPointer<const Gos::ObjectDimension *>(VT_OBJECT_DIMENSION_Z);
  }
  const Gos::ObjectDimension *object_dimension_y() const {
    return GetPointer<const Gos::ObjectDimension *>(VT_OBJECT_DIMENSION_Y);
  }
  const Gos::ObjectDimension *object_dimension_x() const {
    return GetPointer<const Gos::ObjectDimension *>(VT_OBJECT_DIMENSION_X);
  }
  uint32_t object_age() const {
    return GetField<uint32_t>(VT_OBJECT_AGE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::ObjectClassWithConfidence>> *classification() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::ObjectClassWithConfidence>> *>(VT_CLASSIFICATION);
  }
  const Gos::MapPosition *map_position() const {
    return GetPointer<const Gos::MapPosition *>(VT_MAP_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_MEASUREMENT_DELTA_TIME, 4) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyTable(velocity()) &&
           VerifyOffset(verifier, VT_OBJECT_DIMENSION_Z) &&
           verifier.VerifyTable(object_dimension_z()) &&
           VerifyOffset(verifier, VT_OBJECT_DIMENSION_Y) &&
           verifier.VerifyTable(object_dimension_y()) &&
           VerifyOffset(verifier, VT_OBJECT_DIMENSION_X) &&
           verifier.VerifyTable(object_dimension_x()) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_AGE, 4) &&
           VerifyOffset(verifier, VT_CLASSIFICATION) &&
           verifier.VerifyVector(classification()) &&
           verifier.VerifyVectorOfTables(classification()) &&
           VerifyOffset(verifier, VT_MAP_POSITION) &&
           verifier.VerifyTable(map_position()) &&
           verifier.EndTable();
  }
};

struct PerceivedObjectBuilder {
  typedef PerceivedObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_object_id(uint32_t object_id) {
    fbb_.AddElement<uint32_t>(PerceivedObject::VT_OBJECT_ID, object_id, 0);
  }
  void add_measurement_delta_time(int32_t measurement_delta_time) {
    fbb_.AddElement<int32_t>(PerceivedObject::VT_MEASUREMENT_DELTA_TIME, measurement_delta_time, 0);
  }
  void add_position(::flatbuffers::Offset<Gos::CartesianPosition3dWithConfidence> position) {
    fbb_.AddOffset(PerceivedObject::VT_POSITION, position);
  }
  void add_velocity(::flatbuffers::Offset<Gos::Velocity3dWithConfidence> velocity) {
    fbb_.AddOffset(PerceivedObject::VT_VELOCITY, velocity);
  }
  void add_object_dimension_z(::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_z) {
    fbb_.AddOffset(PerceivedObject::VT_OBJECT_DIMENSION_Z, object_dimension_z);
  }
  void add_object_dimension_y(::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_y) {
    fbb_.AddOffset(PerceivedObject::VT_OBJECT_DIMENSION_Y, object_dimension_y);
  }
  void add_object_dimension_x(::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_x) {
    fbb_.AddOffset(PerceivedObject::VT_OBJECT_DIMENSION_X, object_dimension_x);
  }
  void add_object_age(uint32_t object_age) {
    fbb_.AddElement<uint32_t>(PerceivedObject::VT_OBJECT_AGE, object_age, 0);
  }
  void add_classification(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::ObjectClassWithConfidence>>> classification) {
    fbb_.AddOffset(PerceivedObject::VT_CLASSIFICATION, classification);
  }
  void add_map_position(::flatbuffers::Offset<Gos::MapPosition> map_position) {
    fbb_.AddOffset(PerceivedObject::VT_MAP_POSITION, map_position);
  }
  explicit PerceivedObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceivedObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceivedObject>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceivedObject> CreatePerceivedObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t object_id = 0,
    int32_t measurement_delta_time = 0,
    ::flatbuffers::Offset<Gos::CartesianPosition3dWithConfidence> position = 0,
    ::flatbuffers::Offset<Gos::Velocity3dWithConfidence> velocity = 0,
    ::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_z = 0,
    ::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_y = 0,
    ::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_x = 0,
    uint32_t object_age = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::ObjectClassWithConfidence>>> classification = 0,
    ::flatbuffers::Offset<Gos::MapPosition> map_position = 0) {
  PerceivedObjectBuilder builder_(_fbb);
  builder_.add_map_position(map_position);
  builder_.add_classification(classification);
  builder_.add_object_age(object_age);
  builder_.add_object_dimension_x(object_dimension_x);
  builder_.add_object_dimension_y(object_dimension_y);
  builder_.add_object_dimension_z(object_dimension_z);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  builder_.add_measurement_delta_time(measurement_delta_time);
  builder_.add_object_id(object_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceivedObject> CreatePerceivedObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t object_id = 0,
    int32_t measurement_delta_time = 0,
    ::flatbuffers::Offset<Gos::CartesianPosition3dWithConfidence> position = 0,
    ::flatbuffers::Offset<Gos::Velocity3dWithConfidence> velocity = 0,
    ::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_z = 0,
    ::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_y = 0,
    ::flatbuffers::Offset<Gos::ObjectDimension> object_dimension_x = 0,
    uint32_t object_age = 0,
    const std::vector<::flatbuffers::Offset<Gos::ObjectClassWithConfidence>> *classification = nullptr,
    ::flatbuffers::Offset<Gos::MapPosition> map_position = 0) {
  auto classification__ = classification ? _fbb.CreateVector<::flatbuffers::Offset<Gos::ObjectClassWithConfidence>>(*classification) : 0;
  return Gos::CreatePerceivedObject(
      _fbb,
      object_id,
      measurement_delta_time,
      position,
      velocity,
      object_dimension_z,
      object_dimension_y,
      object_dimension_x,
      object_age,
      classification__,
      map_position);
}

struct DENMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DENMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_DENM = 6
  };
  const Gos::ItsPduHeader *header() const {
    return GetPointer<const Gos::ItsPduHeader *>(VT_HEADER);
  }
  const Gos::DecentralizedEnvironmentalNotificationMessage *denm() const {
    return GetPointer<const Gos::DecentralizedEnvironmentalNotificationMessage *>(VT_DENM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_DENM) &&
           verifier.VerifyTable(denm()) &&
           verifier.EndTable();
  }
};

struct DENMessageBuilder {
  typedef DENMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<Gos::ItsPduHeader> header) {
    fbb_.AddOffset(DENMessage::VT_HEADER, header);
  }
  void add_denm(::flatbuffers::Offset<Gos::DecentralizedEnvironmentalNotificationMessage> denm) {
    fbb_.AddOffset(DENMessage::VT_DENM, denm);
  }
  explicit DENMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DENMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DENMessage>(end);
    fbb_.Required(o, DENMessage::VT_HEADER);
    fbb_.Required(o, DENMessage::VT_DENM);
    return o;
  }
};

inline ::flatbuffers::Offset<DENMessage> CreateDENMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::ItsPduHeader> header = 0,
    ::flatbuffers::Offset<Gos::DecentralizedEnvironmentalNotificationMessage> denm = 0) {
  DENMessageBuilder builder_(_fbb);
  builder_.add_denm(denm);
  builder_.add_header(header);
  return builder_.Finish();
}

struct DecentralizedEnvironmentalNotificationMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DecentralizedEnvironmentalNotificationMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MANAGEMENT = 4,
    VT_SITUATION = 6,
    VT_LOCATION = 8,
    VT_ALACARTE = 10
  };
  const Gos::DenmManagementContainer *management() const {
    return GetPointer<const Gos::DenmManagementContainer *>(VT_MANAGEMENT);
  }
  const Gos::SituationContainer *situation() const {
    return GetPointer<const Gos::SituationContainer *>(VT_SITUATION);
  }
  const Gos::LocationContainer *location() const {
    return GetPointer<const Gos::LocationContainer *>(VT_LOCATION);
  }
  const Gos::AlacarteContainer *alacarte() const {
    return GetPointer<const Gos::AlacarteContainer *>(VT_ALACARTE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MANAGEMENT) &&
           verifier.VerifyTable(management()) &&
           VerifyOffset(verifier, VT_SITUATION) &&
           verifier.VerifyTable(situation()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_ALACARTE) &&
           verifier.VerifyTable(alacarte()) &&
           verifier.EndTable();
  }
};

struct DecentralizedEnvironmentalNotificationMessageBuilder {
  typedef DecentralizedEnvironmentalNotificationMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_management(::flatbuffers::Offset<Gos::DenmManagementContainer> management) {
    fbb_.AddOffset(DecentralizedEnvironmentalNotificationMessage::VT_MANAGEMENT, management);
  }
  void add_situation(::flatbuffers::Offset<Gos::SituationContainer> situation) {
    fbb_.AddOffset(DecentralizedEnvironmentalNotificationMessage::VT_SITUATION, situation);
  }
  void add_location(::flatbuffers::Offset<Gos::LocationContainer> location) {
    fbb_.AddOffset(DecentralizedEnvironmentalNotificationMessage::VT_LOCATION, location);
  }
  void add_alacarte(::flatbuffers::Offset<Gos::AlacarteContainer> alacarte) {
    fbb_.AddOffset(DecentralizedEnvironmentalNotificationMessage::VT_ALACARTE, alacarte);
  }
  explicit DecentralizedEnvironmentalNotificationMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage>(end);
    fbb_.Required(o, DecentralizedEnvironmentalNotificationMessage::VT_MANAGEMENT);
    return o;
  }
};

inline ::flatbuffers::Offset<DecentralizedEnvironmentalNotificationMessage> CreateDecentralizedEnvironmentalNotificationMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::DenmManagementContainer> management = 0,
    ::flatbuffers::Offset<Gos::SituationContainer> situation = 0,
    ::flatbuffers::Offset<Gos::LocationContainer> location = 0,
    ::flatbuffers::Offset<Gos::AlacarteContainer> alacarte = 0) {
  DecentralizedEnvironmentalNotificationMessageBuilder builder_(_fbb);
  builder_.add_alacarte(alacarte);
  builder_.add_location(location);
  builder_.add_situation(situation);
  builder_.add_management(management);
  return builder_.Finish();
}

struct AlacarteContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlacarteContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANE_POSITION = 4,
    VT_IMPACT_REDUCTION = 6,
    VT_EXTERNAL_TEMPERATURE = 8,
    VT_ROAD_WORKS = 10,
    VT_POSITIONING_SOLUTION = 12,
    VT_STATIONARY_VEHICLE = 14
  };
  int32_t lane_position() const {
    return GetField<int32_t>(VT_LANE_POSITION, 0);
  }
  const Gos::ImpactReductionContainer *impact_reduction() const {
    return GetPointer<const Gos::ImpactReductionContainer *>(VT_IMPACT_REDUCTION);
  }
  int32_t external_temperature() const {
    return GetField<int32_t>(VT_EXTERNAL_TEMPERATURE, 0);
  }
  const Gos::RoadWorksContainerExtended *road_works() const {
    return GetPointer<const Gos::RoadWorksContainerExtended *>(VT_ROAD_WORKS);
  }
  Gos::PositioningSolutionType positioning_solution() const {
    return static_cast<Gos::PositioningSolutionType>(GetField<int32_t>(VT_POSITIONING_SOLUTION, 0));
  }
  const Gos::StationaryVehicleContainer *stationary_vehicle() const {
    return GetPointer<const Gos::StationaryVehicleContainer *>(VT_STATIONARY_VEHICLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LANE_POSITION, 4) &&
           VerifyOffset(verifier, VT_IMPACT_REDUCTION) &&
           verifier.VerifyTable(impact_reduction()) &&
           VerifyField<int32_t>(verifier, VT_EXTERNAL_TEMPERATURE, 4) &&
           VerifyOffset(verifier, VT_ROAD_WORKS) &&
           verifier.VerifyTable(road_works()) &&
           VerifyField<int32_t>(verifier, VT_POSITIONING_SOLUTION, 4) &&
           VerifyOffset(verifier, VT_STATIONARY_VEHICLE) &&
           verifier.VerifyTable(stationary_vehicle()) &&
           verifier.EndTable();
  }
};

struct AlacarteContainerBuilder {
  typedef AlacarteContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lane_position(int32_t lane_position) {
    fbb_.AddElement<int32_t>(AlacarteContainer::VT_LANE_POSITION, lane_position, 0);
  }
  void add_impact_reduction(::flatbuffers::Offset<Gos::ImpactReductionContainer> impact_reduction) {
    fbb_.AddOffset(AlacarteContainer::VT_IMPACT_REDUCTION, impact_reduction);
  }
  void add_external_temperature(int32_t external_temperature) {
    fbb_.AddElement<int32_t>(AlacarteContainer::VT_EXTERNAL_TEMPERATURE, external_temperature, 0);
  }
  void add_road_works(::flatbuffers::Offset<Gos::RoadWorksContainerExtended> road_works) {
    fbb_.AddOffset(AlacarteContainer::VT_ROAD_WORKS, road_works);
  }
  void add_positioning_solution(Gos::PositioningSolutionType positioning_solution) {
    fbb_.AddElement<int32_t>(AlacarteContainer::VT_POSITIONING_SOLUTION, static_cast<int32_t>(positioning_solution), 0);
  }
  void add_stationary_vehicle(::flatbuffers::Offset<Gos::StationaryVehicleContainer> stationary_vehicle) {
    fbb_.AddOffset(AlacarteContainer::VT_STATIONARY_VEHICLE, stationary_vehicle);
  }
  explicit AlacarteContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlacarteContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlacarteContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlacarteContainer> CreateAlacarteContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lane_position = 0,
    ::flatbuffers::Offset<Gos::ImpactReductionContainer> impact_reduction = 0,
    int32_t external_temperature = 0,
    ::flatbuffers::Offset<Gos::RoadWorksContainerExtended> road_works = 0,
    Gos::PositioningSolutionType positioning_solution = Gos::PositioningSolutionType_PST_NO_POSITIONING_SOLUTION,
    ::flatbuffers::Offset<Gos::StationaryVehicleContainer> stationary_vehicle = 0) {
  AlacarteContainerBuilder builder_(_fbb);
  builder_.add_stationary_vehicle(stationary_vehicle);
  builder_.add_positioning_solution(positioning_solution);
  builder_.add_road_works(road_works);
  builder_.add_external_temperature(external_temperature);
  builder_.add_impact_reduction(impact_reduction);
  builder_.add_lane_position(lane_position);
  return builder_.Finish();
}

struct ImpactReductionContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImpactReductionContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT_LON_CARR_LEFT = 4,
    VT_HEIGHT_LON_CARR_RIGHT = 6,
    VT_POS_LON_CARR_LEFT = 8,
    VT_POS_LON_CARR_RIGHT = 10,
    VT_POSITION_OF_PILLARS = 12,
    VT_POS_CENT_MASS = 14,
    VT_WHEEL_BASE_VEHICLE = 16,
    VT_TURNING_RADIUS = 18,
    VT_POS_FRONT_AX = 20,
    VT_POSITION_OF_OCCUPANTS = 22,
    VT_VEHICLE_MASS = 24,
    VT_REQUEST_RESPONSE_INDICATION = 26
  };
  uint32_t height_lon_carr_left() const {
    return GetField<uint32_t>(VT_HEIGHT_LON_CARR_LEFT, 0);
  }
  uint32_t height_lon_carr_right() const {
    return GetField<uint32_t>(VT_HEIGHT_LON_CARR_RIGHT, 0);
  }
  uint32_t pos_lon_carr_left() const {
    return GetField<uint32_t>(VT_POS_LON_CARR_LEFT, 0);
  }
  uint32_t pos_lon_carr_right() const {
    return GetField<uint32_t>(VT_POS_LON_CARR_RIGHT, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *position_of_pillars() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_POSITION_OF_PILLARS);
  }
  uint32_t pos_cent_mass() const {
    return GetField<uint32_t>(VT_POS_CENT_MASS, 0);
  }
  uint32_t wheel_base_vehicle() const {
    return GetField<uint32_t>(VT_WHEEL_BASE_VEHICLE, 0);
  }
  uint32_t turning_radius() const {
    return GetField<uint32_t>(VT_TURNING_RADIUS, 0);
  }
  uint32_t pos_front_ax() const {
    return GetField<uint32_t>(VT_POS_FRONT_AX, 0);
  }
  Gos::PositionOfOccupants position_of_occupants() const {
    return static_cast<Gos::PositionOfOccupants>(GetField<int32_t>(VT_POSITION_OF_OCCUPANTS, 0));
  }
  uint32_t vehicle_mass() const {
    return GetField<uint32_t>(VT_VEHICLE_MASS, 0);
  }
  Gos::RequestResponseIndication request_response_indication() const {
    return static_cast<Gos::RequestResponseIndication>(GetField<int32_t>(VT_REQUEST_RESPONSE_INDICATION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT_LON_CARR_LEFT, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT_LON_CARR_RIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_POS_LON_CARR_LEFT, 4) &&
           VerifyField<uint32_t>(verifier, VT_POS_LON_CARR_RIGHT, 4) &&
           VerifyOffset(verifier, VT_POSITION_OF_PILLARS) &&
           verifier.VerifyVector(position_of_pillars()) &&
           VerifyField<uint32_t>(verifier, VT_POS_CENT_MASS, 4) &&
           VerifyField<uint32_t>(verifier, VT_WHEEL_BASE_VEHICLE, 4) &&
           VerifyField<uint32_t>(verifier, VT_TURNING_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_POS_FRONT_AX, 4) &&
           VerifyField<int32_t>(verifier, VT_POSITION_OF_OCCUPANTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_VEHICLE_MASS, 4) &&
           VerifyField<int32_t>(verifier, VT_REQUEST_RESPONSE_INDICATION, 4) &&
           verifier.EndTable();
  }
};

struct ImpactReductionContainerBuilder {
  typedef ImpactReductionContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_height_lon_carr_left(uint32_t height_lon_carr_left) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_HEIGHT_LON_CARR_LEFT, height_lon_carr_left, 0);
  }
  void add_height_lon_carr_right(uint32_t height_lon_carr_right) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_HEIGHT_LON_CARR_RIGHT, height_lon_carr_right, 0);
  }
  void add_pos_lon_carr_left(uint32_t pos_lon_carr_left) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_POS_LON_CARR_LEFT, pos_lon_carr_left, 0);
  }
  void add_pos_lon_carr_right(uint32_t pos_lon_carr_right) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_POS_LON_CARR_RIGHT, pos_lon_carr_right, 0);
  }
  void add_position_of_pillars(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> position_of_pillars) {
    fbb_.AddOffset(ImpactReductionContainer::VT_POSITION_OF_PILLARS, position_of_pillars);
  }
  void add_pos_cent_mass(uint32_t pos_cent_mass) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_POS_CENT_MASS, pos_cent_mass, 0);
  }
  void add_wheel_base_vehicle(uint32_t wheel_base_vehicle) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_WHEEL_BASE_VEHICLE, wheel_base_vehicle, 0);
  }
  void add_turning_radius(uint32_t turning_radius) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_TURNING_RADIUS, turning_radius, 0);
  }
  void add_pos_front_ax(uint32_t pos_front_ax) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_POS_FRONT_AX, pos_front_ax, 0);
  }
  void add_position_of_occupants(Gos::PositionOfOccupants position_of_occupants) {
    fbb_.AddElement<int32_t>(ImpactReductionContainer::VT_POSITION_OF_OCCUPANTS, static_cast<int32_t>(position_of_occupants), 0);
  }
  void add_vehicle_mass(uint32_t vehicle_mass) {
    fbb_.AddElement<uint32_t>(ImpactReductionContainer::VT_VEHICLE_MASS, vehicle_mass, 0);
  }
  void add_request_response_indication(Gos::RequestResponseIndication request_response_indication) {
    fbb_.AddElement<int32_t>(ImpactReductionContainer::VT_REQUEST_RESPONSE_INDICATION, static_cast<int32_t>(request_response_indication), 0);
  }
  explicit ImpactReductionContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImpactReductionContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImpactReductionContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImpactReductionContainer> CreateImpactReductionContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t height_lon_carr_left = 0,
    uint32_t height_lon_carr_right = 0,
    uint32_t pos_lon_carr_left = 0,
    uint32_t pos_lon_carr_right = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> position_of_pillars = 0,
    uint32_t pos_cent_mass = 0,
    uint32_t wheel_base_vehicle = 0,
    uint32_t turning_radius = 0,
    uint32_t pos_front_ax = 0,
    Gos::PositionOfOccupants position_of_occupants = Gos::PositionOfOccupants_POS_OCC_ROW1_LEFT_OCCUPIED,
    uint32_t vehicle_mass = 0,
    Gos::RequestResponseIndication request_response_indication = Gos::RequestResponseIndication_RRI_REQUEST) {
  ImpactReductionContainerBuilder builder_(_fbb);
  builder_.add_request_response_indication(request_response_indication);
  builder_.add_vehicle_mass(vehicle_mass);
  builder_.add_position_of_occupants(position_of_occupants);
  builder_.add_pos_front_ax(pos_front_ax);
  builder_.add_turning_radius(turning_radius);
  builder_.add_wheel_base_vehicle(wheel_base_vehicle);
  builder_.add_pos_cent_mass(pos_cent_mass);
  builder_.add_position_of_pillars(position_of_pillars);
  builder_.add_pos_lon_carr_right(pos_lon_carr_right);
  builder_.add_pos_lon_carr_left(pos_lon_carr_left);
  builder_.add_height_lon_carr_right(height_lon_carr_right);
  builder_.add_height_lon_carr_left(height_lon_carr_left);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ImpactReductionContainer> CreateImpactReductionContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t height_lon_carr_left = 0,
    uint32_t height_lon_carr_right = 0,
    uint32_t pos_lon_carr_left = 0,
    uint32_t pos_lon_carr_right = 0,
    const std::vector<uint32_t> *position_of_pillars = nullptr,
    uint32_t pos_cent_mass = 0,
    uint32_t wheel_base_vehicle = 0,
    uint32_t turning_radius = 0,
    uint32_t pos_front_ax = 0,
    Gos::PositionOfOccupants position_of_occupants = Gos::PositionOfOccupants_POS_OCC_ROW1_LEFT_OCCUPIED,
    uint32_t vehicle_mass = 0,
    Gos::RequestResponseIndication request_response_indication = Gos::RequestResponseIndication_RRI_REQUEST) {
  auto position_of_pillars__ = position_of_pillars ? _fbb.CreateVector<uint32_t>(*position_of_pillars) : 0;
  return Gos::CreateImpactReductionContainer(
      _fbb,
      height_lon_carr_left,
      height_lon_carr_right,
      pos_lon_carr_left,
      pos_lon_carr_right,
      position_of_pillars__,
      pos_cent_mass,
      wheel_base_vehicle,
      turning_radius,
      pos_front_ax,
      position_of_occupants,
      vehicle_mass,
      request_response_indication);
}

struct LocationContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LocationContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_SPEED = 4,
    VT_EVENT_POSITION_HEADING = 6,
    VT_TRACES = 8,
    VT_ROAD_TYPE = 10
  };
  const Gos::Speed *event_speed() const {
    return GetPointer<const Gos::Speed *>(VT_EVENT_SPEED);
  }
  const Gos::Heading *event_position_heading() const {
    return GetPointer<const Gos::Heading *>(VT_EVENT_POSITION_HEADING);
  }
  uint32_t traces() const {
    return GetField<uint32_t>(VT_TRACES, 0);
  }
  Gos::RoadType road_type() const {
    return static_cast<Gos::RoadType>(GetField<int32_t>(VT_ROAD_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENT_SPEED) &&
           verifier.VerifyTable(event_speed()) &&
           VerifyOffset(verifier, VT_EVENT_POSITION_HEADING) &&
           verifier.VerifyTable(event_position_heading()) &&
           VerifyField<uint32_t>(verifier, VT_TRACES, 4) &&
           VerifyField<int32_t>(verifier, VT_ROAD_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct LocationContainerBuilder {
  typedef LocationContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_speed(::flatbuffers::Offset<Gos::Speed> event_speed) {
    fbb_.AddOffset(LocationContainer::VT_EVENT_SPEED, event_speed);
  }
  void add_event_position_heading(::flatbuffers::Offset<Gos::Heading> event_position_heading) {
    fbb_.AddOffset(LocationContainer::VT_EVENT_POSITION_HEADING, event_position_heading);
  }
  void add_traces(uint32_t traces) {
    fbb_.AddElement<uint32_t>(LocationContainer::VT_TRACES, traces, 0);
  }
  void add_road_type(Gos::RoadType road_type) {
    fbb_.AddElement<int32_t>(LocationContainer::VT_ROAD_TYPE, static_cast<int32_t>(road_type), 0);
  }
  explicit LocationContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LocationContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LocationContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LocationContainer> CreateLocationContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::Speed> event_speed = 0,
    ::flatbuffers::Offset<Gos::Heading> event_position_heading = 0,
    uint32_t traces = 0,
    Gos::RoadType road_type = Gos::RoadType_RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES) {
  LocationContainerBuilder builder_(_fbb);
  builder_.add_road_type(road_type);
  builder_.add_traces(traces);
  builder_.add_event_position_heading(event_position_heading);
  builder_.add_event_speed(event_speed);
  return builder_.Finish();
}

struct DenmManagementContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DenmManagementContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION_ID = 4,
    VT_DETECTION_TIME = 6,
    VT_REFERENCE_TIME = 8,
    VT_TERMINATION = 10,
    VT_EVENT_POSITION = 12,
    VT_RELEVANCE_DISTANCE = 14,
    VT_RELEVANCE_TRAFFIC_DIRECTION = 16,
    VT_VALIDITY_DURATION = 18,
    VT_TRANSMISSION_INTERVAL = 20,
    VT_STATION_TYPE = 22
  };
  const Gos::ActionID *action_id() const {
    return GetPointer<const Gos::ActionID *>(VT_ACTION_ID);
  }
  uint64_t detection_time() const {
    return GetField<uint64_t>(VT_DETECTION_TIME, 0);
  }
  uint64_t reference_time() const {
    return GetField<uint64_t>(VT_REFERENCE_TIME, 0);
  }
  Gos::Termination termination() const {
    return static_cast<Gos::Termination>(GetField<int32_t>(VT_TERMINATION, 0));
  }
  const Gos::ReferencePosition *event_position() const {
    return GetPointer<const Gos::ReferencePosition *>(VT_EVENT_POSITION);
  }
  Gos::RelevanceDistance relevance_distance() const {
    return static_cast<Gos::RelevanceDistance>(GetField<int32_t>(VT_RELEVANCE_DISTANCE, 0));
  }
  Gos::RelevanceTrafficDirection relevance_traffic_direction() const {
    return static_cast<Gos::RelevanceTrafficDirection>(GetField<int32_t>(VT_RELEVANCE_TRAFFIC_DIRECTION, 0));
  }
  uint32_t validity_duration() const {
    return GetField<uint32_t>(VT_VALIDITY_DURATION, 600);
  }
  uint32_t transmission_interval() const {
    return GetField<uint32_t>(VT_TRANSMISSION_INTERVAL, 0);
  }
  Gos::StationType station_type() const {
    return static_cast<Gos::StationType>(GetField<int32_t>(VT_STATION_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ACTION_ID) &&
           verifier.VerifyTable(action_id()) &&
           VerifyField<uint64_t>(verifier, VT_DETECTION_TIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_REFERENCE_TIME, 8) &&
           VerifyField<int32_t>(verifier, VT_TERMINATION, 4) &&
           VerifyOffsetRequired(verifier, VT_EVENT_POSITION) &&
           verifier.VerifyTable(event_position()) &&
           VerifyField<int32_t>(verifier, VT_RELEVANCE_DISTANCE, 4) &&
           VerifyField<int32_t>(verifier, VT_RELEVANCE_TRAFFIC_DIRECTION, 4) &&
           VerifyField<uint32_t>(verifier, VT_VALIDITY_DURATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_TRANSMISSION_INTERVAL, 4) &&
           VerifyField<int32_t>(verifier, VT_STATION_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct DenmManagementContainerBuilder {
  typedef DenmManagementContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action_id(::flatbuffers::Offset<Gos::ActionID> action_id) {
    fbb_.AddOffset(DenmManagementContainer::VT_ACTION_ID, action_id);
  }
  void add_detection_time(uint64_t detection_time) {
    fbb_.AddElement<uint64_t>(DenmManagementContainer::VT_DETECTION_TIME, detection_time, 0);
  }
  void add_reference_time(uint64_t reference_time) {
    fbb_.AddElement<uint64_t>(DenmManagementContainer::VT_REFERENCE_TIME, reference_time, 0);
  }
  void add_termination(Gos::Termination termination) {
    fbb_.AddElement<int32_t>(DenmManagementContainer::VT_TERMINATION, static_cast<int32_t>(termination), 0);
  }
  void add_event_position(::flatbuffers::Offset<Gos::ReferencePosition> event_position) {
    fbb_.AddOffset(DenmManagementContainer::VT_EVENT_POSITION, event_position);
  }
  void add_relevance_distance(Gos::RelevanceDistance relevance_distance) {
    fbb_.AddElement<int32_t>(DenmManagementContainer::VT_RELEVANCE_DISTANCE, static_cast<int32_t>(relevance_distance), 0);
  }
  void add_relevance_traffic_direction(Gos::RelevanceTrafficDirection relevance_traffic_direction) {
    fbb_.AddElement<int32_t>(DenmManagementContainer::VT_RELEVANCE_TRAFFIC_DIRECTION, static_cast<int32_t>(relevance_traffic_direction), 0);
  }
  void add_validity_duration(uint32_t validity_duration) {
    fbb_.AddElement<uint32_t>(DenmManagementContainer::VT_VALIDITY_DURATION, validity_duration, 600);
  }
  void add_transmission_interval(uint32_t transmission_interval) {
    fbb_.AddElement<uint32_t>(DenmManagementContainer::VT_TRANSMISSION_INTERVAL, transmission_interval, 0);
  }
  void add_station_type(Gos::StationType station_type) {
    fbb_.AddElement<int32_t>(DenmManagementContainer::VT_STATION_TYPE, static_cast<int32_t>(station_type), 0);
  }
  explicit DenmManagementContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DenmManagementContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DenmManagementContainer>(end);
    fbb_.Required(o, DenmManagementContainer::VT_ACTION_ID);
    fbb_.Required(o, DenmManagementContainer::VT_EVENT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<DenmManagementContainer> CreateDenmManagementContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::ActionID> action_id = 0,
    uint64_t detection_time = 0,
    uint64_t reference_time = 0,
    Gos::Termination termination = Gos::Termination_TRMNTN_IS_CANCELLATION,
    ::flatbuffers::Offset<Gos::ReferencePosition> event_position = 0,
    Gos::RelevanceDistance relevance_distance = Gos::RelevanceDistance_REL_DIST_LESS_THAN_50M,
    Gos::RelevanceTrafficDirection relevance_traffic_direction = Gos::RelevanceTrafficDirection_REL_TD_ALL_TRAFFIC_DIRECTIONS,
    uint32_t validity_duration = 600,
    uint32_t transmission_interval = 0,
    Gos::StationType station_type = Gos::StationType_STN_TYPE_UNKNOWN) {
  DenmManagementContainerBuilder builder_(_fbb);
  builder_.add_reference_time(reference_time);
  builder_.add_detection_time(detection_time);
  builder_.add_station_type(station_type);
  builder_.add_transmission_interval(transmission_interval);
  builder_.add_validity_duration(validity_duration);
  builder_.add_relevance_traffic_direction(relevance_traffic_direction);
  builder_.add_relevance_distance(relevance_distance);
  builder_.add_event_position(event_position);
  builder_.add_termination(termination);
  builder_.add_action_id(action_id);
  return builder_.Finish();
}

struct RoadWorksContainerExtended FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoadWorksContainerExtendedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIGHT_BAR_SIREN_IN_USE = 4,
    VT_CLOSED_LANES = 6,
    VT_RESTRICTION = 8,
    VT_SPEED_LIMIT = 10,
    VT_INCIDENT_INDICATION = 12,
    VT_RECOMMENDED_PATH = 14,
    VT_STARTING_POINT_SPEED_LIMIT = 16,
    VT_TRAFFIC_FLOW_RULE = 18,
    VT_REFERENCE_DENMS = 20
  };
  Gos::LightBarSirenInUse light_bar_siren_in_use() const {
    return static_cast<Gos::LightBarSirenInUse>(GetField<int32_t>(VT_LIGHT_BAR_SIREN_IN_USE, 0));
  }
  const Gos::ClosedLanes *closed_lanes() const {
    return GetPointer<const Gos::ClosedLanes *>(VT_CLOSED_LANES);
  }
  const Gos::RestrictedTypes *restriction() const {
    return GetPointer<const Gos::RestrictedTypes *>(VT_RESTRICTION);
  }
  uint32_t speed_limit() const {
    return GetField<uint32_t>(VT_SPEED_LIMIT, 0);
  }
  const Gos::CauseCode *incident_indication() const {
    return GetPointer<const Gos::CauseCode *>(VT_INCIDENT_INDICATION);
  }
  const Gos::ItineraryPath *recommended_path() const {
    return GetPointer<const Gos::ItineraryPath *>(VT_RECOMMENDED_PATH);
  }
  const Gos::DeltaReferencePosition *starting_point_speed_limit() const {
    return GetPointer<const Gos::DeltaReferencePosition *>(VT_STARTING_POINT_SPEED_LIMIT);
  }
  Gos::TrafficRule traffic_flow_rule() const {
    return static_cast<Gos::TrafficRule>(GetField<int32_t>(VT_TRAFFIC_FLOW_RULE, 0));
  }
  const Gos::ReferenceDenms *reference_denms() const {
    return GetPointer<const Gos::ReferenceDenms *>(VT_REFERENCE_DENMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LIGHT_BAR_SIREN_IN_USE, 4) &&
           VerifyOffset(verifier, VT_CLOSED_LANES) &&
           verifier.VerifyTable(closed_lanes()) &&
           VerifyOffset(verifier, VT_RESTRICTION) &&
           verifier.VerifyTable(restriction()) &&
           VerifyField<uint32_t>(verifier, VT_SPEED_LIMIT, 4) &&
           VerifyOffset(verifier, VT_INCIDENT_INDICATION) &&
           verifier.VerifyTable(incident_indication()) &&
           VerifyOffset(verifier, VT_RECOMMENDED_PATH) &&
           verifier.VerifyTable(recommended_path()) &&
           VerifyOffset(verifier, VT_STARTING_POINT_SPEED_LIMIT) &&
           verifier.VerifyTable(starting_point_speed_limit()) &&
           VerifyField<int32_t>(verifier, VT_TRAFFIC_FLOW_RULE, 4) &&
           VerifyOffset(verifier, VT_REFERENCE_DENMS) &&
           verifier.VerifyTable(reference_denms()) &&
           verifier.EndTable();
  }
};

struct RoadWorksContainerExtendedBuilder {
  typedef RoadWorksContainerExtended Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_light_bar_siren_in_use(Gos::LightBarSirenInUse light_bar_siren_in_use) {
    fbb_.AddElement<int32_t>(RoadWorksContainerExtended::VT_LIGHT_BAR_SIREN_IN_USE, static_cast<int32_t>(light_bar_siren_in_use), 0);
  }
  void add_closed_lanes(::flatbuffers::Offset<Gos::ClosedLanes> closed_lanes) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_CLOSED_LANES, closed_lanes);
  }
  void add_restriction(::flatbuffers::Offset<Gos::RestrictedTypes> restriction) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_RESTRICTION, restriction);
  }
  void add_speed_limit(uint32_t speed_limit) {
    fbb_.AddElement<uint32_t>(RoadWorksContainerExtended::VT_SPEED_LIMIT, speed_limit, 0);
  }
  void add_incident_indication(::flatbuffers::Offset<Gos::CauseCode> incident_indication) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_INCIDENT_INDICATION, incident_indication);
  }
  void add_recommended_path(::flatbuffers::Offset<Gos::ItineraryPath> recommended_path) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_RECOMMENDED_PATH, recommended_path);
  }
  void add_starting_point_speed_limit(::flatbuffers::Offset<Gos::DeltaReferencePosition> starting_point_speed_limit) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_STARTING_POINT_SPEED_LIMIT, starting_point_speed_limit);
  }
  void add_traffic_flow_rule(Gos::TrafficRule traffic_flow_rule) {
    fbb_.AddElement<int32_t>(RoadWorksContainerExtended::VT_TRAFFIC_FLOW_RULE, static_cast<int32_t>(traffic_flow_rule), 0);
  }
  void add_reference_denms(::flatbuffers::Offset<Gos::ReferenceDenms> reference_denms) {
    fbb_.AddOffset(RoadWorksContainerExtended::VT_REFERENCE_DENMS, reference_denms);
  }
  explicit RoadWorksContainerExtendedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoadWorksContainerExtended> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoadWorksContainerExtended>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoadWorksContainerExtended> CreateRoadWorksContainerExtended(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::LightBarSirenInUse light_bar_siren_in_use = Gos::LightBarSirenInUse_LS_LIGHTBAR_ACTIVATED,
    ::flatbuffers::Offset<Gos::ClosedLanes> closed_lanes = 0,
    ::flatbuffers::Offset<Gos::RestrictedTypes> restriction = 0,
    uint32_t speed_limit = 0,
    ::flatbuffers::Offset<Gos::CauseCode> incident_indication = 0,
    ::flatbuffers::Offset<Gos::ItineraryPath> recommended_path = 0,
    ::flatbuffers::Offset<Gos::DeltaReferencePosition> starting_point_speed_limit = 0,
    Gos::TrafficRule traffic_flow_rule = Gos::TrafficRule_TR_NOPASSING,
    ::flatbuffers::Offset<Gos::ReferenceDenms> reference_denms = 0) {
  RoadWorksContainerExtendedBuilder builder_(_fbb);
  builder_.add_reference_denms(reference_denms);
  builder_.add_traffic_flow_rule(traffic_flow_rule);
  builder_.add_starting_point_speed_limit(starting_point_speed_limit);
  builder_.add_recommended_path(recommended_path);
  builder_.add_incident_indication(incident_indication);
  builder_.add_speed_limit(speed_limit);
  builder_.add_restriction(restriction);
  builder_.add_closed_lanes(closed_lanes);
  builder_.add_light_bar_siren_in_use(light_bar_siren_in_use);
  return builder_.Finish();
}

struct SituationContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SituationContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFORMATION_QUALITY = 4,
    VT_EVENT_TYPE = 6,
    VT_LINKED_CAUSE = 8,
    VT_EVENT_HISTORY = 10
  };
  uint32_t information_quality() const {
    return GetField<uint32_t>(VT_INFORMATION_QUALITY, 0);
  }
  const Gos::CauseCode *event_type() const {
    return GetPointer<const Gos::CauseCode *>(VT_EVENT_TYPE);
  }
  const Gos::CauseCode *linked_cause() const {
    return GetPointer<const Gos::CauseCode *>(VT_LINKED_CAUSE);
  }
  const Gos::EventHistory *event_history() const {
    return GetPointer<const Gos::EventHistory *>(VT_EVENT_HISTORY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INFORMATION_QUALITY, 4) &&
           VerifyOffsetRequired(verifier, VT_EVENT_TYPE) &&
           verifier.VerifyTable(event_type()) &&
           VerifyOffset(verifier, VT_LINKED_CAUSE) &&
           verifier.VerifyTable(linked_cause()) &&
           VerifyOffset(verifier, VT_EVENT_HISTORY) &&
           verifier.VerifyTable(event_history()) &&
           verifier.EndTable();
  }
};

struct SituationContainerBuilder {
  typedef SituationContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_information_quality(uint32_t information_quality) {
    fbb_.AddElement<uint32_t>(SituationContainer::VT_INFORMATION_QUALITY, information_quality, 0);
  }
  void add_event_type(::flatbuffers::Offset<Gos::CauseCode> event_type) {
    fbb_.AddOffset(SituationContainer::VT_EVENT_TYPE, event_type);
  }
  void add_linked_cause(::flatbuffers::Offset<Gos::CauseCode> linked_cause) {
    fbb_.AddOffset(SituationContainer::VT_LINKED_CAUSE, linked_cause);
  }
  void add_event_history(::flatbuffers::Offset<Gos::EventHistory> event_history) {
    fbb_.AddOffset(SituationContainer::VT_EVENT_HISTORY, event_history);
  }
  explicit SituationContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SituationContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SituationContainer>(end);
    fbb_.Required(o, SituationContainer::VT_EVENT_TYPE);
    return o;
  }
};

inline ::flatbuffers::Offset<SituationContainer> CreateSituationContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t information_quality = 0,
    ::flatbuffers::Offset<Gos::CauseCode> event_type = 0,
    ::flatbuffers::Offset<Gos::CauseCode> linked_cause = 0,
    ::flatbuffers::Offset<Gos::EventHistory> event_history = 0) {
  SituationContainerBuilder builder_(_fbb);
  builder_.add_event_history(event_history);
  builder_.add_linked_cause(linked_cause);
  builder_.add_event_type(event_type);
  builder_.add_information_quality(information_quality);
  return builder_.Finish();
}

struct StationaryVehicleContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StationaryVehicleContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATIONARY_SINCE = 4,
    VT_STATIONARY_CAUSE = 6,
    VT_CARRYING_DANGEROUS_GOODS = 8,
    VT_NUMBER_OF_OCCUPANTS = 10,
    VT_VEHICLE_IDENTIFICATION = 12,
    VT_ENERGY_STORAGE_TYPE = 14
  };
  Gos::StationarySince stationary_since() const {
    return static_cast<Gos::StationarySince>(GetField<int32_t>(VT_STATIONARY_SINCE, 0));
  }
  const Gos::CauseCode *stationary_cause() const {
    return GetPointer<const Gos::CauseCode *>(VT_STATIONARY_CAUSE);
  }
  const Gos::DangerousGoodsExtended *carrying_dangerous_goods() const {
    return GetPointer<const Gos::DangerousGoodsExtended *>(VT_CARRYING_DANGEROUS_GOODS);
  }
  uint32_t number_of_occupants() const {
    return GetField<uint32_t>(VT_NUMBER_OF_OCCUPANTS, 0);
  }
  const Gos::VehicleIdentification *vehicle_identification() const {
    return GetPointer<const Gos::VehicleIdentification *>(VT_VEHICLE_IDENTIFICATION);
  }
  const Gos::EnergyStorageType *energy_storage_type() const {
    return GetPointer<const Gos::EnergyStorageType *>(VT_ENERGY_STORAGE_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATIONARY_SINCE, 4) &&
           VerifyOffset(verifier, VT_STATIONARY_CAUSE) &&
           verifier.VerifyTable(stationary_cause()) &&
           VerifyOffset(verifier, VT_CARRYING_DANGEROUS_GOODS) &&
           verifier.VerifyTable(carrying_dangerous_goods()) &&
           VerifyField<uint32_t>(verifier, VT_NUMBER_OF_OCCUPANTS, 4) &&
           VerifyOffset(verifier, VT_VEHICLE_IDENTIFICATION) &&
           verifier.VerifyTable(vehicle_identification()) &&
           VerifyOffset(verifier, VT_ENERGY_STORAGE_TYPE) &&
           verifier.VerifyTable(energy_storage_type()) &&
           verifier.EndTable();
  }
};

struct StationaryVehicleContainerBuilder {
  typedef StationaryVehicleContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stationary_since(Gos::StationarySince stationary_since) {
    fbb_.AddElement<int32_t>(StationaryVehicleContainer::VT_STATIONARY_SINCE, static_cast<int32_t>(stationary_since), 0);
  }
  void add_stationary_cause(::flatbuffers::Offset<Gos::CauseCode> stationary_cause) {
    fbb_.AddOffset(StationaryVehicleContainer::VT_STATIONARY_CAUSE, stationary_cause);
  }
  void add_carrying_dangerous_goods(::flatbuffers::Offset<Gos::DangerousGoodsExtended> carrying_dangerous_goods) {
    fbb_.AddOffset(StationaryVehicleContainer::VT_CARRYING_DANGEROUS_GOODS, carrying_dangerous_goods);
  }
  void add_number_of_occupants(uint32_t number_of_occupants) {
    fbb_.AddElement<uint32_t>(StationaryVehicleContainer::VT_NUMBER_OF_OCCUPANTS, number_of_occupants, 0);
  }
  void add_vehicle_identification(::flatbuffers::Offset<Gos::VehicleIdentification> vehicle_identification) {
    fbb_.AddOffset(StationaryVehicleContainer::VT_VEHICLE_IDENTIFICATION, vehicle_identification);
  }
  void add_energy_storage_type(::flatbuffers::Offset<Gos::EnergyStorageType> energy_storage_type) {
    fbb_.AddOffset(StationaryVehicleContainer::VT_ENERGY_STORAGE_TYPE, energy_storage_type);
  }
  explicit StationaryVehicleContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StationaryVehicleContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StationaryVehicleContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StationaryVehicleContainer> CreateStationaryVehicleContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::StationarySince stationary_since = Gos::StationarySince_STATIONARY_SINCE_LESSTHAN1MINUTE,
    ::flatbuffers::Offset<Gos::CauseCode> stationary_cause = 0,
    ::flatbuffers::Offset<Gos::DangerousGoodsExtended> carrying_dangerous_goods = 0,
    uint32_t number_of_occupants = 0,
    ::flatbuffers::Offset<Gos::VehicleIdentification> vehicle_identification = 0,
    ::flatbuffers::Offset<Gos::EnergyStorageType> energy_storage_type = 0) {
  StationaryVehicleContainerBuilder builder_(_fbb);
  builder_.add_energy_storage_type(energy_storage_type);
  builder_.add_vehicle_identification(vehicle_identification);
  builder_.add_number_of_occupants(number_of_occupants);
  builder_.add_carrying_dangerous_goods(carrying_dangerous_goods);
  builder_.add_stationary_cause(stationary_cause);
  builder_.add_stationary_since(stationary_since);
  return builder_.Finish();
}

struct Acceleration3dWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Acceleration3dWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POLAR_ACCELERATION = 4,
    VT_CARTESIAN_ACCELERATION = 6
  };
  const Gos::AccelerationPolarWithZ *polar_acceleration() const {
    return GetPointer<const Gos::AccelerationPolarWithZ *>(VT_POLAR_ACCELERATION);
  }
  const Gos::AccelerationCartesian *cartesian_acceleration() const {
    return GetPointer<const Gos::AccelerationCartesian *>(VT_CARTESIAN_ACCELERATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POLAR_ACCELERATION) &&
           verifier.VerifyTable(polar_acceleration()) &&
           VerifyOffset(verifier, VT_CARTESIAN_ACCELERATION) &&
           verifier.VerifyTable(cartesian_acceleration()) &&
           verifier.EndTable();
  }
};

struct Acceleration3dWithConfidenceBuilder {
  typedef Acceleration3dWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_polar_acceleration(::flatbuffers::Offset<Gos::AccelerationPolarWithZ> polar_acceleration) {
    fbb_.AddOffset(Acceleration3dWithConfidence::VT_POLAR_ACCELERATION, polar_acceleration);
  }
  void add_cartesian_acceleration(::flatbuffers::Offset<Gos::AccelerationCartesian> cartesian_acceleration) {
    fbb_.AddOffset(Acceleration3dWithConfidence::VT_CARTESIAN_ACCELERATION, cartesian_acceleration);
  }
  explicit Acceleration3dWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Acceleration3dWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Acceleration3dWithConfidence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Acceleration3dWithConfidence> CreateAcceleration3dWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::AccelerationPolarWithZ> polar_acceleration = 0,
    ::flatbuffers::Offset<Gos::AccelerationCartesian> cartesian_acceleration = 0) {
  Acceleration3dWithConfidenceBuilder builder_(_fbb);
  builder_.add_cartesian_acceleration(cartesian_acceleration);
  builder_.add_polar_acceleration(polar_acceleration);
  return builder_.Finish();
}

struct AccelerationCartesian FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerationCartesianBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_ACCELERATION = 4,
    VT_Y_ACCELERATION = 6,
    VT_Z_ACCELERATION = 8
  };
  const Gos::AccelerationComponent *x_acceleration() const {
    return GetStruct<const Gos::AccelerationComponent *>(VT_X_ACCELERATION);
  }
  const Gos::AccelerationComponent *y_acceleration() const {
    return GetStruct<const Gos::AccelerationComponent *>(VT_Y_ACCELERATION);
  }
  const Gos::AccelerationComponent *z_acceleration() const {
    return GetStruct<const Gos::AccelerationComponent *>(VT_Z_ACCELERATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Gos::AccelerationComponent>(verifier, VT_X_ACCELERATION, 4) &&
           VerifyFieldRequired<Gos::AccelerationComponent>(verifier, VT_Y_ACCELERATION, 4) &&
           VerifyField<Gos::AccelerationComponent>(verifier, VT_Z_ACCELERATION, 4) &&
           verifier.EndTable();
  }
};

struct AccelerationCartesianBuilder {
  typedef AccelerationCartesian Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_acceleration(const Gos::AccelerationComponent *x_acceleration) {
    fbb_.AddStruct(AccelerationCartesian::VT_X_ACCELERATION, x_acceleration);
  }
  void add_y_acceleration(const Gos::AccelerationComponent *y_acceleration) {
    fbb_.AddStruct(AccelerationCartesian::VT_Y_ACCELERATION, y_acceleration);
  }
  void add_z_acceleration(const Gos::AccelerationComponent *z_acceleration) {
    fbb_.AddStruct(AccelerationCartesian::VT_Z_ACCELERATION, z_acceleration);
  }
  explicit AccelerationCartesianBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerationCartesian> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerationCartesian>(end);
    fbb_.Required(o, AccelerationCartesian::VT_X_ACCELERATION);
    fbb_.Required(o, AccelerationCartesian::VT_Y_ACCELERATION);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerationCartesian> CreateAccelerationCartesian(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Gos::AccelerationComponent *x_acceleration = nullptr,
    const Gos::AccelerationComponent *y_acceleration = nullptr,
    const Gos::AccelerationComponent *z_acceleration = nullptr) {
  AccelerationCartesianBuilder builder_(_fbb);
  builder_.add_z_acceleration(z_acceleration);
  builder_.add_y_acceleration(y_acceleration);
  builder_.add_x_acceleration(x_acceleration);
  return builder_.Finish();
}

struct AccelerationMagnitude FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerationMagnitudeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCELERATION_MAGNITUDE_VALUE = 4,
    VT_ACCELERATION_CONFIDENCE = 6
  };
  uint32_t acceleration_magnitude_value() const {
    return GetField<uint32_t>(VT_ACCELERATION_MAGNITUDE_VALUE, 0);
  }
  uint32_t acceleration_confidence() const {
    return GetField<uint32_t>(VT_ACCELERATION_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACCELERATION_MAGNITUDE_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACCELERATION_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct AccelerationMagnitudeBuilder {
  typedef AccelerationMagnitude Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_acceleration_magnitude_value(uint32_t acceleration_magnitude_value) {
    fbb_.AddElement<uint32_t>(AccelerationMagnitude::VT_ACCELERATION_MAGNITUDE_VALUE, acceleration_magnitude_value, 0);
  }
  void add_acceleration_confidence(uint32_t acceleration_confidence) {
    fbb_.AddElement<uint32_t>(AccelerationMagnitude::VT_ACCELERATION_CONFIDENCE, acceleration_confidence, 0);
  }
  explicit AccelerationMagnitudeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerationMagnitude> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerationMagnitude>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerationMagnitude> CreateAccelerationMagnitude(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t acceleration_magnitude_value = 0,
    uint32_t acceleration_confidence = 0) {
  AccelerationMagnitudeBuilder builder_(_fbb);
  builder_.add_acceleration_confidence(acceleration_confidence);
  builder_.add_acceleration_magnitude_value(acceleration_magnitude_value);
  return builder_.Finish();
}

struct AccelerationPolarWithZ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerationPolarWithZBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCELERATION_MAGNITUDE = 4,
    VT_ACCELERATION_DIRECTION = 6,
    VT_Z_ACCELERATION = 8
  };
  const Gos::AccelerationMagnitude *acceleration_magnitude() const {
    return GetPointer<const Gos::AccelerationMagnitude *>(VT_ACCELERATION_MAGNITUDE);
  }
  const Gos::CartesianAngle *acceleration_direction() const {
    return GetPointer<const Gos::CartesianAngle *>(VT_ACCELERATION_DIRECTION);
  }
  const Gos::AccelerationComponent *z_acceleration() const {
    return GetStruct<const Gos::AccelerationComponent *>(VT_Z_ACCELERATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ACCELERATION_MAGNITUDE) &&
           verifier.VerifyTable(acceleration_magnitude()) &&
           VerifyOffsetRequired(verifier, VT_ACCELERATION_DIRECTION) &&
           verifier.VerifyTable(acceleration_direction()) &&
           VerifyField<Gos::AccelerationComponent>(verifier, VT_Z_ACCELERATION, 4) &&
           verifier.EndTable();
  }
};

struct AccelerationPolarWithZBuilder {
  typedef AccelerationPolarWithZ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_acceleration_magnitude(::flatbuffers::Offset<Gos::AccelerationMagnitude> acceleration_magnitude) {
    fbb_.AddOffset(AccelerationPolarWithZ::VT_ACCELERATION_MAGNITUDE, acceleration_magnitude);
  }
  void add_acceleration_direction(::flatbuffers::Offset<Gos::CartesianAngle> acceleration_direction) {
    fbb_.AddOffset(AccelerationPolarWithZ::VT_ACCELERATION_DIRECTION, acceleration_direction);
  }
  void add_z_acceleration(const Gos::AccelerationComponent *z_acceleration) {
    fbb_.AddStruct(AccelerationPolarWithZ::VT_Z_ACCELERATION, z_acceleration);
  }
  explicit AccelerationPolarWithZBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerationPolarWithZ> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerationPolarWithZ>(end);
    fbb_.Required(o, AccelerationPolarWithZ::VT_ACCELERATION_MAGNITUDE);
    fbb_.Required(o, AccelerationPolarWithZ::VT_ACCELERATION_DIRECTION);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerationPolarWithZ> CreateAccelerationPolarWithZ(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::AccelerationMagnitude> acceleration_magnitude = 0,
    ::flatbuffers::Offset<Gos::CartesianAngle> acceleration_direction = 0,
    const Gos::AccelerationComponent *z_acceleration = nullptr) {
  AccelerationPolarWithZBuilder builder_(_fbb);
  builder_.add_z_acceleration(z_acceleration);
  builder_.add_acceleration_direction(acceleration_direction);
  builder_.add_acceleration_magnitude(acceleration_magnitude);
  return builder_.Finish();
}

struct ActionID FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActionIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGINATING_STATION_ID = 4,
    VT_SEQUENCE_NUMBER = 6
  };
  uint64_t originating_station_id() const {
    return GetField<uint64_t>(VT_ORIGINATING_STATION_ID, 0);
  }
  uint32_t sequence_number() const {
    return GetField<uint32_t>(VT_SEQUENCE_NUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ORIGINATING_STATION_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE_NUMBER, 4) &&
           verifier.EndTable();
  }
};

struct ActionIDBuilder {
  typedef ActionID Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_originating_station_id(uint64_t originating_station_id) {
    fbb_.AddElement<uint64_t>(ActionID::VT_ORIGINATING_STATION_ID, originating_station_id, 0);
  }
  void add_sequence_number(uint32_t sequence_number) {
    fbb_.AddElement<uint32_t>(ActionID::VT_SEQUENCE_NUMBER, sequence_number, 0);
  }
  explicit ActionIDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActionID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActionID>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ActionID> CreateActionID(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t originating_station_id = 0,
    uint32_t sequence_number = 0) {
  ActionIDBuilder builder_(_fbb);
  builder_.add_originating_station_id(originating_station_id);
  builder_.add_sequence_number(sequence_number);
  return builder_.Finish();
}

struct Altitude FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AltitudeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct AltitudeBuilder {
  typedef Altitude Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Altitude::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(Altitude::VT_CONFIDENCE, confidence, 0);
  }
  explicit AltitudeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Altitude> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Altitude>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Altitude> CreateAltitude(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  AltitudeBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CartesianAngle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianAngleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CARTESIAN_VALUE = 4,
    VT_CARTESIAN_ANGLE_CONFIDENCE = 6
  };
  int64_t cartesian_value() const {
    return GetField<int64_t>(VT_CARTESIAN_VALUE, 0);
  }
  int64_t cartesian_angle_confidence() const {
    return GetField<int64_t>(VT_CARTESIAN_ANGLE_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CARTESIAN_VALUE, 8) &&
           VerifyField<int64_t>(verifier, VT_CARTESIAN_ANGLE_CONFIDENCE, 8) &&
           verifier.EndTable();
  }
};

struct CartesianAngleBuilder {
  typedef CartesianAngle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cartesian_value(int64_t cartesian_value) {
    fbb_.AddElement<int64_t>(CartesianAngle::VT_CARTESIAN_VALUE, cartesian_value, 0);
  }
  void add_cartesian_angle_confidence(int64_t cartesian_angle_confidence) {
    fbb_.AddElement<int64_t>(CartesianAngle::VT_CARTESIAN_ANGLE_CONFIDENCE, cartesian_angle_confidence, 0);
  }
  explicit CartesianAngleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianAngle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianAngle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianAngle> CreateCartesianAngle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t cartesian_value = 0,
    int64_t cartesian_angle_confidence = 0) {
  CartesianAngleBuilder builder_(_fbb);
  builder_.add_cartesian_angle_confidence(cartesian_angle_confidence);
  builder_.add_cartesian_value(cartesian_value);
  return builder_.Finish();
}

struct CartesianAngularVelocityComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianAngularVelocityComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  Gos::AngularSpeedConfidence confidence() const {
    return static_cast<Gos::AngularSpeedConfidence>(GetField<int32_t>(VT_CONFIDENCE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct CartesianAngularVelocityComponentBuilder {
  typedef CartesianAngularVelocityComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CartesianAngularVelocityComponent::VT_VALUE, value, 0);
  }
  void add_confidence(Gos::AngularSpeedConfidence confidence) {
    fbb_.AddElement<int32_t>(CartesianAngularVelocityComponent::VT_CONFIDENCE, static_cast<int32_t>(confidence), 0);
  }
  explicit CartesianAngularVelocityComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianAngularVelocityComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianAngularVelocityComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianAngularVelocityComponent> CreateCartesianAngularVelocityComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    Gos::AngularSpeedConfidence confidence = Gos::AngularSpeedConfidence_ASC_DEGSEC_01) {
  CartesianAngularVelocityComponentBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CartesianPosition3d FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianPosition3dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_CORD = 4,
    VT_Y_CORD = 6,
    VT_Z_CORD = 8
  };
  int32_t x_cord() const {
    return GetField<int32_t>(VT_X_CORD, 0);
  }
  int32_t y_cord() const {
    return GetField<int32_t>(VT_Y_CORD, 0);
  }
  int32_t z_cord() const {
    return GetField<int32_t>(VT_Z_CORD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X_CORD, 4) &&
           VerifyField<int32_t>(verifier, VT_Y_CORD, 4) &&
           VerifyField<int32_t>(verifier, VT_Z_CORD, 4) &&
           verifier.EndTable();
  }
};

struct CartesianPosition3dBuilder {
  typedef CartesianPosition3d Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_cord(int32_t x_cord) {
    fbb_.AddElement<int32_t>(CartesianPosition3d::VT_X_CORD, x_cord, 0);
  }
  void add_y_cord(int32_t y_cord) {
    fbb_.AddElement<int32_t>(CartesianPosition3d::VT_Y_CORD, y_cord, 0);
  }
  void add_z_cord(int32_t z_cord) {
    fbb_.AddElement<int32_t>(CartesianPosition3d::VT_Z_CORD, z_cord, 0);
  }
  explicit CartesianPosition3dBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianPosition3d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianPosition3d>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianPosition3d> CreateCartesianPosition3d(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x_cord = 0,
    int32_t y_cord = 0,
    int32_t z_cord = 0) {
  CartesianPosition3dBuilder builder_(_fbb);
  builder_.add_z_cord(z_cord);
  builder_.add_y_cord(y_cord);
  builder_.add_x_cord(x_cord);
  return builder_.Finish();
}

struct CartesianCoordinateWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianCoordinateWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct CartesianCoordinateWithConfidenceBuilder {
  typedef CartesianCoordinateWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CartesianCoordinateWithConfidence::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(CartesianCoordinateWithConfidence::VT_CONFIDENCE, confidence, 0);
  }
  explicit CartesianCoordinateWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianCoordinateWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianCoordinateWithConfidence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianCoordinateWithConfidence> CreateCartesianCoordinateWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  CartesianCoordinateWithConfidenceBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CartesianPosition3dWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianPosition3dWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_CORD = 4,
    VT_Y_CORD = 6,
    VT_Z_CORD = 8
  };
  const Gos::CartesianCoordinateWithConfidence *x_cord() const {
    return GetPointer<const Gos::CartesianCoordinateWithConfidence *>(VT_X_CORD);
  }
  const Gos::CartesianCoordinateWithConfidence *y_cord() const {
    return GetPointer<const Gos::CartesianCoordinateWithConfidence *>(VT_Y_CORD);
  }
  const Gos::CartesianCoordinateWithConfidence *z_cord() const {
    return GetPointer<const Gos::CartesianCoordinateWithConfidence *>(VT_Z_CORD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_X_CORD) &&
           verifier.VerifyTable(x_cord()) &&
           VerifyOffsetRequired(verifier, VT_Y_CORD) &&
           verifier.VerifyTable(y_cord()) &&
           VerifyOffset(verifier, VT_Z_CORD) &&
           verifier.VerifyTable(z_cord()) &&
           verifier.EndTable();
  }
};

struct CartesianPosition3dWithConfidenceBuilder {
  typedef CartesianPosition3dWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_cord(::flatbuffers::Offset<Gos::CartesianCoordinateWithConfidence> x_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_X_CORD, x_cord);
  }
  void add_y_cord(::flatbuffers::Offset<Gos::CartesianCoordinateWithConfidence> y_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_Y_CORD, y_cord);
  }
  void add_z_cord(::flatbuffers::Offset<Gos::CartesianCoordinateWithConfidence> z_cord) {
    fbb_.AddOffset(CartesianPosition3dWithConfidence::VT_Z_CORD, z_cord);
  }
  explicit CartesianPosition3dWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianPosition3dWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianPosition3dWithConfidence>(end);
    fbb_.Required(o, CartesianPosition3dWithConfidence::VT_X_CORD);
    fbb_.Required(o, CartesianPosition3dWithConfidence::VT_Y_CORD);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianPosition3dWithConfidence> CreateCartesianPosition3dWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::CartesianCoordinateWithConfidence> x_cord = 0,
    ::flatbuffers::Offset<Gos::CartesianCoordinateWithConfidence> y_cord = 0,
    ::flatbuffers::Offset<Gos::CartesianCoordinateWithConfidence> z_cord = 0) {
  CartesianPosition3dWithConfidenceBuilder builder_(_fbb);
  builder_.add_z_cord(z_cord);
  builder_.add_y_cord(y_cord);
  builder_.add_x_cord(x_cord);
  return builder_.Finish();
}

struct CircularShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircularShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE_REF_POINT = 4,
    VT_RADIUS = 6,
    VT_HEIGHT = 8
  };
  const Gos::CartesianPosition3d *shape_ref_point() const {
    return GetPointer<const Gos::CartesianPosition3d *>(VT_SHAPE_REF_POINT);
  }
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE_REF_POINT) &&
           verifier.VerifyTable(shape_ref_point()) &&
           VerifyField<int32_t>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct CircularShapeBuilder {
  typedef CircularShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape_ref_point(::flatbuffers::Offset<Gos::CartesianPosition3d> shape_ref_point) {
    fbb_.AddOffset(CircularShape::VT_SHAPE_REF_POINT, shape_ref_point);
  }
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(CircularShape::VT_RADIUS, radius, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(CircularShape::VT_HEIGHT, height, 0);
  }
  explicit CircularShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircularShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircularShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CircularShape> CreateCircularShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::CartesianPosition3d> shape_ref_point = 0,
    int32_t radius = 0,
    uint32_t height = 0) {
  CircularShapeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_radius(radius);
  builder_.add_shape_ref_point(shape_ref_point);
  return builder_.Finish();
}

struct ClosedLanes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClosedLanesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INNER_HARD_SHOULDER_STATUS = 4,
    VT_OUTER_HARD_SHOULDER_STATUS = 6,
    VT_DRIVING_LANE_STATUS = 8
  };
  Gos::HardShoulderStatus inner_hard_shoulder_status() const {
    return static_cast<Gos::HardShoulderStatus>(GetField<int32_t>(VT_INNER_HARD_SHOULDER_STATUS, 0));
  }
  Gos::HardShoulderStatus outer_hard_shoulder_status() const {
    return static_cast<Gos::HardShoulderStatus>(GetField<int32_t>(VT_OUTER_HARD_SHOULDER_STATUS, 0));
  }
  uint32_t driving_lane_status() const {
    return GetField<uint32_t>(VT_DRIVING_LANE_STATUS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INNER_HARD_SHOULDER_STATUS, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTER_HARD_SHOULDER_STATUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_DRIVING_LANE_STATUS, 4) &&
           verifier.EndTable();
  }
};

struct ClosedLanesBuilder {
  typedef ClosedLanes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inner_hard_shoulder_status(Gos::HardShoulderStatus inner_hard_shoulder_status) {
    fbb_.AddElement<int32_t>(ClosedLanes::VT_INNER_HARD_SHOULDER_STATUS, static_cast<int32_t>(inner_hard_shoulder_status), 0);
  }
  void add_outer_hard_shoulder_status(Gos::HardShoulderStatus outer_hard_shoulder_status) {
    fbb_.AddElement<int32_t>(ClosedLanes::VT_OUTER_HARD_SHOULDER_STATUS, static_cast<int32_t>(outer_hard_shoulder_status), 0);
  }
  void add_driving_lane_status(uint32_t driving_lane_status) {
    fbb_.AddElement<uint32_t>(ClosedLanes::VT_DRIVING_LANE_STATUS, driving_lane_status, 0);
  }
  explicit ClosedLanesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClosedLanes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClosedLanes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClosedLanes> CreateClosedLanes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::HardShoulderStatus inner_hard_shoulder_status = Gos::HardShoulderStatus_HSS_AVAILABLE_FOR_STOPPING,
    Gos::HardShoulderStatus outer_hard_shoulder_status = Gos::HardShoulderStatus_HSS_AVAILABLE_FOR_STOPPING,
    uint32_t driving_lane_status = 0) {
  ClosedLanesBuilder builder_(_fbb);
  builder_.add_driving_lane_status(driving_lane_status);
  builder_.add_outer_hard_shoulder_status(outer_hard_shoulder_status);
  builder_.add_inner_hard_shoulder_status(inner_hard_shoulder_status);
  return builder_.Finish();
}

struct CorrelationColumn FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CorrelationColumnBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct CorrelationColumnBuilder {
  typedef CorrelationColumn Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(CorrelationColumn::VT_VALUE, value);
  }
  explicit CorrelationColumnBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CorrelationColumn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CorrelationColumn>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CorrelationColumn> CreateCorrelationColumn(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value = 0) {
  CorrelationColumnBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CorrelationColumn> CreateCorrelationColumnDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return Gos::CreateCorrelationColumn(
      _fbb,
      value__);
}

struct Curvature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CurvatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  int32_t confidence() const {
    return GetField<int32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct CurvatureBuilder {
  typedef Curvature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Curvature::VT_VALUE, value, 0);
  }
  void add_confidence(int32_t confidence) {
    fbb_.AddElement<int32_t>(Curvature::VT_CONFIDENCE, confidence, 0);
  }
  explicit CurvatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Curvature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Curvature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Curvature> CreateCurvature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    int32_t confidence = 0) {
  CurvatureBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct CauseCode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CauseCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAUSE_CODE = 4,
    VT_SUB_CAUSE_CODE = 6
  };
  Gos::CauseCodeType cause_code() const {
    return static_cast<Gos::CauseCodeType>(GetField<int32_t>(VT_CAUSE_CODE, 0));
  }
  uint32_t sub_cause_code() const {
    return GetField<uint32_t>(VT_SUB_CAUSE_CODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CAUSE_CODE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SUB_CAUSE_CODE, 4) &&
           verifier.EndTable();
  }
};

struct CauseCodeBuilder {
  typedef CauseCode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cause_code(Gos::CauseCodeType cause_code) {
    fbb_.AddElement<int32_t>(CauseCode::VT_CAUSE_CODE, static_cast<int32_t>(cause_code), 0);
  }
  void add_sub_cause_code(uint32_t sub_cause_code) {
    fbb_.AddElement<uint32_t>(CauseCode::VT_SUB_CAUSE_CODE, sub_cause_code, 0);
  }
  explicit CauseCodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CauseCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CauseCode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CauseCode> CreateCauseCode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::CauseCodeType cause_code = Gos::CauseCodeType_CCT_UNKNOWN,
    uint32_t sub_cause_code = 0) {
  CauseCodeBuilder builder_(_fbb);
  builder_.add_sub_cause_code(sub_cause_code);
  builder_.add_cause_code(cause_code);
  return builder_.Finish();
}

struct DangerousGoodsExtended FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DangerousGoodsExtendedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DANGEROUS_GOODS_TYPE = 4,
    VT_UN_NUMBER = 6,
    VT_ELEVATED_TEMPERATURE = 8,
    VT_TUNNELS_RESTRICTED = 10,
    VT_LIMITED_QUANTITY = 12,
    VT_EMERGENCY_ACTION_CODE = 14,
    VT_PHONE_NUMBER = 16,
    VT_COMPANY_NAME = 18
  };
  Gos::DangerousGoodsBasic dangerous_goods_type() const {
    return static_cast<Gos::DangerousGoodsBasic>(GetField<int32_t>(VT_DANGEROUS_GOODS_TYPE, 0));
  }
  uint32_t un_number() const {
    return GetField<uint32_t>(VT_UN_NUMBER, 0);
  }
  bool elevated_temperature() const {
    return GetField<uint8_t>(VT_ELEVATED_TEMPERATURE, 0) != 0;
  }
  bool tunnels_restricted() const {
    return GetField<uint8_t>(VT_TUNNELS_RESTRICTED, 0) != 0;
  }
  bool limited_quantity() const {
    return GetField<uint8_t>(VT_LIMITED_QUANTITY, 0) != 0;
  }
  const ::flatbuffers::String *emergency_action_code() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EMERGENCY_ACTION_CODE);
  }
  const ::flatbuffers::String *phone_number() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PHONE_NUMBER);
  }
  const ::flatbuffers::String *company_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMPANY_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DANGEROUS_GOODS_TYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_UN_NUMBER, 4) &&
           VerifyField<uint8_t>(verifier, VT_ELEVATED_TEMPERATURE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TUNNELS_RESTRICTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIMITED_QUANTITY, 1) &&
           VerifyOffset(verifier, VT_EMERGENCY_ACTION_CODE) &&
           verifier.VerifyString(emergency_action_code()) &&
           VerifyOffset(verifier, VT_PHONE_NUMBER) &&
           verifier.VerifyString(phone_number()) &&
           VerifyOffset(verifier, VT_COMPANY_NAME) &&
           verifier.VerifyString(company_name()) &&
           verifier.EndTable();
  }
};

struct DangerousGoodsExtendedBuilder {
  typedef DangerousGoodsExtended Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dangerous_goods_type(Gos::DangerousGoodsBasic dangerous_goods_type) {
    fbb_.AddElement<int32_t>(DangerousGoodsExtended::VT_DANGEROUS_GOODS_TYPE, static_cast<int32_t>(dangerous_goods_type), 0);
  }
  void add_un_number(uint32_t un_number) {
    fbb_.AddElement<uint32_t>(DangerousGoodsExtended::VT_UN_NUMBER, un_number, 0);
  }
  void add_elevated_temperature(bool elevated_temperature) {
    fbb_.AddElement<uint8_t>(DangerousGoodsExtended::VT_ELEVATED_TEMPERATURE, static_cast<uint8_t>(elevated_temperature), 0);
  }
  void add_tunnels_restricted(bool tunnels_restricted) {
    fbb_.AddElement<uint8_t>(DangerousGoodsExtended::VT_TUNNELS_RESTRICTED, static_cast<uint8_t>(tunnels_restricted), 0);
  }
  void add_limited_quantity(bool limited_quantity) {
    fbb_.AddElement<uint8_t>(DangerousGoodsExtended::VT_LIMITED_QUANTITY, static_cast<uint8_t>(limited_quantity), 0);
  }
  void add_emergency_action_code(::flatbuffers::Offset<::flatbuffers::String> emergency_action_code) {
    fbb_.AddOffset(DangerousGoodsExtended::VT_EMERGENCY_ACTION_CODE, emergency_action_code);
  }
  void add_phone_number(::flatbuffers::Offset<::flatbuffers::String> phone_number) {
    fbb_.AddOffset(DangerousGoodsExtended::VT_PHONE_NUMBER, phone_number);
  }
  void add_company_name(::flatbuffers::Offset<::flatbuffers::String> company_name) {
    fbb_.AddOffset(DangerousGoodsExtended::VT_COMPANY_NAME, company_name);
  }
  explicit DangerousGoodsExtendedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DangerousGoodsExtended> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DangerousGoodsExtended>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DangerousGoodsExtended> CreateDangerousGoodsExtended(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::DangerousGoodsBasic dangerous_goods_type = Gos::DangerousGoodsBasic_DGB_EXPLOSIVES1,
    uint32_t un_number = 0,
    bool elevated_temperature = false,
    bool tunnels_restricted = false,
    bool limited_quantity = false,
    ::flatbuffers::Offset<::flatbuffers::String> emergency_action_code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> phone_number = 0,
    ::flatbuffers::Offset<::flatbuffers::String> company_name = 0) {
  DangerousGoodsExtendedBuilder builder_(_fbb);
  builder_.add_company_name(company_name);
  builder_.add_phone_number(phone_number);
  builder_.add_emergency_action_code(emergency_action_code);
  builder_.add_un_number(un_number);
  builder_.add_dangerous_goods_type(dangerous_goods_type);
  builder_.add_limited_quantity(limited_quantity);
  builder_.add_tunnels_restricted(tunnels_restricted);
  builder_.add_elevated_temperature(elevated_temperature);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DangerousGoodsExtended> CreateDangerousGoodsExtendedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::DangerousGoodsBasic dangerous_goods_type = Gos::DangerousGoodsBasic_DGB_EXPLOSIVES1,
    uint32_t un_number = 0,
    bool elevated_temperature = false,
    bool tunnels_restricted = false,
    bool limited_quantity = false,
    const char *emergency_action_code = nullptr,
    const char *phone_number = nullptr,
    const char *company_name = nullptr) {
  auto emergency_action_code__ = emergency_action_code ? _fbb.CreateString(emergency_action_code) : 0;
  auto phone_number__ = phone_number ? _fbb.CreateString(phone_number) : 0;
  auto company_name__ = company_name ? _fbb.CreateString(company_name) : 0;
  return Gos::CreateDangerousGoodsExtended(
      _fbb,
      dangerous_goods_type,
      un_number,
      elevated_temperature,
      tunnels_restricted,
      limited_quantity,
      emergency_action_code__,
      phone_number__,
      company_name__);
}

struct DeltaReferencePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeltaReferencePositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DELTA_LATITUDE = 4,
    VT_DELTA_LONGITUDE = 6,
    VT_DELTA_ALTITUDE = 8
  };
  int32_t delta_latitude() const {
    return GetField<int32_t>(VT_DELTA_LATITUDE, 0);
  }
  int32_t delta_longitude() const {
    return GetField<int32_t>(VT_DELTA_LONGITUDE, 0);
  }
  int32_t delta_altitude() const {
    return GetField<int32_t>(VT_DELTA_ALTITUDE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DELTA_LATITUDE, 4) &&
           VerifyField<int32_t>(verifier, VT_DELTA_LONGITUDE, 4) &&
           VerifyField<int32_t>(verifier, VT_DELTA_ALTITUDE, 4) &&
           verifier.EndTable();
  }
};

struct DeltaReferencePositionBuilder {
  typedef DeltaReferencePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_delta_latitude(int32_t delta_latitude) {
    fbb_.AddElement<int32_t>(DeltaReferencePosition::VT_DELTA_LATITUDE, delta_latitude, 0);
  }
  void add_delta_longitude(int32_t delta_longitude) {
    fbb_.AddElement<int32_t>(DeltaReferencePosition::VT_DELTA_LONGITUDE, delta_longitude, 0);
  }
  void add_delta_altitude(int32_t delta_altitude) {
    fbb_.AddElement<int32_t>(DeltaReferencePosition::VT_DELTA_ALTITUDE, delta_altitude, 0);
  }
  explicit DeltaReferencePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeltaReferencePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeltaReferencePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeltaReferencePosition> CreateDeltaReferencePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t delta_latitude = 0,
    int32_t delta_longitude = 0,
    int32_t delta_altitude = 0) {
  DeltaReferencePositionBuilder builder_(_fbb);
  builder_.add_delta_altitude(delta_altitude);
  builder_.add_delta_longitude(delta_longitude);
  builder_.add_delta_latitude(delta_latitude);
  return builder_.Finish();
}

struct EnergyStorageType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnergyStorageTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HYDROGEN_STORAGE = 4,
    VT_ELECTRIC_ENERGY_STORAGE = 6,
    VT_LIQUID_PROPANE_GAS = 8,
    VT_COMPRESSED_NATURAL_GAS = 10,
    VT_DIESEL = 12,
    VT_GASOLINE = 14,
    VT_AMMONIA = 16
  };
  bool hydrogen_storage() const {
    return GetField<uint8_t>(VT_HYDROGEN_STORAGE, 0) != 0;
  }
  bool electric_energy_storage() const {
    return GetField<uint8_t>(VT_ELECTRIC_ENERGY_STORAGE, 0) != 0;
  }
  bool liquid_propane_gas() const {
    return GetField<uint8_t>(VT_LIQUID_PROPANE_GAS, 0) != 0;
  }
  bool compressed_natural_gas() const {
    return GetField<uint8_t>(VT_COMPRESSED_NATURAL_GAS, 0) != 0;
  }
  bool diesel() const {
    return GetField<uint8_t>(VT_DIESEL, 0) != 0;
  }
  bool gasoline() const {
    return GetField<uint8_t>(VT_GASOLINE, 0) != 0;
  }
  bool ammonia() const {
    return GetField<uint8_t>(VT_AMMONIA, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HYDROGEN_STORAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ELECTRIC_ENERGY_STORAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIQUID_PROPANE_GAS, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMPRESSED_NATURAL_GAS, 1) &&
           VerifyField<uint8_t>(verifier, VT_DIESEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_GASOLINE, 1) &&
           VerifyField<uint8_t>(verifier, VT_AMMONIA, 1) &&
           verifier.EndTable();
  }
};

struct EnergyStorageTypeBuilder {
  typedef EnergyStorageType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hydrogen_storage(bool hydrogen_storage) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_HYDROGEN_STORAGE, static_cast<uint8_t>(hydrogen_storage), 0);
  }
  void add_electric_energy_storage(bool electric_energy_storage) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_ELECTRIC_ENERGY_STORAGE, static_cast<uint8_t>(electric_energy_storage), 0);
  }
  void add_liquid_propane_gas(bool liquid_propane_gas) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_LIQUID_PROPANE_GAS, static_cast<uint8_t>(liquid_propane_gas), 0);
  }
  void add_compressed_natural_gas(bool compressed_natural_gas) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_COMPRESSED_NATURAL_GAS, static_cast<uint8_t>(compressed_natural_gas), 0);
  }
  void add_diesel(bool diesel) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_DIESEL, static_cast<uint8_t>(diesel), 0);
  }
  void add_gasoline(bool gasoline) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_GASOLINE, static_cast<uint8_t>(gasoline), 0);
  }
  void add_ammonia(bool ammonia) {
    fbb_.AddElement<uint8_t>(EnergyStorageType::VT_AMMONIA, static_cast<uint8_t>(ammonia), 0);
  }
  explicit EnergyStorageTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnergyStorageType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnergyStorageType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnergyStorageType> CreateEnergyStorageType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool hydrogen_storage = false,
    bool electric_energy_storage = false,
    bool liquid_propane_gas = false,
    bool compressed_natural_gas = false,
    bool diesel = false,
    bool gasoline = false,
    bool ammonia = false) {
  EnergyStorageTypeBuilder builder_(_fbb);
  builder_.add_ammonia(ammonia);
  builder_.add_gasoline(gasoline);
  builder_.add_diesel(diesel);
  builder_.add_compressed_natural_gas(compressed_natural_gas);
  builder_.add_liquid_propane_gas(liquid_propane_gas);
  builder_.add_electric_energy_storage(electric_energy_storage);
  builder_.add_hydrogen_storage(hydrogen_storage);
  return builder_.Finish();
}

struct EllipticalShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EllipticalShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE_REFERENCE_POINT = 4,
    VT_SEMI_MAJOR_AXIS_LENGTH = 6,
    VT_SEMI_MINOR_AXIS_LENGTH = 8,
    VT_ORIENTATION = 10,
    VT_HEIGHT = 12
  };
  const Gos::CartesianPosition3d *shape_reference_point() const {
    return GetPointer<const Gos::CartesianPosition3d *>(VT_SHAPE_REFERENCE_POINT);
  }
  uint32_t semi_major_axis_length() const {
    return GetField<uint32_t>(VT_SEMI_MAJOR_AXIS_LENGTH, 0);
  }
  uint32_t semi_minor_axis_length() const {
    return GetField<uint32_t>(VT_SEMI_MINOR_AXIS_LENGTH, 0);
  }
  uint32_t orientation() const {
    return GetField<uint32_t>(VT_ORIENTATION, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE_REFERENCE_POINT) &&
           verifier.VerifyTable(shape_reference_point()) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_MAJOR_AXIS_LENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_MINOR_AXIS_LENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_ORIENTATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct EllipticalShapeBuilder {
  typedef EllipticalShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape_reference_point(::flatbuffers::Offset<Gos::CartesianPosition3d> shape_reference_point) {
    fbb_.AddOffset(EllipticalShape::VT_SHAPE_REFERENCE_POINT, shape_reference_point);
  }
  void add_semi_major_axis_length(uint32_t semi_major_axis_length) {
    fbb_.AddElement<uint32_t>(EllipticalShape::VT_SEMI_MAJOR_AXIS_LENGTH, semi_major_axis_length, 0);
  }
  void add_semi_minor_axis_length(uint32_t semi_minor_axis_length) {
    fbb_.AddElement<uint32_t>(EllipticalShape::VT_SEMI_MINOR_AXIS_LENGTH, semi_minor_axis_length, 0);
  }
  void add_orientation(uint32_t orientation) {
    fbb_.AddElement<uint32_t>(EllipticalShape::VT_ORIENTATION, orientation, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(EllipticalShape::VT_HEIGHT, height, 0);
  }
  explicit EllipticalShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EllipticalShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EllipticalShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EllipticalShape> CreateEllipticalShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::CartesianPosition3d> shape_reference_point = 0,
    uint32_t semi_major_axis_length = 0,
    uint32_t semi_minor_axis_length = 0,
    uint32_t orientation = 0,
    uint32_t height = 0) {
  EllipticalShapeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_orientation(orientation);
  builder_.add_semi_minor_axis_length(semi_minor_axis_length);
  builder_.add_semi_major_axis_length(semi_major_axis_length);
  builder_.add_shape_reference_point(shape_reference_point);
  return builder_.Finish();
}

struct EulerAnglesWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EulerAnglesWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Z_ANGLE = 4,
    VT_Y_ANGLE = 6,
    VT_X_ANGLE = 8
  };
  const Gos::CartesianAngle *z_angle() const {
    return GetPointer<const Gos::CartesianAngle *>(VT_Z_ANGLE);
  }
  const Gos::CartesianAngle *y_angle() const {
    return GetPointer<const Gos::CartesianAngle *>(VT_Y_ANGLE);
  }
  const Gos::CartesianAngle *x_angle() const {
    return GetPointer<const Gos::CartesianAngle *>(VT_X_ANGLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_Z_ANGLE) &&
           verifier.VerifyTable(z_angle()) &&
           VerifyOffset(verifier, VT_Y_ANGLE) &&
           verifier.VerifyTable(y_angle()) &&
           VerifyOffset(verifier, VT_X_ANGLE) &&
           verifier.VerifyTable(x_angle()) &&
           verifier.EndTable();
  }
};

struct EulerAnglesWithConfidenceBuilder {
  typedef EulerAnglesWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_z_angle(::flatbuffers::Offset<Gos::CartesianAngle> z_angle) {
    fbb_.AddOffset(EulerAnglesWithConfidence::VT_Z_ANGLE, z_angle);
  }
  void add_y_angle(::flatbuffers::Offset<Gos::CartesianAngle> y_angle) {
    fbb_.AddOffset(EulerAnglesWithConfidence::VT_Y_ANGLE, y_angle);
  }
  void add_x_angle(::flatbuffers::Offset<Gos::CartesianAngle> x_angle) {
    fbb_.AddOffset(EulerAnglesWithConfidence::VT_X_ANGLE, x_angle);
  }
  explicit EulerAnglesWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EulerAnglesWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EulerAnglesWithConfidence>(end);
    fbb_.Required(o, EulerAnglesWithConfidence::VT_Z_ANGLE);
    return o;
  }
};

inline ::flatbuffers::Offset<EulerAnglesWithConfidence> CreateEulerAnglesWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::CartesianAngle> z_angle = 0,
    ::flatbuffers::Offset<Gos::CartesianAngle> y_angle = 0,
    ::flatbuffers::Offset<Gos::CartesianAngle> x_angle = 0) {
  EulerAnglesWithConfidenceBuilder builder_(_fbb);
  builder_.add_x_angle(x_angle);
  builder_.add_y_angle(y_angle);
  builder_.add_z_angle(z_angle);
  return builder_.Finish();
}

struct EventHistory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventHistoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_POINTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::EventPoint>> *event_points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::EventPoint>> *>(VT_EVENT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENT_POINTS) &&
           verifier.VerifyVector(event_points()) &&
           verifier.VerifyVectorOfTables(event_points()) &&
           verifier.EndTable();
  }
};

struct EventHistoryBuilder {
  typedef EventHistory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::EventPoint>>> event_points) {
    fbb_.AddOffset(EventHistory::VT_EVENT_POINTS, event_points);
  }
  explicit EventHistoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventHistory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventHistory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventHistory> CreateEventHistory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::EventPoint>>> event_points = 0) {
  EventHistoryBuilder builder_(_fbb);
  builder_.add_event_points(event_points);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EventHistory> CreateEventHistoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Gos::EventPoint>> *event_points = nullptr) {
  auto event_points__ = event_points ? _fbb.CreateVector<::flatbuffers::Offset<Gos::EventPoint>>(*event_points) : 0;
  return Gos::CreateEventHistory(
      _fbb,
      event_points__);
}

struct EventPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_POSITION = 4,
    VT_EVENT_DELTA_TIME = 6,
    VT_INFORMATION_QUALITY = 8
  };
  const Gos::DeltaReferencePosition *event_position() const {
    return GetPointer<const Gos::DeltaReferencePosition *>(VT_EVENT_POSITION);
  }
  uint32_t event_delta_time() const {
    return GetField<uint32_t>(VT_EVENT_DELTA_TIME, 0);
  }
  uint32_t information_quality() const {
    return GetField<uint32_t>(VT_INFORMATION_QUALITY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EVENT_POSITION) &&
           verifier.VerifyTable(event_position()) &&
           VerifyField<uint32_t>(verifier, VT_EVENT_DELTA_TIME, 4) &&
           VerifyField<uint32_t>(verifier, VT_INFORMATION_QUALITY, 4) &&
           verifier.EndTable();
  }
};

struct EventPointBuilder {
  typedef EventPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_position(::flatbuffers::Offset<Gos::DeltaReferencePosition> event_position) {
    fbb_.AddOffset(EventPoint::VT_EVENT_POSITION, event_position);
  }
  void add_event_delta_time(uint32_t event_delta_time) {
    fbb_.AddElement<uint32_t>(EventPoint::VT_EVENT_DELTA_TIME, event_delta_time, 0);
  }
  void add_information_quality(uint32_t information_quality) {
    fbb_.AddElement<uint32_t>(EventPoint::VT_INFORMATION_QUALITY, information_quality, 0);
  }
  explicit EventPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventPoint>(end);
    fbb_.Required(o, EventPoint::VT_EVENT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<EventPoint> CreateEventPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::DeltaReferencePosition> event_position = 0,
    uint32_t event_delta_time = 0,
    uint32_t information_quality = 0) {
  EventPointBuilder builder_(_fbb);
  builder_.add_information_quality(information_quality);
  builder_.add_event_delta_time(event_delta_time);
  builder_.add_event_position(event_position);
  return builder_.Finish();
}

struct Heading FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeadingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct HeadingBuilder {
  typedef Heading Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Heading::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(Heading::VT_CONFIDENCE, confidence, 0);
  }
  explicit HeadingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Heading> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Heading>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Heading> CreateHeading(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  HeadingBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct IntersectionReferenceID FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntersectionReferenceIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGION = 4,
    VT_ID = 6
  };
  int64_t region() const {
    return GetField<int64_t>(VT_REGION, 0);
  }
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_REGION, 8) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           verifier.EndTable();
  }
};

struct IntersectionReferenceIDBuilder {
  typedef IntersectionReferenceID Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_region(int64_t region) {
    fbb_.AddElement<int64_t>(IntersectionReferenceID::VT_REGION, region, 0);
  }
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(IntersectionReferenceID::VT_ID, id, 0);
  }
  explicit IntersectionReferenceIDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntersectionReferenceID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntersectionReferenceID>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntersectionReferenceID> CreateIntersectionReferenceID(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t region = 0,
    int64_t id = 0) {
  IntersectionReferenceIDBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_region(region);
  return builder_.Finish();
}

struct ItineraryPath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItineraryPathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::ReferencePosition>> *path() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::ReferencePosition>> *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfTables(path()) &&
           verifier.EndTable();
  }
};

struct ItineraryPathBuilder {
  typedef ItineraryPath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::ReferencePosition>>> path) {
    fbb_.AddOffset(ItineraryPath::VT_PATH, path);
  }
  explicit ItineraryPathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ItineraryPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ItineraryPath>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ItineraryPath> CreateItineraryPath(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::ReferencePosition>>> path = 0) {
  ItineraryPathBuilder builder_(_fbb);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ItineraryPath> CreateItineraryPathDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Gos::ReferencePosition>> *path = nullptr) {
  auto path__ = path ? _fbb.CreateVector<::flatbuffers::Offset<Gos::ReferencePosition>>(*path) : 0;
  return Gos::CreateItineraryPath(
      _fbb,
      path__);
}

struct LongitudinalAcceleration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LongitudinalAccelerationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  int32_t confidence() const {
    return GetField<int32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct LongitudinalAccelerationBuilder {
  typedef LongitudinalAcceleration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(LongitudinalAcceleration::VT_VALUE, value, 0);
  }
  void add_confidence(int32_t confidence) {
    fbb_.AddElement<int32_t>(LongitudinalAcceleration::VT_CONFIDENCE, confidence, 0);
  }
  explicit LongitudinalAccelerationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LongitudinalAcceleration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LongitudinalAcceleration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LongitudinalAcceleration> CreateLongitudinalAcceleration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    int32_t confidence = 0) {
  LongitudinalAccelerationBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct LongitudinalLanePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LongitudinalLanePositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDINAL_LANE_POSITION_VALUE = 4,
    VT_LONGITUDINAL_LANE_POSITION_CONFIDENCE = 6
  };
  uint32_t longitudinal_lane_position_value() const {
    return GetField<uint32_t>(VT_LONGITUDINAL_LANE_POSITION_VALUE, 0);
  }
  uint32_t longitudinal_lane_position_confidence() const {
    return GetField<uint32_t>(VT_LONGITUDINAL_LANE_POSITION_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LONGITUDINAL_LANE_POSITION_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_LONGITUDINAL_LANE_POSITION_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct LongitudinalLanePositionBuilder {
  typedef LongitudinalLanePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_longitudinal_lane_position_value(uint32_t longitudinal_lane_position_value) {
    fbb_.AddElement<uint32_t>(LongitudinalLanePosition::VT_LONGITUDINAL_LANE_POSITION_VALUE, longitudinal_lane_position_value, 0);
  }
  void add_longitudinal_lane_position_confidence(uint32_t longitudinal_lane_position_confidence) {
    fbb_.AddElement<uint32_t>(LongitudinalLanePosition::VT_LONGITUDINAL_LANE_POSITION_CONFIDENCE, longitudinal_lane_position_confidence, 0);
  }
  explicit LongitudinalLanePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LongitudinalLanePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LongitudinalLanePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LongitudinalLanePosition> CreateLongitudinalLanePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t longitudinal_lane_position_value = 0,
    uint32_t longitudinal_lane_position_confidence = 0) {
  LongitudinalLanePositionBuilder builder_(_fbb);
  builder_.add_longitudinal_lane_position_confidence(longitudinal_lane_position_confidence);
  builder_.add_longitudinal_lane_position_value(longitudinal_lane_position_value);
  return builder_.Finish();
}

struct LowerTriangularPositiveSemidefiniteMatrix FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LowerTriangularPositiveSemidefiniteMatrixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPONENTS_INCLUDED_IN_THE_MATRIX = 4,
    VT_MATRIX = 6
  };
  const Gos::MatrixIncludedComponents *components_included_in_the_matrix() const {
    return GetPointer<const Gos::MatrixIncludedComponents *>(VT_COMPONENTS_INCLUDED_IN_THE_MATRIX);
  }
  const Gos::LowerTriangularPositiveSemidefiniteMatrixColumns *matrix() const {
    return GetPointer<const Gos::LowerTriangularPositiveSemidefiniteMatrixColumns *>(VT_MATRIX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COMPONENTS_INCLUDED_IN_THE_MATRIX) &&
           verifier.VerifyTable(components_included_in_the_matrix()) &&
           VerifyOffsetRequired(verifier, VT_MATRIX) &&
           verifier.VerifyTable(matrix()) &&
           verifier.EndTable();
  }
};

struct LowerTriangularPositiveSemidefiniteMatrixBuilder {
  typedef LowerTriangularPositiveSemidefiniteMatrix Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_components_included_in_the_matrix(::flatbuffers::Offset<Gos::MatrixIncludedComponents> components_included_in_the_matrix) {
    fbb_.AddOffset(LowerTriangularPositiveSemidefiniteMatrix::VT_COMPONENTS_INCLUDED_IN_THE_MATRIX, components_included_in_the_matrix);
  }
  void add_matrix(::flatbuffers::Offset<Gos::LowerTriangularPositiveSemidefiniteMatrixColumns> matrix) {
    fbb_.AddOffset(LowerTriangularPositiveSemidefiniteMatrix::VT_MATRIX, matrix);
  }
  explicit LowerTriangularPositiveSemidefiniteMatrixBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix>(end);
    fbb_.Required(o, LowerTriangularPositiveSemidefiniteMatrix::VT_COMPONENTS_INCLUDED_IN_THE_MATRIX);
    fbb_.Required(o, LowerTriangularPositiveSemidefiniteMatrix::VT_MATRIX);
    return o;
  }
};

inline ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix> CreateLowerTriangularPositiveSemidefiniteMatrix(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::MatrixIncludedComponents> components_included_in_the_matrix = 0,
    ::flatbuffers::Offset<Gos::LowerTriangularPositiveSemidefiniteMatrixColumns> matrix = 0) {
  LowerTriangularPositiveSemidefiniteMatrixBuilder builder_(_fbb);
  builder_.add_matrix(matrix);
  builder_.add_components_included_in_the_matrix(components_included_in_the_matrix);
  return builder_.Finish();
}

struct LowerTriangularPositiveSemidefiniteMatrixColumns FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::CorrelationColumn>> *columns() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::CorrelationColumn>> *>(VT_COLUMNS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
};

struct LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder {
  typedef LowerTriangularPositiveSemidefiniteMatrixColumns Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_columns(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::CorrelationColumn>>> columns) {
    fbb_.AddOffset(LowerTriangularPositiveSemidefiniteMatrixColumns::VT_COLUMNS, columns);
  }
  explicit LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns> CreateLowerTriangularPositiveSemidefiniteMatrixColumns(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::CorrelationColumn>>> columns = 0) {
  LowerTriangularPositiveSemidefiniteMatrixColumnsBuilder builder_(_fbb);
  builder_.add_columns(columns);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrixColumns> CreateLowerTriangularPositiveSemidefiniteMatrixColumnsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Gos::CorrelationColumn>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<::flatbuffers::Offset<Gos::CorrelationColumn>>(*columns) : 0;
  return Gos::CreateLowerTriangularPositiveSemidefiniteMatrixColumns(
      _fbb,
      columns__);
}

struct MapPosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapPositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAP_REFERENCE = 4,
    VT_LANE_ID = 6,
    VT_CONNECTION_ID = 8,
    VT_LONGITUDINAL_LANE_POSITION = 10
  };
  const Gos::MapReference *map_reference() const {
    return GetPointer<const Gos::MapReference *>(VT_MAP_REFERENCE);
  }
  uint32_t lane_id() const {
    return GetField<uint32_t>(VT_LANE_ID, 0);
  }
  uint32_t connection_id() const {
    return GetField<uint32_t>(VT_CONNECTION_ID, 0);
  }
  const Gos::LongitudinalLanePosition *longitudinal_lane_position() const {
    return GetPointer<const Gos::LongitudinalLanePosition *>(VT_LONGITUDINAL_LANE_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAP_REFERENCE) &&
           verifier.VerifyTable(map_reference()) &&
           VerifyField<uint32_t>(verifier, VT_LANE_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONNECTION_ID, 4) &&
           VerifyOffset(verifier, VT_LONGITUDINAL_LANE_POSITION) &&
           verifier.VerifyTable(longitudinal_lane_position()) &&
           verifier.EndTable();
  }
};

struct MapPositionBuilder {
  typedef MapPosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_map_reference(::flatbuffers::Offset<Gos::MapReference> map_reference) {
    fbb_.AddOffset(MapPosition::VT_MAP_REFERENCE, map_reference);
  }
  void add_lane_id(uint32_t lane_id) {
    fbb_.AddElement<uint32_t>(MapPosition::VT_LANE_ID, lane_id, 0);
  }
  void add_connection_id(uint32_t connection_id) {
    fbb_.AddElement<uint32_t>(MapPosition::VT_CONNECTION_ID, connection_id, 0);
  }
  void add_longitudinal_lane_position(::flatbuffers::Offset<Gos::LongitudinalLanePosition> longitudinal_lane_position) {
    fbb_.AddOffset(MapPosition::VT_LONGITUDINAL_LANE_POSITION, longitudinal_lane_position);
  }
  explicit MapPositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MapPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MapPosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MapPosition> CreateMapPosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::MapReference> map_reference = 0,
    uint32_t lane_id = 0,
    uint32_t connection_id = 0,
    ::flatbuffers::Offset<Gos::LongitudinalLanePosition> longitudinal_lane_position = 0) {
  MapPositionBuilder builder_(_fbb);
  builder_.add_longitudinal_lane_position(longitudinal_lane_position);
  builder_.add_connection_id(connection_id);
  builder_.add_lane_id(lane_id);
  builder_.add_map_reference(map_reference);
  return builder_.Finish();
}

struct MapReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROAD_SEGMENT = 4,
    VT_INTERSECTION = 6
  };
  const Gos::RoadSegmentReferenceID *road_segment() const {
    return GetPointer<const Gos::RoadSegmentReferenceID *>(VT_ROAD_SEGMENT);
  }
  const Gos::IntersectionReferenceID *intersection() const {
    return GetPointer<const Gos::IntersectionReferenceID *>(VT_INTERSECTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROAD_SEGMENT) &&
           verifier.VerifyTable(road_segment()) &&
           VerifyOffset(verifier, VT_INTERSECTION) &&
           verifier.VerifyTable(intersection()) &&
           verifier.EndTable();
  }
};

struct MapReferenceBuilder {
  typedef MapReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_road_segment(::flatbuffers::Offset<Gos::RoadSegmentReferenceID> road_segment) {
    fbb_.AddOffset(MapReference::VT_ROAD_SEGMENT, road_segment);
  }
  void add_intersection(::flatbuffers::Offset<Gos::IntersectionReferenceID> intersection) {
    fbb_.AddOffset(MapReference::VT_INTERSECTION, intersection);
  }
  explicit MapReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MapReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MapReference>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MapReference> CreateMapReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::RoadSegmentReferenceID> road_segment = 0,
    ::flatbuffers::Offset<Gos::IntersectionReferenceID> intersection = 0) {
  MapReferenceBuilder builder_(_fbb);
  builder_.add_intersection(intersection);
  builder_.add_road_segment(road_segment);
  return builder_.Finish();
}

struct MatrixIncludedComponents FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatrixIncludedComponentsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_POSITION = 4,
    VT_Y_POSITION = 6,
    VT_Z_POSITION = 8,
    VT_X_VELOCITY_OR_VELOCITY_MAGNITUDE = 10,
    VT_Y_VELOCITY_OR_VELOCITY_DIRECTION = 12,
    VT_Z_SPEED = 14,
    VT_X_ACCEL_OR_ACCEL_MAGNITUDE = 16,
    VT_Y_ACCEL_OR_ACCEL_DIRECTION = 18,
    VT_Z_ACCELERATION = 20,
    VT_Z_ANGLE = 22,
    VT_Y_ANGLE = 24,
    VT_X_ANGLE = 26,
    VT_Z_ANGULAR_VELOCITY = 28
  };
  bool x_position() const {
    return GetField<uint8_t>(VT_X_POSITION, 0) != 0;
  }
  bool y_position() const {
    return GetField<uint8_t>(VT_Y_POSITION, 0) != 0;
  }
  bool z_position() const {
    return GetField<uint8_t>(VT_Z_POSITION, 0) != 0;
  }
  bool x_velocity_or_velocity_magnitude() const {
    return GetField<uint8_t>(VT_X_VELOCITY_OR_VELOCITY_MAGNITUDE, 0) != 0;
  }
  bool y_velocity_or_velocity_direction() const {
    return GetField<uint8_t>(VT_Y_VELOCITY_OR_VELOCITY_DIRECTION, 0) != 0;
  }
  bool z_speed() const {
    return GetField<uint8_t>(VT_Z_SPEED, 0) != 0;
  }
  bool x_accel_or_accel_magnitude() const {
    return GetField<uint8_t>(VT_X_ACCEL_OR_ACCEL_MAGNITUDE, 0) != 0;
  }
  bool y_accel_or_accel_direction() const {
    return GetField<uint8_t>(VT_Y_ACCEL_OR_ACCEL_DIRECTION, 0) != 0;
  }
  bool z_acceleration() const {
    return GetField<uint8_t>(VT_Z_ACCELERATION, 0) != 0;
  }
  bool z_angle() const {
    return GetField<uint8_t>(VT_Z_ANGLE, 0) != 0;
  }
  bool y_angle() const {
    return GetField<uint8_t>(VT_Y_ANGLE, 0) != 0;
  }
  bool x_angle() const {
    return GetField<uint8_t>(VT_X_ANGLE, 0) != 0;
  }
  bool z_angular_velocity() const {
    return GetField<uint8_t>(VT_Z_ANGULAR_VELOCITY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_X_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_Y_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_Z_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_X_VELOCITY_OR_VELOCITY_MAGNITUDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_Y_VELOCITY_OR_VELOCITY_DIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_Z_SPEED, 1) &&
           VerifyField<uint8_t>(verifier, VT_X_ACCEL_OR_ACCEL_MAGNITUDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_Y_ACCEL_OR_ACCEL_DIRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_Z_ACCELERATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_Z_ANGLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_Y_ANGLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_X_ANGLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_Z_ANGULAR_VELOCITY, 1) &&
           verifier.EndTable();
  }
};

struct MatrixIncludedComponentsBuilder {
  typedef MatrixIncludedComponents Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_position(bool x_position) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_X_POSITION, static_cast<uint8_t>(x_position), 0);
  }
  void add_y_position(bool y_position) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Y_POSITION, static_cast<uint8_t>(y_position), 0);
  }
  void add_z_position(bool z_position) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Z_POSITION, static_cast<uint8_t>(z_position), 0);
  }
  void add_x_velocity_or_velocity_magnitude(bool x_velocity_or_velocity_magnitude) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_X_VELOCITY_OR_VELOCITY_MAGNITUDE, static_cast<uint8_t>(x_velocity_or_velocity_magnitude), 0);
  }
  void add_y_velocity_or_velocity_direction(bool y_velocity_or_velocity_direction) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Y_VELOCITY_OR_VELOCITY_DIRECTION, static_cast<uint8_t>(y_velocity_or_velocity_direction), 0);
  }
  void add_z_speed(bool z_speed) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Z_SPEED, static_cast<uint8_t>(z_speed), 0);
  }
  void add_x_accel_or_accel_magnitude(bool x_accel_or_accel_magnitude) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_X_ACCEL_OR_ACCEL_MAGNITUDE, static_cast<uint8_t>(x_accel_or_accel_magnitude), 0);
  }
  void add_y_accel_or_accel_direction(bool y_accel_or_accel_direction) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Y_ACCEL_OR_ACCEL_DIRECTION, static_cast<uint8_t>(y_accel_or_accel_direction), 0);
  }
  void add_z_acceleration(bool z_acceleration) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Z_ACCELERATION, static_cast<uint8_t>(z_acceleration), 0);
  }
  void add_z_angle(bool z_angle) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Z_ANGLE, static_cast<uint8_t>(z_angle), 0);
  }
  void add_y_angle(bool y_angle) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Y_ANGLE, static_cast<uint8_t>(y_angle), 0);
  }
  void add_x_angle(bool x_angle) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_X_ANGLE, static_cast<uint8_t>(x_angle), 0);
  }
  void add_z_angular_velocity(bool z_angular_velocity) {
    fbb_.AddElement<uint8_t>(MatrixIncludedComponents::VT_Z_ANGULAR_VELOCITY, static_cast<uint8_t>(z_angular_velocity), 0);
  }
  explicit MatrixIncludedComponentsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MatrixIncludedComponents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MatrixIncludedComponents>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MatrixIncludedComponents> CreateMatrixIncludedComponents(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool x_position = false,
    bool y_position = false,
    bool z_position = false,
    bool x_velocity_or_velocity_magnitude = false,
    bool y_velocity_or_velocity_direction = false,
    bool z_speed = false,
    bool x_accel_or_accel_magnitude = false,
    bool y_accel_or_accel_direction = false,
    bool z_acceleration = false,
    bool z_angle = false,
    bool y_angle = false,
    bool x_angle = false,
    bool z_angular_velocity = false) {
  MatrixIncludedComponentsBuilder builder_(_fbb);
  builder_.add_z_angular_velocity(z_angular_velocity);
  builder_.add_x_angle(x_angle);
  builder_.add_y_angle(y_angle);
  builder_.add_z_angle(z_angle);
  builder_.add_z_acceleration(z_acceleration);
  builder_.add_y_accel_or_accel_direction(y_accel_or_accel_direction);
  builder_.add_x_accel_or_accel_magnitude(x_accel_or_accel_magnitude);
  builder_.add_z_speed(z_speed);
  builder_.add_y_velocity_or_velocity_direction(y_velocity_or_velocity_direction);
  builder_.add_x_velocity_or_velocity_magnitude(x_velocity_or_velocity_magnitude);
  builder_.add_z_position(z_position);
  builder_.add_y_position(y_position);
  builder_.add_x_position(x_position);
  return builder_.Finish();
}

struct MessageRateHz FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageRateHzBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MANTISSA = 4,
    VT_EXPONENT = 6
  };
  uint32_t mantissa() const {
    return GetField<uint32_t>(VT_MANTISSA, 0);
  }
  int32_t exponent() const {
    return GetField<int32_t>(VT_EXPONENT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MANTISSA, 4) &&
           VerifyField<int32_t>(verifier, VT_EXPONENT, 4) &&
           verifier.EndTable();
  }
};

struct MessageRateHzBuilder {
  typedef MessageRateHz Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mantissa(uint32_t mantissa) {
    fbb_.AddElement<uint32_t>(MessageRateHz::VT_MANTISSA, mantissa, 0);
  }
  void add_exponent(int32_t exponent) {
    fbb_.AddElement<int32_t>(MessageRateHz::VT_EXPONENT, exponent, 0);
  }
  explicit MessageRateHzBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageRateHz> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageRateHz>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageRateHz> CreateMessageRateHz(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mantissa = 0,
    int32_t exponent = 0) {
  MessageRateHzBuilder builder_(_fbb);
  builder_.add_exponent(exponent);
  builder_.add_mantissa(mantissa);
  return builder_.Finish();
}

struct MessageSegmentationInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageSegmentationInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTAL_MSG_NO = 4,
    VT_THIS_MSG_NO = 6
  };
  uint32_t total_msg_no() const {
    return GetField<uint32_t>(VT_TOTAL_MSG_NO, 0);
  }
  uint32_t this_msg_no() const {
    return GetField<uint32_t>(VT_THIS_MSG_NO, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_MSG_NO, 4) &&
           VerifyField<uint32_t>(verifier, VT_THIS_MSG_NO, 4) &&
           verifier.EndTable();
  }
};

struct MessageSegmentationInfoBuilder {
  typedef MessageSegmentationInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_total_msg_no(uint32_t total_msg_no) {
    fbb_.AddElement<uint32_t>(MessageSegmentationInfo::VT_TOTAL_MSG_NO, total_msg_no, 0);
  }
  void add_this_msg_no(uint32_t this_msg_no) {
    fbb_.AddElement<uint32_t>(MessageSegmentationInfo::VT_THIS_MSG_NO, this_msg_no, 0);
  }
  explicit MessageSegmentationInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageSegmentationInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageSegmentationInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageSegmentationInfo> CreateMessageSegmentationInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t total_msg_no = 0,
    uint32_t this_msg_no = 0) {
  MessageSegmentationInfoBuilder builder_(_fbb);
  builder_.add_this_msg_no(this_msg_no);
  builder_.add_total_msg_no(total_msg_no);
  return builder_.Finish();
}

struct ObjectClass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectClassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEHICLE_SUB_CLASS = 4
  };
  Gos::TrafficParticipantType vehicle_sub_class() const {
    return static_cast<Gos::TrafficParticipantType>(GetField<int32_t>(VT_VEHICLE_SUB_CLASS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VEHICLE_SUB_CLASS, 4) &&
           verifier.EndTable();
  }
};

struct ObjectClassBuilder {
  typedef ObjectClass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vehicle_sub_class(Gos::TrafficParticipantType vehicle_sub_class) {
    fbb_.AddElement<int32_t>(ObjectClass::VT_VEHICLE_SUB_CLASS, static_cast<int32_t>(vehicle_sub_class), 0);
  }
  explicit ObjectClassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectClass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectClass> CreateObjectClass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::TrafficParticipantType vehicle_sub_class = Gos::TrafficParticipantType_TP_TYPE_UNKNOWN) {
  ObjectClassBuilder builder_(_fbb);
  builder_.add_vehicle_sub_class(vehicle_sub_class);
  return builder_.Finish();
}

struct ObjectClassWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectClassWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_CLASS = 4,
    VT_CONFIDENCE = 6
  };
  const Gos::ObjectClass *object_class() const {
    return GetPointer<const Gos::ObjectClass *>(VT_OBJECT_CLASS);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OBJECT_CLASS) &&
           verifier.VerifyTable(object_class()) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct ObjectClassWithConfidenceBuilder {
  typedef ObjectClassWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_object_class(::flatbuffers::Offset<Gos::ObjectClass> object_class) {
    fbb_.AddOffset(ObjectClassWithConfidence::VT_OBJECT_CLASS, object_class);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(ObjectClassWithConfidence::VT_CONFIDENCE, confidence, 0);
  }
  explicit ObjectClassWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectClassWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectClassWithConfidence>(end);
    fbb_.Required(o, ObjectClassWithConfidence::VT_OBJECT_CLASS);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectClassWithConfidence> CreateObjectClassWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::ObjectClass> object_class = 0,
    uint32_t confidence = 0) {
  ObjectClassWithConfidenceBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_object_class(object_class);
  return builder_.Finish();
}

struct ObjectDimension FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectDimensionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct ObjectDimensionBuilder {
  typedef ObjectDimension Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(ObjectDimension::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(ObjectDimension::VT_CONFIDENCE, confidence, 0);
  }
  explicit ObjectDimensionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectDimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectDimension>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectDimension> CreateObjectDimension(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0,
    uint32_t confidence = 0) {
  ObjectDimensionBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct OtherSubClass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OtherSubClassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNKNOWN = 4,
    VT_SINGLE_OBJECT = 6,
    VT_MULTIPLE_OBJECTS = 8,
    VT_BULK_MATERIAL = 10
  };
  bool unknown() const {
    return GetField<uint8_t>(VT_UNKNOWN, 0) != 0;
  }
  bool single_object() const {
    return GetField<uint8_t>(VT_SINGLE_OBJECT, 0) != 0;
  }
  bool multiple_objects() const {
    return GetField<uint8_t>(VT_MULTIPLE_OBJECTS, 0) != 0;
  }
  bool bulk_material() const {
    return GetField<uint8_t>(VT_BULK_MATERIAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UNKNOWN, 1) &&
           VerifyField<uint8_t>(verifier, VT_SINGLE_OBJECT, 1) &&
           VerifyField<uint8_t>(verifier, VT_MULTIPLE_OBJECTS, 1) &&
           VerifyField<uint8_t>(verifier, VT_BULK_MATERIAL, 1) &&
           verifier.EndTable();
  }
};

struct OtherSubClassBuilder {
  typedef OtherSubClass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unknown(bool unknown) {
    fbb_.AddElement<uint8_t>(OtherSubClass::VT_UNKNOWN, static_cast<uint8_t>(unknown), 0);
  }
  void add_single_object(bool single_object) {
    fbb_.AddElement<uint8_t>(OtherSubClass::VT_SINGLE_OBJECT, static_cast<uint8_t>(single_object), 0);
  }
  void add_multiple_objects(bool multiple_objects) {
    fbb_.AddElement<uint8_t>(OtherSubClass::VT_MULTIPLE_OBJECTS, static_cast<uint8_t>(multiple_objects), 0);
  }
  void add_bulk_material(bool bulk_material) {
    fbb_.AddElement<uint8_t>(OtherSubClass::VT_BULK_MATERIAL, static_cast<uint8_t>(bulk_material), 0);
  }
  explicit OtherSubClassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OtherSubClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OtherSubClass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OtherSubClass> CreateOtherSubClass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool unknown = false,
    bool single_object = false,
    bool multiple_objects = false,
    bool bulk_material = false) {
  OtherSubClassBuilder builder_(_fbb);
  builder_.add_bulk_material(bulk_material);
  builder_.add_multiple_objects(multiple_objects);
  builder_.add_single_object(single_object);
  builder_.add_unknown(unknown);
  return builder_.Finish();
}

struct PolygonalShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolygonalShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE_REFERENCE_POINT = 4,
    VT_POLYGON = 6,
    VT_HEIGHT = 8
  };
  const Gos::CartesianPosition3d *shape_reference_point() const {
    return GetPointer<const Gos::CartesianPosition3d *>(VT_SHAPE_REFERENCE_POINT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::CartesianPosition3d>> *polygon() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::CartesianPosition3d>> *>(VT_POLYGON);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE_REFERENCE_POINT) &&
           verifier.VerifyTable(shape_reference_point()) &&
           VerifyOffset(verifier, VT_POLYGON) &&
           verifier.VerifyVector(polygon()) &&
           verifier.VerifyVectorOfTables(polygon()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct PolygonalShapeBuilder {
  typedef PolygonalShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape_reference_point(::flatbuffers::Offset<Gos::CartesianPosition3d> shape_reference_point) {
    fbb_.AddOffset(PolygonalShape::VT_SHAPE_REFERENCE_POINT, shape_reference_point);
  }
  void add_polygon(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::CartesianPosition3d>>> polygon) {
    fbb_.AddOffset(PolygonalShape::VT_POLYGON, polygon);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(PolygonalShape::VT_HEIGHT, height, 0);
  }
  explicit PolygonalShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PolygonalShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PolygonalShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PolygonalShape> CreatePolygonalShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::CartesianPosition3d> shape_reference_point = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::CartesianPosition3d>>> polygon = 0,
    uint32_t height = 0) {
  PolygonalShapeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_polygon(polygon);
  builder_.add_shape_reference_point(shape_reference_point);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PolygonalShape> CreatePolygonalShapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::CartesianPosition3d> shape_reference_point = 0,
    const std::vector<::flatbuffers::Offset<Gos::CartesianPosition3d>> *polygon = nullptr,
    uint32_t height = 0) {
  auto polygon__ = polygon ? _fbb.CreateVector<::flatbuffers::Offset<Gos::CartesianPosition3d>>(*polygon) : 0;
  return Gos::CreatePolygonalShape(
      _fbb,
      shape_reference_point,
      polygon__,
      height);
}

struct PositionConfidenceEllipse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PositionConfidenceEllipseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEMI_MAJOR_CONFIDENCE = 4,
    VT_SEMI_MINOR_CONFIDENCE = 6,
    VT_SEMI_MAJOR_ORIENTATION = 8
  };
  uint32_t semi_major_confidence() const {
    return GetField<uint32_t>(VT_SEMI_MAJOR_CONFIDENCE, 0);
  }
  uint32_t semi_minor_confidence() const {
    return GetField<uint32_t>(VT_SEMI_MINOR_CONFIDENCE, 0);
  }
  uint32_t semi_major_orientation() const {
    return GetField<uint32_t>(VT_SEMI_MAJOR_ORIENTATION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_MAJOR_CONFIDENCE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_MINOR_CONFIDENCE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_MAJOR_ORIENTATION, 4) &&
           verifier.EndTable();
  }
};

struct PositionConfidenceEllipseBuilder {
  typedef PositionConfidenceEllipse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_semi_major_confidence(uint32_t semi_major_confidence) {
    fbb_.AddElement<uint32_t>(PositionConfidenceEllipse::VT_SEMI_MAJOR_CONFIDENCE, semi_major_confidence, 0);
  }
  void add_semi_minor_confidence(uint32_t semi_minor_confidence) {
    fbb_.AddElement<uint32_t>(PositionConfidenceEllipse::VT_SEMI_MINOR_CONFIDENCE, semi_minor_confidence, 0);
  }
  void add_semi_major_orientation(uint32_t semi_major_orientation) {
    fbb_.AddElement<uint32_t>(PositionConfidenceEllipse::VT_SEMI_MAJOR_ORIENTATION, semi_major_orientation, 0);
  }
  explicit PositionConfidenceEllipseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PositionConfidenceEllipse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PositionConfidenceEllipse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PositionConfidenceEllipse> CreatePositionConfidenceEllipse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t semi_major_confidence = 0,
    uint32_t semi_minor_confidence = 0,
    uint32_t semi_major_orientation = 0) {
  PositionConfidenceEllipseBuilder builder_(_fbb);
  builder_.add_semi_major_orientation(semi_major_orientation);
  builder_.add_semi_minor_confidence(semi_minor_confidence);
  builder_.add_semi_major_confidence(semi_major_confidence);
  return builder_.Finish();
}

struct RadialShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadialShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHARED_REF_POINT = 4,
    VT_RANGE = 6,
    VT_STATIONARY_HORIZONTAL_OPENING_ANGLE_START = 8,
    VT_STATIONARY_HORIZONTAL_OPENING_ANGLE_END = 10,
    VT_VERTICAL_OPENING_ANGLE_START = 12,
    VT_VERTICAL_OPENING_ANGLE_END = 14
  };
  const Gos::CartesianPosition3d *shared_ref_point() const {
    return GetPointer<const Gos::CartesianPosition3d *>(VT_SHARED_REF_POINT);
  }
  uint32_t range() const {
    return GetField<uint32_t>(VT_RANGE, 0);
  }
  uint32_t stationary_horizontal_opening_angle_start() const {
    return GetField<uint32_t>(VT_STATIONARY_HORIZONTAL_OPENING_ANGLE_START, 0);
  }
  uint32_t stationary_horizontal_opening_angle_end() const {
    return GetField<uint32_t>(VT_STATIONARY_HORIZONTAL_OPENING_ANGLE_END, 0);
  }
  uint32_t vertical_opening_angle_start() const {
    return GetField<uint32_t>(VT_VERTICAL_OPENING_ANGLE_START, 0);
  }
  uint32_t vertical_opening_angle_end() const {
    return GetField<uint32_t>(VT_VERTICAL_OPENING_ANGLE_END, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHARED_REF_POINT) &&
           verifier.VerifyTable(shared_ref_point()) &&
           VerifyField<uint32_t>(verifier, VT_RANGE, 4) &&
           VerifyField<uint32_t>(verifier, VT_STATIONARY_HORIZONTAL_OPENING_ANGLE_START, 4) &&
           VerifyField<uint32_t>(verifier, VT_STATIONARY_HORIZONTAL_OPENING_ANGLE_END, 4) &&
           VerifyField<uint32_t>(verifier, VT_VERTICAL_OPENING_ANGLE_START, 4) &&
           VerifyField<uint32_t>(verifier, VT_VERTICAL_OPENING_ANGLE_END, 4) &&
           verifier.EndTable();
  }
};

struct RadialShapeBuilder {
  typedef RadialShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shared_ref_point(::flatbuffers::Offset<Gos::CartesianPosition3d> shared_ref_point) {
    fbb_.AddOffset(RadialShape::VT_SHARED_REF_POINT, shared_ref_point);
  }
  void add_range(uint32_t range) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_RANGE, range, 0);
  }
  void add_stationary_horizontal_opening_angle_start(uint32_t stationary_horizontal_opening_angle_start) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_STATIONARY_HORIZONTAL_OPENING_ANGLE_START, stationary_horizontal_opening_angle_start, 0);
  }
  void add_stationary_horizontal_opening_angle_end(uint32_t stationary_horizontal_opening_angle_end) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_STATIONARY_HORIZONTAL_OPENING_ANGLE_END, stationary_horizontal_opening_angle_end, 0);
  }
  void add_vertical_opening_angle_start(uint32_t vertical_opening_angle_start) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_VERTICAL_OPENING_ANGLE_START, vertical_opening_angle_start, 0);
  }
  void add_vertical_opening_angle_end(uint32_t vertical_opening_angle_end) {
    fbb_.AddElement<uint32_t>(RadialShape::VT_VERTICAL_OPENING_ANGLE_END, vertical_opening_angle_end, 0);
  }
  explicit RadialShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadialShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadialShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadialShape> CreateRadialShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::CartesianPosition3d> shared_ref_point = 0,
    uint32_t range = 0,
    uint32_t stationary_horizontal_opening_angle_start = 0,
    uint32_t stationary_horizontal_opening_angle_end = 0,
    uint32_t vertical_opening_angle_start = 0,
    uint32_t vertical_opening_angle_end = 0) {
  RadialShapeBuilder builder_(_fbb);
  builder_.add_vertical_opening_angle_end(vertical_opening_angle_end);
  builder_.add_vertical_opening_angle_start(vertical_opening_angle_start);
  builder_.add_stationary_horizontal_opening_angle_end(stationary_horizontal_opening_angle_end);
  builder_.add_stationary_horizontal_opening_angle_start(stationary_horizontal_opening_angle_start);
  builder_.add_range(range);
  builder_.add_shared_ref_point(shared_ref_point);
  return builder_.Finish();
}

struct RadialShapes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadialShapesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REF_POINT_ID = 4,
    VT_X_COORD = 6,
    VT_Y_COORD = 8,
    VT_Z_COORD = 10,
    VT_RADIAL_SHAPES_LIST = 12
  };
  uint32_t ref_point_id() const {
    return GetField<uint32_t>(VT_REF_POINT_ID, 0);
  }
  int32_t x_coord() const {
    return GetField<int32_t>(VT_X_COORD, 0);
  }
  int32_t y_coord() const {
    return GetField<int32_t>(VT_Y_COORD, 0);
  }
  int32_t z_coord() const {
    return GetField<int32_t>(VT_Z_COORD, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::RadialShapeDetails>> *radial_shapes_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::RadialShapeDetails>> *>(VT_RADIAL_SHAPES_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REF_POINT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_X_COORD, 4) &&
           VerifyField<int32_t>(verifier, VT_Y_COORD, 4) &&
           VerifyField<int32_t>(verifier, VT_Z_COORD, 4) &&
           VerifyOffset(verifier, VT_RADIAL_SHAPES_LIST) &&
           verifier.VerifyVector(radial_shapes_list()) &&
           verifier.VerifyVectorOfTables(radial_shapes_list()) &&
           verifier.EndTable();
  }
};

struct RadialShapesBuilder {
  typedef RadialShapes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ref_point_id(uint32_t ref_point_id) {
    fbb_.AddElement<uint32_t>(RadialShapes::VT_REF_POINT_ID, ref_point_id, 0);
  }
  void add_x_coord(int32_t x_coord) {
    fbb_.AddElement<int32_t>(RadialShapes::VT_X_COORD, x_coord, 0);
  }
  void add_y_coord(int32_t y_coord) {
    fbb_.AddElement<int32_t>(RadialShapes::VT_Y_COORD, y_coord, 0);
  }
  void add_z_coord(int32_t z_coord) {
    fbb_.AddElement<int32_t>(RadialShapes::VT_Z_COORD, z_coord, 0);
  }
  void add_radial_shapes_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::RadialShapeDetails>>> radial_shapes_list) {
    fbb_.AddOffset(RadialShapes::VT_RADIAL_SHAPES_LIST, radial_shapes_list);
  }
  explicit RadialShapesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadialShapes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadialShapes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadialShapes> CreateRadialShapes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ref_point_id = 0,
    int32_t x_coord = 0,
    int32_t y_coord = 0,
    int32_t z_coord = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::RadialShapeDetails>>> radial_shapes_list = 0) {
  RadialShapesBuilder builder_(_fbb);
  builder_.add_radial_shapes_list(radial_shapes_list);
  builder_.add_z_coord(z_coord);
  builder_.add_y_coord(y_coord);
  builder_.add_x_coord(x_coord);
  builder_.add_ref_point_id(ref_point_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RadialShapes> CreateRadialShapesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ref_point_id = 0,
    int32_t x_coord = 0,
    int32_t y_coord = 0,
    int32_t z_coord = 0,
    const std::vector<::flatbuffers::Offset<Gos::RadialShapeDetails>> *radial_shapes_list = nullptr) {
  auto radial_shapes_list__ = radial_shapes_list ? _fbb.CreateVector<::flatbuffers::Offset<Gos::RadialShapeDetails>>(*radial_shapes_list) : 0;
  return Gos::CreateRadialShapes(
      _fbb,
      ref_point_id,
      x_coord,
      y_coord,
      z_coord,
      radial_shapes_list__);
}

struct RadialShapeDetails FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadialShapeDetailsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANGE = 4,
    VT_HORIZONTAL_OPENING_ANGLE_START = 6,
    VT_HORIZONTAL_OPENING_ANGLE_END = 8,
    VT_VERTICAL_OPENING_ANGLE_START = 10,
    VT_VERTICAL_OPENING_ANGLE_END = 12
  };
  int32_t range() const {
    return GetField<int32_t>(VT_RANGE, 0);
  }
  uint32_t horizontal_opening_angle_start() const {
    return GetField<uint32_t>(VT_HORIZONTAL_OPENING_ANGLE_START, 0);
  }
  uint32_t horizontal_opening_angle_end() const {
    return GetField<uint32_t>(VT_HORIZONTAL_OPENING_ANGLE_END, 0);
  }
  uint32_t vertical_opening_angle_start() const {
    return GetField<uint32_t>(VT_VERTICAL_OPENING_ANGLE_START, 0);
  }
  uint32_t vertical_opening_angle_end() const {
    return GetField<uint32_t>(VT_VERTICAL_OPENING_ANGLE_END, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANGE, 4) &&
           VerifyField<uint32_t>(verifier, VT_HORIZONTAL_OPENING_ANGLE_START, 4) &&
           VerifyField<uint32_t>(verifier, VT_HORIZONTAL_OPENING_ANGLE_END, 4) &&
           VerifyField<uint32_t>(verifier, VT_VERTICAL_OPENING_ANGLE_START, 4) &&
           VerifyField<uint32_t>(verifier, VT_VERTICAL_OPENING_ANGLE_END, 4) &&
           verifier.EndTable();
  }
};

struct RadialShapeDetailsBuilder {
  typedef RadialShapeDetails Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_range(int32_t range) {
    fbb_.AddElement<int32_t>(RadialShapeDetails::VT_RANGE, range, 0);
  }
  void add_horizontal_opening_angle_start(uint32_t horizontal_opening_angle_start) {
    fbb_.AddElement<uint32_t>(RadialShapeDetails::VT_HORIZONTAL_OPENING_ANGLE_START, horizontal_opening_angle_start, 0);
  }
  void add_horizontal_opening_angle_end(uint32_t horizontal_opening_angle_end) {
    fbb_.AddElement<uint32_t>(RadialShapeDetails::VT_HORIZONTAL_OPENING_ANGLE_END, horizontal_opening_angle_end, 0);
  }
  void add_vertical_opening_angle_start(uint32_t vertical_opening_angle_start) {
    fbb_.AddElement<uint32_t>(RadialShapeDetails::VT_VERTICAL_OPENING_ANGLE_START, vertical_opening_angle_start, 0);
  }
  void add_vertical_opening_angle_end(uint32_t vertical_opening_angle_end) {
    fbb_.AddElement<uint32_t>(RadialShapeDetails::VT_VERTICAL_OPENING_ANGLE_END, vertical_opening_angle_end, 0);
  }
  explicit RadialShapeDetailsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadialShapeDetails> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadialShapeDetails>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadialShapeDetails> CreateRadialShapeDetails(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t range = 0,
    uint32_t horizontal_opening_angle_start = 0,
    uint32_t horizontal_opening_angle_end = 0,
    uint32_t vertical_opening_angle_start = 0,
    uint32_t vertical_opening_angle_end = 0) {
  RadialShapeDetailsBuilder builder_(_fbb);
  builder_.add_vertical_opening_angle_end(vertical_opening_angle_end);
  builder_.add_vertical_opening_angle_start(vertical_opening_angle_start);
  builder_.add_horizontal_opening_angle_end(horizontal_opening_angle_end);
  builder_.add_horizontal_opening_angle_start(horizontal_opening_angle_start);
  builder_.add_range(range);
  return builder_.Finish();
}

struct RectangularShape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RectangularShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER_POINT = 4,
    VT_SEMI_LENGTH = 6,
    VT_SEMI_BREADTH = 8,
    VT_ORIENTATION = 10,
    VT_HEIGHT = 12
  };
  const Gos::CartesianPosition3d *center_point() const {
    return GetPointer<const Gos::CartesianPosition3d *>(VT_CENTER_POINT);
  }
  uint32_t semi_length() const {
    return GetField<uint32_t>(VT_SEMI_LENGTH, 0);
  }
  uint32_t semi_breadth() const {
    return GetField<uint32_t>(VT_SEMI_BREADTH, 0);
  }
  uint32_t orientation() const {
    return GetField<uint32_t>(VT_ORIENTATION, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CENTER_POINT) &&
           verifier.VerifyTable(center_point()) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_LENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_SEMI_BREADTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_ORIENTATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct RectangularShapeBuilder {
  typedef RectangularShape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center_point(::flatbuffers::Offset<Gos::CartesianPosition3d> center_point) {
    fbb_.AddOffset(RectangularShape::VT_CENTER_POINT, center_point);
  }
  void add_semi_length(uint32_t semi_length) {
    fbb_.AddElement<uint32_t>(RectangularShape::VT_SEMI_LENGTH, semi_length, 0);
  }
  void add_semi_breadth(uint32_t semi_breadth) {
    fbb_.AddElement<uint32_t>(RectangularShape::VT_SEMI_BREADTH, semi_breadth, 0);
  }
  void add_orientation(uint32_t orientation) {
    fbb_.AddElement<uint32_t>(RectangularShape::VT_ORIENTATION, orientation, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(RectangularShape::VT_HEIGHT, height, 0);
  }
  explicit RectangularShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RectangularShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RectangularShape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RectangularShape> CreateRectangularShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::CartesianPosition3d> center_point = 0,
    uint32_t semi_length = 0,
    uint32_t semi_breadth = 0,
    uint32_t orientation = 0,
    uint32_t height = 0) {
  RectangularShapeBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_orientation(orientation);
  builder_.add_semi_breadth(semi_breadth);
  builder_.add_semi_length(semi_length);
  builder_.add_center_point(center_point);
  return builder_.Finish();
}

struct ReferenceDenms FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReferenceDenmsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION_IDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::ActionID>> *action_ids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Gos::ActionID>> *>(VT_ACTION_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION_IDS) &&
           verifier.VerifyVector(action_ids()) &&
           verifier.VerifyVectorOfTables(action_ids()) &&
           verifier.EndTable();
  }
};

struct ReferenceDenmsBuilder {
  typedef ReferenceDenms Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_action_ids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::ActionID>>> action_ids) {
    fbb_.AddOffset(ReferenceDenms::VT_ACTION_IDS, action_ids);
  }
  explicit ReferenceDenmsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReferenceDenms> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReferenceDenms>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReferenceDenms> CreateReferenceDenms(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Gos::ActionID>>> action_ids = 0) {
  ReferenceDenmsBuilder builder_(_fbb);
  builder_.add_action_ids(action_ids);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReferenceDenms> CreateReferenceDenmsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Gos::ActionID>> *action_ids = nullptr) {
  auto action_ids__ = action_ids ? _fbb.CreateVector<::flatbuffers::Offset<Gos::ActionID>>(*action_ids) : 0;
  return Gos::CreateReferenceDenms(
      _fbb,
      action_ids__);
}

struct ReferencePosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReferencePositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATITUDE = 4,
    VT_LONGITUDE = 6,
    VT_POSITION_CONFIDENCE = 8,
    VT_ALTITUDE = 10
  };
  int64_t latitude() const {
    return GetField<int64_t>(VT_LATITUDE, 0);
  }
  int64_t longitude() const {
    return GetField<int64_t>(VT_LONGITUDE, 0);
  }
  const Gos::PositionConfidenceEllipse *position_confidence() const {
    return GetPointer<const Gos::PositionConfidenceEllipse *>(VT_POSITION_CONFIDENCE);
  }
  const Gos::Altitude *altitude() const {
    return GetPointer<const Gos::Altitude *>(VT_ALTITUDE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LATITUDE, 8) &&
           VerifyField<int64_t>(verifier, VT_LONGITUDE, 8) &&
           VerifyOffset(verifier, VT_POSITION_CONFIDENCE) &&
           verifier.VerifyTable(position_confidence()) &&
           VerifyOffset(verifier, VT_ALTITUDE) &&
           verifier.VerifyTable(altitude()) &&
           verifier.EndTable();
  }
};

struct ReferencePositionBuilder {
  typedef ReferencePosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_latitude(int64_t latitude) {
    fbb_.AddElement<int64_t>(ReferencePosition::VT_LATITUDE, latitude, 0);
  }
  void add_longitude(int64_t longitude) {
    fbb_.AddElement<int64_t>(ReferencePosition::VT_LONGITUDE, longitude, 0);
  }
  void add_position_confidence(::flatbuffers::Offset<Gos::PositionConfidenceEllipse> position_confidence) {
    fbb_.AddOffset(ReferencePosition::VT_POSITION_CONFIDENCE, position_confidence);
  }
  void add_altitude(::flatbuffers::Offset<Gos::Altitude> altitude) {
    fbb_.AddOffset(ReferencePosition::VT_ALTITUDE, altitude);
  }
  explicit ReferencePositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReferencePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReferencePosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReferencePosition> CreateReferencePosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t latitude = 0,
    int64_t longitude = 0,
    ::flatbuffers::Offset<Gos::PositionConfidenceEllipse> position_confidence = 0,
    ::flatbuffers::Offset<Gos::Altitude> altitude = 0) {
  ReferencePositionBuilder builder_(_fbb);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_altitude(altitude);
  builder_.add_position_confidence(position_confidence);
  return builder_.Finish();
}

struct RestrictedTypes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RestrictedTypesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESTRICTED_VEHICLES = 4
  };
  const ::flatbuffers::Vector<int32_t> *restricted_vehicles() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_RESTRICTED_VEHICLES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESTRICTED_VEHICLES) &&
           verifier.VerifyVector(restricted_vehicles()) &&
           verifier.EndTable();
  }
};

struct RestrictedTypesBuilder {
  typedef RestrictedTypes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_restricted_vehicles(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> restricted_vehicles) {
    fbb_.AddOffset(RestrictedTypes::VT_RESTRICTED_VEHICLES, restricted_vehicles);
  }
  explicit RestrictedTypesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RestrictedTypes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RestrictedTypes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RestrictedTypes> CreateRestrictedTypes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> restricted_vehicles = 0) {
  RestrictedTypesBuilder builder_(_fbb);
  builder_.add_restricted_vehicles(restricted_vehicles);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RestrictedTypes> CreateRestrictedTypesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *restricted_vehicles = nullptr) {
  auto restricted_vehicles__ = restricted_vehicles ? _fbb.CreateVector<int32_t>(*restricted_vehicles) : 0;
  return Gos::CreateRestrictedTypes(
      _fbb,
      restricted_vehicles__);
}

struct RoadSegmentReferenceID FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoadSegmentReferenceIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGION = 4,
    VT_ID = 6
  };
  int64_t region() const {
    return GetField<int64_t>(VT_REGION, 0);
  }
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_REGION, 8) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           verifier.EndTable();
  }
};

struct RoadSegmentReferenceIDBuilder {
  typedef RoadSegmentReferenceID Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_region(int64_t region) {
    fbb_.AddElement<int64_t>(RoadSegmentReferenceID::VT_REGION, region, 0);
  }
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(RoadSegmentReferenceID::VT_ID, id, 0);
  }
  explicit RoadSegmentReferenceIDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoadSegmentReferenceID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoadSegmentReferenceID>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoadSegmentReferenceID> CreateRoadSegmentReferenceID(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t region = 0,
    int64_t id = 0) {
  RoadSegmentReferenceIDBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_region(region);
  return builder_.Finish();
}

struct Shape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECTANGULAR = 4,
    VT_CIRCULAR = 6,
    VT_POLYGONAL = 8,
    VT_ELLIPTICAL = 10,
    VT_RADIAL = 12,
    VT_RADIAL_SHAPES = 14
  };
  const Gos::RectangularShape *rectangular() const {
    return GetPointer<const Gos::RectangularShape *>(VT_RECTANGULAR);
  }
  const Gos::CircularShape *circular() const {
    return GetPointer<const Gos::CircularShape *>(VT_CIRCULAR);
  }
  const Gos::PolygonalShape *polygonal() const {
    return GetPointer<const Gos::PolygonalShape *>(VT_POLYGONAL);
  }
  const Gos::EllipticalShape *elliptical() const {
    return GetPointer<const Gos::EllipticalShape *>(VT_ELLIPTICAL);
  }
  const Gos::RadialShape *radial() const {
    return GetPointer<const Gos::RadialShape *>(VT_RADIAL);
  }
  const Gos::RadialShapes *radial_shapes() const {
    return GetPointer<const Gos::RadialShapes *>(VT_RADIAL_SHAPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECTANGULAR) &&
           verifier.VerifyTable(rectangular()) &&
           VerifyOffset(verifier, VT_CIRCULAR) &&
           verifier.VerifyTable(circular()) &&
           VerifyOffset(verifier, VT_POLYGONAL) &&
           verifier.VerifyTable(polygonal()) &&
           VerifyOffset(verifier, VT_ELLIPTICAL) &&
           verifier.VerifyTable(elliptical()) &&
           VerifyOffset(verifier, VT_RADIAL) &&
           verifier.VerifyTable(radial()) &&
           VerifyOffset(verifier, VT_RADIAL_SHAPES) &&
           verifier.VerifyTable(radial_shapes()) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  typedef Shape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rectangular(::flatbuffers::Offset<Gos::RectangularShape> rectangular) {
    fbb_.AddOffset(Shape::VT_RECTANGULAR, rectangular);
  }
  void add_circular(::flatbuffers::Offset<Gos::CircularShape> circular) {
    fbb_.AddOffset(Shape::VT_CIRCULAR, circular);
  }
  void add_polygonal(::flatbuffers::Offset<Gos::PolygonalShape> polygonal) {
    fbb_.AddOffset(Shape::VT_POLYGONAL, polygonal);
  }
  void add_elliptical(::flatbuffers::Offset<Gos::EllipticalShape> elliptical) {
    fbb_.AddOffset(Shape::VT_ELLIPTICAL, elliptical);
  }
  void add_radial(::flatbuffers::Offset<Gos::RadialShape> radial) {
    fbb_.AddOffset(Shape::VT_RADIAL, radial);
  }
  void add_radial_shapes(::flatbuffers::Offset<Gos::RadialShapes> radial_shapes) {
    fbb_.AddOffset(Shape::VT_RADIAL_SHAPES, radial_shapes);
  }
  explicit ShapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Shape> CreateShape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::RectangularShape> rectangular = 0,
    ::flatbuffers::Offset<Gos::CircularShape> circular = 0,
    ::flatbuffers::Offset<Gos::PolygonalShape> polygonal = 0,
    ::flatbuffers::Offset<Gos::EllipticalShape> elliptical = 0,
    ::flatbuffers::Offset<Gos::RadialShape> radial = 0,
    ::flatbuffers::Offset<Gos::RadialShapes> radial_shapes = 0) {
  ShapeBuilder builder_(_fbb);
  builder_.add_radial_shapes(radial_shapes);
  builder_.add_radial(radial);
  builder_.add_elliptical(elliptical);
  builder_.add_polygonal(polygonal);
  builder_.add_circular(circular);
  builder_.add_rectangular(rectangular);
  return builder_.Finish();
}

struct Speed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CONFIDENCE = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t confidence() const {
    return GetField<uint32_t>(VT_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct SpeedBuilder {
  typedef Speed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Speed::VT_VALUE, value, 0);
  }
  void add_confidence(uint32_t confidence) {
    fbb_.AddElement<uint32_t>(Speed::VT_CONFIDENCE, confidence, 0);
  }
  explicit SpeedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Speed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Speed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Speed> CreateSpeed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t confidence = 0) {
  SpeedBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VehicleIdentification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VehicleIdentificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WMI_NUMBER = 4,
    VT_VDS = 6
  };
  const ::flatbuffers::String *wmi_number() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WMI_NUMBER);
  }
  const ::flatbuffers::String *vds() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WMI_NUMBER) &&
           verifier.VerifyString(wmi_number()) &&
           VerifyOffset(verifier, VT_VDS) &&
           verifier.VerifyString(vds()) &&
           verifier.EndTable();
  }
};

struct VehicleIdentificationBuilder {
  typedef VehicleIdentification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wmi_number(::flatbuffers::Offset<::flatbuffers::String> wmi_number) {
    fbb_.AddOffset(VehicleIdentification::VT_WMI_NUMBER, wmi_number);
  }
  void add_vds(::flatbuffers::Offset<::flatbuffers::String> vds) {
    fbb_.AddOffset(VehicleIdentification::VT_VDS, vds);
  }
  explicit VehicleIdentificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VehicleIdentification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VehicleIdentification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VehicleIdentification> CreateVehicleIdentification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> wmi_number = 0,
    ::flatbuffers::Offset<::flatbuffers::String> vds = 0) {
  VehicleIdentificationBuilder builder_(_fbb);
  builder_.add_vds(vds);
  builder_.add_wmi_number(wmi_number);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VehicleIdentification> CreateVehicleIdentificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *wmi_number = nullptr,
    const char *vds = nullptr) {
  auto wmi_number__ = wmi_number ? _fbb.CreateString(wmi_number) : 0;
  auto vds__ = vds ? _fbb.CreateString(vds) : 0;
  return Gos::CreateVehicleIdentification(
      _fbb,
      wmi_number__,
      vds__);
}

struct VehicleLength FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VehicleLengthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_VEH_LEN_CONF_IND = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  Gos::VehicleLengthConfidenceIndication veh_len_conf_ind() const {
    return static_cast<Gos::VehicleLengthConfidenceIndication>(GetField<int32_t>(VT_VEH_LEN_CONF_IND, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_VEH_LEN_CONF_IND, 4) &&
           verifier.EndTable();
  }
};

struct VehicleLengthBuilder {
  typedef VehicleLength Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(VehicleLength::VT_VALUE, value, 0);
  }
  void add_veh_len_conf_ind(Gos::VehicleLengthConfidenceIndication veh_len_conf_ind) {
    fbb_.AddElement<int32_t>(VehicleLength::VT_VEH_LEN_CONF_IND, static_cast<int32_t>(veh_len_conf_ind), 0);
  }
  explicit VehicleLengthBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VehicleLength> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VehicleLength>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VehicleLength> CreateVehicleLength(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    Gos::VehicleLengthConfidenceIndication veh_len_conf_ind = Gos::VehicleLengthConfidenceIndication_VLCI_NO_TRAILER_PRESENT) {
  VehicleLengthBuilder builder_(_fbb);
  builder_.add_veh_len_conf_ind(veh_len_conf_ind);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VehicleWidth FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VehicleWidthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct VehicleWidthBuilder {
  typedef VehicleWidth Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(VehicleWidth::VT_VALUE, value, 0);
  }
  explicit VehicleWidthBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VehicleWidth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VehicleWidth>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VehicleWidth> CreateVehicleWidth(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  VehicleWidthBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct VelocityCartesian FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityCartesianBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_VELOCITY = 4,
    VT_Y_VELOCITY = 6,
    VT_Z_VELOCITY = 8
  };
  const Gos::VelocityComponent *x_velocity() const {
    return GetPointer<const Gos::VelocityComponent *>(VT_X_VELOCITY);
  }
  const Gos::VelocityComponent *y_velocity() const {
    return GetPointer<const Gos::VelocityComponent *>(VT_Y_VELOCITY);
  }
  const Gos::VelocityComponent *z_velocity() const {
    return GetPointer<const Gos::VelocityComponent *>(VT_Z_VELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_X_VELOCITY) &&
           verifier.VerifyTable(x_velocity()) &&
           VerifyOffsetRequired(verifier, VT_Y_VELOCITY) &&
           verifier.VerifyTable(y_velocity()) &&
           VerifyOffset(verifier, VT_Z_VELOCITY) &&
           verifier.VerifyTable(z_velocity()) &&
           verifier.EndTable();
  }
};

struct VelocityCartesianBuilder {
  typedef VelocityCartesian Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_velocity(::flatbuffers::Offset<Gos::VelocityComponent> x_velocity) {
    fbb_.AddOffset(VelocityCartesian::VT_X_VELOCITY, x_velocity);
  }
  void add_y_velocity(::flatbuffers::Offset<Gos::VelocityComponent> y_velocity) {
    fbb_.AddOffset(VelocityCartesian::VT_Y_VELOCITY, y_velocity);
  }
  void add_z_velocity(::flatbuffers::Offset<Gos::VelocityComponent> z_velocity) {
    fbb_.AddOffset(VelocityCartesian::VT_Z_VELOCITY, z_velocity);
  }
  explicit VelocityCartesianBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityCartesian> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityCartesian>(end);
    fbb_.Required(o, VelocityCartesian::VT_X_VELOCITY);
    fbb_.Required(o, VelocityCartesian::VT_Y_VELOCITY);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityCartesian> CreateVelocityCartesian(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::VelocityComponent> x_velocity = 0,
    ::flatbuffers::Offset<Gos::VelocityComponent> y_velocity = 0,
    ::flatbuffers::Offset<Gos::VelocityComponent> z_velocity = 0) {
  VelocityCartesianBuilder builder_(_fbb);
  builder_.add_z_velocity(z_velocity);
  builder_.add_y_velocity(y_velocity);
  builder_.add_x_velocity(x_velocity);
  return builder_.Finish();
}

struct VelocityComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VEL_COMP_VALUE = 4,
    VT_SPEED_CONFIDENCE = 6
  };
  int32_t vel_comp_value() const {
    return GetField<int32_t>(VT_VEL_COMP_VALUE, 0);
  }
  uint32_t speed_confidence() const {
    return GetField<uint32_t>(VT_SPEED_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VEL_COMP_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SPEED_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct VelocityComponentBuilder {
  typedef VelocityComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vel_comp_value(int32_t vel_comp_value) {
    fbb_.AddElement<int32_t>(VelocityComponent::VT_VEL_COMP_VALUE, vel_comp_value, 0);
  }
  void add_speed_confidence(uint32_t speed_confidence) {
    fbb_.AddElement<uint32_t>(VelocityComponent::VT_SPEED_CONFIDENCE, speed_confidence, 0);
  }
  explicit VelocityComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityComponent> CreateVelocityComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t vel_comp_value = 0,
    uint32_t speed_confidence = 0) {
  VelocityComponentBuilder builder_(_fbb);
  builder_.add_speed_confidence(speed_confidence);
  builder_.add_vel_comp_value(vel_comp_value);
  return builder_.Finish();
}

struct VelocityPolarWithZ FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VelocityPolarWithZBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VELOCITY_MAGNITUDE = 4,
    VT_VELOCITY_DIRECTION = 6,
    VT_Z_VELOCITY = 8
  };
  const Gos::Speed *velocity_magnitude() const {
    return GetPointer<const Gos::Speed *>(VT_VELOCITY_MAGNITUDE);
  }
  const Gos::CartesianAngle *velocity_direction() const {
    return GetPointer<const Gos::CartesianAngle *>(VT_VELOCITY_DIRECTION);
  }
  const Gos::VelocityComponent *z_velocity() const {
    return GetPointer<const Gos::VelocityComponent *>(VT_Z_VELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VELOCITY_MAGNITUDE) &&
           verifier.VerifyTable(velocity_magnitude()) &&
           VerifyOffsetRequired(verifier, VT_VELOCITY_DIRECTION) &&
           verifier.VerifyTable(velocity_direction()) &&
           VerifyOffset(verifier, VT_Z_VELOCITY) &&
           verifier.VerifyTable(z_velocity()) &&
           verifier.EndTable();
  }
};

struct VelocityPolarWithZBuilder {
  typedef VelocityPolarWithZ Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_velocity_magnitude(::flatbuffers::Offset<Gos::Speed> velocity_magnitude) {
    fbb_.AddOffset(VelocityPolarWithZ::VT_VELOCITY_MAGNITUDE, velocity_magnitude);
  }
  void add_velocity_direction(::flatbuffers::Offset<Gos::CartesianAngle> velocity_direction) {
    fbb_.AddOffset(VelocityPolarWithZ::VT_VELOCITY_DIRECTION, velocity_direction);
  }
  void add_z_velocity(::flatbuffers::Offset<Gos::VelocityComponent> z_velocity) {
    fbb_.AddOffset(VelocityPolarWithZ::VT_Z_VELOCITY, z_velocity);
  }
  explicit VelocityPolarWithZBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VelocityPolarWithZ> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VelocityPolarWithZ>(end);
    fbb_.Required(o, VelocityPolarWithZ::VT_VELOCITY_MAGNITUDE);
    fbb_.Required(o, VelocityPolarWithZ::VT_VELOCITY_DIRECTION);
    return o;
  }
};

inline ::flatbuffers::Offset<VelocityPolarWithZ> CreateVelocityPolarWithZ(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::Speed> velocity_magnitude = 0,
    ::flatbuffers::Offset<Gos::CartesianAngle> velocity_direction = 0,
    ::flatbuffers::Offset<Gos::VelocityComponent> z_velocity = 0) {
  VelocityPolarWithZBuilder builder_(_fbb);
  builder_.add_z_velocity(z_velocity);
  builder_.add_velocity_direction(velocity_direction);
  builder_.add_velocity_magnitude(velocity_magnitude);
  return builder_.Finish();
}

struct Velocity3dWithConfidence FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Velocity3dWithConfidenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POLAR_VELOCITY = 4,
    VT_CARTESIAN_VELOCITY = 6
  };
  const Gos::VelocityPolarWithZ *polar_velocity() const {
    return GetPointer<const Gos::VelocityPolarWithZ *>(VT_POLAR_VELOCITY);
  }
  const Gos::VelocityCartesian *cartesian_velocity() const {
    return GetPointer<const Gos::VelocityCartesian *>(VT_CARTESIAN_VELOCITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POLAR_VELOCITY) &&
           verifier.VerifyTable(polar_velocity()) &&
           VerifyOffset(verifier, VT_CARTESIAN_VELOCITY) &&
           verifier.VerifyTable(cartesian_velocity()) &&
           verifier.EndTable();
  }
};

struct Velocity3dWithConfidenceBuilder {
  typedef Velocity3dWithConfidence Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_polar_velocity(::flatbuffers::Offset<Gos::VelocityPolarWithZ> polar_velocity) {
    fbb_.AddOffset(Velocity3dWithConfidence::VT_POLAR_VELOCITY, polar_velocity);
  }
  void add_cartesian_velocity(::flatbuffers::Offset<Gos::VelocityCartesian> cartesian_velocity) {
    fbb_.AddOffset(Velocity3dWithConfidence::VT_CARTESIAN_VELOCITY, cartesian_velocity);
  }
  explicit Velocity3dWithConfidenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Velocity3dWithConfidence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Velocity3dWithConfidence>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Velocity3dWithConfidence> CreateVelocity3dWithConfidence(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Gos::VelocityPolarWithZ> polar_velocity = 0,
    ::flatbuffers::Offset<Gos::VelocityCartesian> cartesian_velocity = 0) {
  Velocity3dWithConfidenceBuilder builder_(_fbb);
  builder_.add_cartesian_velocity(cartesian_velocity);
  builder_.add_polar_velocity(polar_velocity);
  return builder_.Finish();
}

struct VruClusterProfiles FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VruClusterProfilesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEDESTRIAN = 4,
    VT_BICYCLIST = 6,
    VT_MOTORCYCLIST = 8,
    VT_ANIMAL = 10
  };
  bool pedestrian() const {
    return GetField<uint8_t>(VT_PEDESTRIAN, 0) != 0;
  }
  bool bicyclist() const {
    return GetField<uint8_t>(VT_BICYCLIST, 0) != 0;
  }
  bool motorcyclist() const {
    return GetField<uint8_t>(VT_MOTORCYCLIST, 0) != 0;
  }
  bool animal() const {
    return GetField<uint8_t>(VT_ANIMAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PEDESTRIAN, 1) &&
           VerifyField<uint8_t>(verifier, VT_BICYCLIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_MOTORCYCLIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_ANIMAL, 1) &&
           verifier.EndTable();
  }
};

struct VruClusterProfilesBuilder {
  typedef VruClusterProfiles Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pedestrian(bool pedestrian) {
    fbb_.AddElement<uint8_t>(VruClusterProfiles::VT_PEDESTRIAN, static_cast<uint8_t>(pedestrian), 0);
  }
  void add_bicyclist(bool bicyclist) {
    fbb_.AddElement<uint8_t>(VruClusterProfiles::VT_BICYCLIST, static_cast<uint8_t>(bicyclist), 0);
  }
  void add_motorcyclist(bool motorcyclist) {
    fbb_.AddElement<uint8_t>(VruClusterProfiles::VT_MOTORCYCLIST, static_cast<uint8_t>(motorcyclist), 0);
  }
  void add_animal(bool animal) {
    fbb_.AddElement<uint8_t>(VruClusterProfiles::VT_ANIMAL, static_cast<uint8_t>(animal), 0);
  }
  explicit VruClusterProfilesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VruClusterProfiles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VruClusterProfiles>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VruClusterProfiles> CreateVruClusterProfiles(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool pedestrian = false,
    bool bicyclist = false,
    bool motorcyclist = false,
    bool animal = false) {
  VruClusterProfilesBuilder builder_(_fbb);
  builder_.add_animal(animal);
  builder_.add_motorcyclist(motorcyclist);
  builder_.add_bicyclist(bicyclist);
  builder_.add_pedestrian(pedestrian);
  return builder_.Finish();
}

struct VruClusterInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VruClusterInformationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLUSTER_ID = 4,
    VT_CLUSTER_BOUNDING_BOX_SHAPE = 6,
    VT_CLUSTER_CARDINALITY_SIZE = 8,
    VT_CLUSTER_PROFILES = 10
  };
  uint32_t cluster_id() const {
    return GetField<uint32_t>(VT_CLUSTER_ID, 0);
  }
  const Gos::Shape *cluster_bounding_box_shape() const {
    return GetPointer<const Gos::Shape *>(VT_CLUSTER_BOUNDING_BOX_SHAPE);
  }
  uint32_t cluster_cardinality_size() const {
    return GetField<uint32_t>(VT_CLUSTER_CARDINALITY_SIZE, 0);
  }
  const Gos::VruClusterProfiles *cluster_profiles() const {
    return GetPointer<const Gos::VruClusterProfiles *>(VT_CLUSTER_PROFILES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CLUSTER_ID, 4) &&
           VerifyOffset(verifier, VT_CLUSTER_BOUNDING_BOX_SHAPE) &&
           verifier.VerifyTable(cluster_bounding_box_shape()) &&
           VerifyField<uint32_t>(verifier, VT_CLUSTER_CARDINALITY_SIZE, 4) &&
           VerifyOffset(verifier, VT_CLUSTER_PROFILES) &&
           verifier.VerifyTable(cluster_profiles()) &&
           verifier.EndTable();
  }
};

struct VruClusterInformationBuilder {
  typedef VruClusterInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cluster_id(uint32_t cluster_id) {
    fbb_.AddElement<uint32_t>(VruClusterInformation::VT_CLUSTER_ID, cluster_id, 0);
  }
  void add_cluster_bounding_box_shape(::flatbuffers::Offset<Gos::Shape> cluster_bounding_box_shape) {
    fbb_.AddOffset(VruClusterInformation::VT_CLUSTER_BOUNDING_BOX_SHAPE, cluster_bounding_box_shape);
  }
  void add_cluster_cardinality_size(uint32_t cluster_cardinality_size) {
    fbb_.AddElement<uint32_t>(VruClusterInformation::VT_CLUSTER_CARDINALITY_SIZE, cluster_cardinality_size, 0);
  }
  void add_cluster_profiles(::flatbuffers::Offset<Gos::VruClusterProfiles> cluster_profiles) {
    fbb_.AddOffset(VruClusterInformation::VT_CLUSTER_PROFILES, cluster_profiles);
  }
  explicit VruClusterInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VruClusterInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VruClusterInformation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VruClusterInformation> CreateVruClusterInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t cluster_id = 0,
    ::flatbuffers::Offset<Gos::Shape> cluster_bounding_box_shape = 0,
    uint32_t cluster_cardinality_size = 0,
    ::flatbuffers::Offset<Gos::VruClusterProfiles> cluster_profiles = 0) {
  VruClusterInformationBuilder builder_(_fbb);
  builder_.add_cluster_profiles(cluster_profiles);
  builder_.add_cluster_cardinality_size(cluster_cardinality_size);
  builder_.add_cluster_bounding_box_shape(cluster_bounding_box_shape);
  builder_.add_cluster_id(cluster_id);
  return builder_.Finish();
}

struct VruProfileAndSubprofile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VruProfileAndSubprofileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEDESTRIAN = 4,
    VT_BICYCLIST_AND_LIGHT_VRU_VEHICLE = 6,
    VT_MOTORCYCLIST = 8,
    VT_ANIMAL = 10
  };
  Gos::VruSubProfilePedestrian pedestrian() const {
    return static_cast<Gos::VruSubProfilePedestrian>(GetField<int32_t>(VT_PEDESTRIAN, 0));
  }
  Gos::VruSubProfileBicyclist bicyclist_and_light_vru_vehicle() const {
    return static_cast<Gos::VruSubProfileBicyclist>(GetField<int32_t>(VT_BICYCLIST_AND_LIGHT_VRU_VEHICLE, 0));
  }
  Gos::VruSubProfileMotorcyclist motorcyclist() const {
    return static_cast<Gos::VruSubProfileMotorcyclist>(GetField<int32_t>(VT_MOTORCYCLIST, 0));
  }
  Gos::VruSubProfileAnimal animal() const {
    return static_cast<Gos::VruSubProfileAnimal>(GetField<int32_t>(VT_ANIMAL, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEDESTRIAN, 4) &&
           VerifyField<int32_t>(verifier, VT_BICYCLIST_AND_LIGHT_VRU_VEHICLE, 4) &&
           VerifyField<int32_t>(verifier, VT_MOTORCYCLIST, 4) &&
           VerifyField<int32_t>(verifier, VT_ANIMAL, 4) &&
           verifier.EndTable();
  }
};

struct VruProfileAndSubprofileBuilder {
  typedef VruProfileAndSubprofile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pedestrian(Gos::VruSubProfilePedestrian pedestrian) {
    fbb_.AddElement<int32_t>(VruProfileAndSubprofile::VT_PEDESTRIAN, static_cast<int32_t>(pedestrian), 0);
  }
  void add_bicyclist_and_light_vru_vehicle(Gos::VruSubProfileBicyclist bicyclist_and_light_vru_vehicle) {
    fbb_.AddElement<int32_t>(VruProfileAndSubprofile::VT_BICYCLIST_AND_LIGHT_VRU_VEHICLE, static_cast<int32_t>(bicyclist_and_light_vru_vehicle), 0);
  }
  void add_motorcyclist(Gos::VruSubProfileMotorcyclist motorcyclist) {
    fbb_.AddElement<int32_t>(VruProfileAndSubprofile::VT_MOTORCYCLIST, static_cast<int32_t>(motorcyclist), 0);
  }
  void add_animal(Gos::VruSubProfileAnimal animal) {
    fbb_.AddElement<int32_t>(VruProfileAndSubprofile::VT_ANIMAL, static_cast<int32_t>(animal), 0);
  }
  explicit VruProfileAndSubprofileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VruProfileAndSubprofile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VruProfileAndSubprofile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VruProfileAndSubprofile> CreateVruProfileAndSubprofile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Gos::VruSubProfilePedestrian pedestrian = Gos::VruSubProfilePedestrian_PED_UNAVAILABLE,
    Gos::VruSubProfileBicyclist bicyclist_and_light_vru_vehicle = Gos::VruSubProfileBicyclist_BC_UNAVAILABLE,
    Gos::VruSubProfileMotorcyclist motorcyclist = Gos::VruSubProfileMotorcyclist_MC_UNAVAILABLE,
    Gos::VruSubProfileAnimal animal = Gos::VruSubProfileAnimal_AN_UNAVAILABLE) {
  VruProfileAndSubprofileBuilder builder_(_fbb);
  builder_.add_animal(animal);
  builder_.add_motorcyclist(motorcyclist);
  builder_.add_bicyclist_and_light_vru_vehicle(bicyclist_and_light_vru_vehicle);
  builder_.add_pedestrian(pedestrian);
  return builder_.Finish();
}

struct Wgs84Angle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Wgs84AngleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WGS_ANGLE_VALUE = 4,
    VT_WGS84_ANGLE_CONFIDENCE = 6
  };
  uint32_t wgs_angle_value() const {
    return GetField<uint32_t>(VT_WGS_ANGLE_VALUE, 0);
  }
  uint32_t wgs84_angle_confidence() const {
    return GetField<uint32_t>(VT_WGS84_ANGLE_CONFIDENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_WGS_ANGLE_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_WGS84_ANGLE_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct Wgs84AngleBuilder {
  typedef Wgs84Angle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wgs_angle_value(uint32_t wgs_angle_value) {
    fbb_.AddElement<uint32_t>(Wgs84Angle::VT_WGS_ANGLE_VALUE, wgs_angle_value, 0);
  }
  void add_wgs84_angle_confidence(uint32_t wgs84_angle_confidence) {
    fbb_.AddElement<uint32_t>(Wgs84Angle::VT_WGS84_ANGLE_CONFIDENCE, wgs84_angle_confidence, 0);
  }
  explicit Wgs84AngleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Wgs84Angle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Wgs84Angle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Wgs84Angle> CreateWgs84Angle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t wgs_angle_value = 0,
    uint32_t wgs84_angle_confidence = 0) {
  Wgs84AngleBuilder builder_(_fbb);
  builder_.add_wgs84_angle_confidence(wgs84_angle_confidence);
  builder_.add_wgs_angle_value(wgs_angle_value);
  return builder_.Finish();
}

struct YawRate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef YawRateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_YAW_RATE_VALUE = 4,
    VT_YAW_RATE_CONFIDENCE = 6
  };
  int32_t yaw_rate_value() const {
    return GetField<int32_t>(VT_YAW_RATE_VALUE, 0);
  }
  Gos::YawRateConfidence yaw_rate_confidence() const {
    return static_cast<Gos::YawRateConfidence>(GetField<int32_t>(VT_YAW_RATE_CONFIDENCE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_YAW_RATE_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_YAW_RATE_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
};

struct YawRateBuilder {
  typedef YawRate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_yaw_rate_value(int32_t yaw_rate_value) {
    fbb_.AddElement<int32_t>(YawRate::VT_YAW_RATE_VALUE, yaw_rate_value, 0);
  }
  void add_yaw_rate_confidence(Gos::YawRateConfidence yaw_rate_confidence) {
    fbb_.AddElement<int32_t>(YawRate::VT_YAW_RATE_CONFIDENCE, static_cast<int32_t>(yaw_rate_confidence), 0);
  }
  explicit YawRateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<YawRate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<YawRate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<YawRate> CreateYawRate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t yaw_rate_value = 0,
    Gos::YawRateConfidence yaw_rate_confidence = Gos::YawRateConfidence_YRC_DEGSEC_000_01) {
  YawRateBuilder builder_(_fbb);
  builder_.add_yaw_rate_confidence(yaw_rate_confidence);
  builder_.add_yaw_rate_value(yaw_rate_value);
  return builder_.Finish();
}

inline bool VerifyFacilityLayerMessage(::flatbuffers::Verifier &verifier, const void *obj, FacilityLayerMessage type) {
  switch (type) {
    case FacilityLayerMessage_NONE: {
      return true;
    }
    case FacilityLayerMessage_CAMessage: {
      auto ptr = reinterpret_cast<const Gos::CAMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FacilityLayerMessage_CPMessage: {
      auto ptr = reinterpret_cast<const Gos::CPMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFacilityLayerMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFacilityLayerMessage(
        verifier,  values->Get(i), types->GetEnum<FacilityLayerMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGossipType(::flatbuffers::Verifier &verifier, const void *obj, GossipType type) {
  switch (type) {
    case GossipType_NONE: {
      return true;
    }
    case GossipType_ChannelBusyRatio: {
      auto ptr = reinterpret_cast<const Gos::ChannelBusyRatio *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GossipType_LinkLayerReception: {
      auto ptr = reinterpret_cast<const Gos::LinkLayerReception *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GossipType_FacilityLayerReception: {
      auto ptr = reinterpret_cast<const Gos::FacilityLayerReception *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGossipTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGossipType(
        verifier,  values->Get(i), types->GetEnum<GossipType>(i))) {
      return false;
    }
  }
  return true;
}

inline const Gos::GossipMessage *GetGossipMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Gos::GossipMessage>(buf);
}

inline const Gos::GossipMessage *GetSizePrefixedGossipMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Gos::GossipMessage>(buf);
}

inline bool VerifyGossipMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Gos::GossipMessage>(nullptr);
}

inline bool VerifySizePrefixedGossipMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Gos::GossipMessage>(nullptr);
}

inline void FinishGossipMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Gos::GossipMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGossipMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Gos::GossipMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Gos

#endif  // FLATBUFFERS_GENERATED_ALLINTERFACENEW_GOS_H_
