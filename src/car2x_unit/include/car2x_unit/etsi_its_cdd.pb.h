// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: etsi_its_cdd.proto

#ifndef PROTOBUF_INCLUDED_etsi_5fits_5fcdd_2eproto
#define PROTOBUF_INCLUDED_etsi_5fits_5fcdd_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_etsi_5fits_5fcdd_2eproto 

namespace protobuf_etsi_5fits_5fcdd_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[64];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_etsi_5fits_5fcdd_2eproto
class Acceleration3dWithConfidence;
class Acceleration3dWithConfidenceDefaultTypeInternal;
extern Acceleration3dWithConfidenceDefaultTypeInternal _Acceleration3dWithConfidence_default_instance_;
class AccelerationCartesian;
class AccelerationCartesianDefaultTypeInternal;
extern AccelerationCartesianDefaultTypeInternal _AccelerationCartesian_default_instance_;
class AccelerationComponent;
class AccelerationComponentDefaultTypeInternal;
extern AccelerationComponentDefaultTypeInternal _AccelerationComponent_default_instance_;
class AccelerationMagnitude;
class AccelerationMagnitudeDefaultTypeInternal;
extern AccelerationMagnitudeDefaultTypeInternal _AccelerationMagnitude_default_instance_;
class AccelerationPolarWithZ;
class AccelerationPolarWithZDefaultTypeInternal;
extern AccelerationPolarWithZDefaultTypeInternal _AccelerationPolarWithZ_default_instance_;
class ActionID;
class ActionIDDefaultTypeInternal;
extern ActionIDDefaultTypeInternal _ActionID_default_instance_;
class Altitude;
class AltitudeDefaultTypeInternal;
extern AltitudeDefaultTypeInternal _Altitude_default_instance_;
class CartesianAngle;
class CartesianAngleDefaultTypeInternal;
extern CartesianAngleDefaultTypeInternal _CartesianAngle_default_instance_;
class CartesianAngularVelocityComponent;
class CartesianAngularVelocityComponentDefaultTypeInternal;
extern CartesianAngularVelocityComponentDefaultTypeInternal _CartesianAngularVelocityComponent_default_instance_;
class CartesianCoordinateWithConfidence;
class CartesianCoordinateWithConfidenceDefaultTypeInternal;
extern CartesianCoordinateWithConfidenceDefaultTypeInternal _CartesianCoordinateWithConfidence_default_instance_;
class CartesianPosition3d;
class CartesianPosition3dDefaultTypeInternal;
extern CartesianPosition3dDefaultTypeInternal _CartesianPosition3d_default_instance_;
class CartesianPosition3dWithConfidence;
class CartesianPosition3dWithConfidenceDefaultTypeInternal;
extern CartesianPosition3dWithConfidenceDefaultTypeInternal _CartesianPosition3dWithConfidence_default_instance_;
class CauseCode;
class CauseCodeDefaultTypeInternal;
extern CauseCodeDefaultTypeInternal _CauseCode_default_instance_;
class CircularShape;
class CircularShapeDefaultTypeInternal;
extern CircularShapeDefaultTypeInternal _CircularShape_default_instance_;
class ClosedLanes;
class ClosedLanesDefaultTypeInternal;
extern ClosedLanesDefaultTypeInternal _ClosedLanes_default_instance_;
class CorrelationColumn;
class CorrelationColumnDefaultTypeInternal;
extern CorrelationColumnDefaultTypeInternal _CorrelationColumn_default_instance_;
class Curvature;
class CurvatureDefaultTypeInternal;
extern CurvatureDefaultTypeInternal _Curvature_default_instance_;
class DangerousGoodsExtended;
class DangerousGoodsExtendedDefaultTypeInternal;
extern DangerousGoodsExtendedDefaultTypeInternal _DangerousGoodsExtended_default_instance_;
class DeltaReferencePosition;
class DeltaReferencePositionDefaultTypeInternal;
extern DeltaReferencePositionDefaultTypeInternal _DeltaReferencePosition_default_instance_;
class EllipticalShape;
class EllipticalShapeDefaultTypeInternal;
extern EllipticalShapeDefaultTypeInternal _EllipticalShape_default_instance_;
class EnergyStorageType;
class EnergyStorageTypeDefaultTypeInternal;
extern EnergyStorageTypeDefaultTypeInternal _EnergyStorageType_default_instance_;
class EulerAnglesWithConfidence;
class EulerAnglesWithConfidenceDefaultTypeInternal;
extern EulerAnglesWithConfidenceDefaultTypeInternal _EulerAnglesWithConfidence_default_instance_;
class EventHistory;
class EventHistoryDefaultTypeInternal;
extern EventHistoryDefaultTypeInternal _EventHistory_default_instance_;
class EventPoint;
class EventPointDefaultTypeInternal;
extern EventPointDefaultTypeInternal _EventPoint_default_instance_;
class Heading;
class HeadingDefaultTypeInternal;
extern HeadingDefaultTypeInternal _Heading_default_instance_;
class IntersectionReferenceID;
class IntersectionReferenceIDDefaultTypeInternal;
extern IntersectionReferenceIDDefaultTypeInternal _IntersectionReferenceID_default_instance_;
class ItineraryPath;
class ItineraryPathDefaultTypeInternal;
extern ItineraryPathDefaultTypeInternal _ItineraryPath_default_instance_;
class LongitudinalAcceleration;
class LongitudinalAccelerationDefaultTypeInternal;
extern LongitudinalAccelerationDefaultTypeInternal _LongitudinalAcceleration_default_instance_;
class LongitudinalLanePosition;
class LongitudinalLanePositionDefaultTypeInternal;
extern LongitudinalLanePositionDefaultTypeInternal _LongitudinalLanePosition_default_instance_;
class LowerTriangularPositiveSemidefiniteMatrix;
class LowerTriangularPositiveSemidefiniteMatrixDefaultTypeInternal;
extern LowerTriangularPositiveSemidefiniteMatrixDefaultTypeInternal _LowerTriangularPositiveSemidefiniteMatrix_default_instance_;
class LowerTriangularPositiveSemidefiniteMatrixColumns;
class LowerTriangularPositiveSemidefiniteMatrixColumnsDefaultTypeInternal;
extern LowerTriangularPositiveSemidefiniteMatrixColumnsDefaultTypeInternal _LowerTriangularPositiveSemidefiniteMatrixColumns_default_instance_;
class MapPosition;
class MapPositionDefaultTypeInternal;
extern MapPositionDefaultTypeInternal _MapPosition_default_instance_;
class MapReference;
class MapReferenceDefaultTypeInternal;
extern MapReferenceDefaultTypeInternal _MapReference_default_instance_;
class MatrixIncludedComponents;
class MatrixIncludedComponentsDefaultTypeInternal;
extern MatrixIncludedComponentsDefaultTypeInternal _MatrixIncludedComponents_default_instance_;
class MessageRateHz;
class MessageRateHzDefaultTypeInternal;
extern MessageRateHzDefaultTypeInternal _MessageRateHz_default_instance_;
class MessageSegmentationInfo;
class MessageSegmentationInfoDefaultTypeInternal;
extern MessageSegmentationInfoDefaultTypeInternal _MessageSegmentationInfo_default_instance_;
class ObjectClass;
class ObjectClassDefaultTypeInternal;
extern ObjectClassDefaultTypeInternal _ObjectClass_default_instance_;
class ObjectClassWithConfidence;
class ObjectClassWithConfidenceDefaultTypeInternal;
extern ObjectClassWithConfidenceDefaultTypeInternal _ObjectClassWithConfidence_default_instance_;
class ObjectDimension;
class ObjectDimensionDefaultTypeInternal;
extern ObjectDimensionDefaultTypeInternal _ObjectDimension_default_instance_;
class OtherSubClass;
class OtherSubClassDefaultTypeInternal;
extern OtherSubClassDefaultTypeInternal _OtherSubClass_default_instance_;
class PolygonalShape;
class PolygonalShapeDefaultTypeInternal;
extern PolygonalShapeDefaultTypeInternal _PolygonalShape_default_instance_;
class PositionConfidenceEllipse;
class PositionConfidenceEllipseDefaultTypeInternal;
extern PositionConfidenceEllipseDefaultTypeInternal _PositionConfidenceEllipse_default_instance_;
class RadialShape;
class RadialShapeDefaultTypeInternal;
extern RadialShapeDefaultTypeInternal _RadialShape_default_instance_;
class RadialShapeDetails;
class RadialShapeDetailsDefaultTypeInternal;
extern RadialShapeDetailsDefaultTypeInternal _RadialShapeDetails_default_instance_;
class RadialShapes;
class RadialShapesDefaultTypeInternal;
extern RadialShapesDefaultTypeInternal _RadialShapes_default_instance_;
class RectangularShape;
class RectangularShapeDefaultTypeInternal;
extern RectangularShapeDefaultTypeInternal _RectangularShape_default_instance_;
class ReferenceDenms;
class ReferenceDenmsDefaultTypeInternal;
extern ReferenceDenmsDefaultTypeInternal _ReferenceDenms_default_instance_;
class ReferencePosition;
class ReferencePositionDefaultTypeInternal;
extern ReferencePositionDefaultTypeInternal _ReferencePosition_default_instance_;
class RestrictedTypes;
class RestrictedTypesDefaultTypeInternal;
extern RestrictedTypesDefaultTypeInternal _RestrictedTypes_default_instance_;
class RoadSegmentReferenceID;
class RoadSegmentReferenceIDDefaultTypeInternal;
extern RoadSegmentReferenceIDDefaultTypeInternal _RoadSegmentReferenceID_default_instance_;
class Shape;
class ShapeDefaultTypeInternal;
extern ShapeDefaultTypeInternal _Shape_default_instance_;
class Speed;
class SpeedDefaultTypeInternal;
extern SpeedDefaultTypeInternal _Speed_default_instance_;
class VehicleIdentification;
class VehicleIdentificationDefaultTypeInternal;
extern VehicleIdentificationDefaultTypeInternal _VehicleIdentification_default_instance_;
class VehicleLength;
class VehicleLengthDefaultTypeInternal;
extern VehicleLengthDefaultTypeInternal _VehicleLength_default_instance_;
class VehicleWidth;
class VehicleWidthDefaultTypeInternal;
extern VehicleWidthDefaultTypeInternal _VehicleWidth_default_instance_;
class Velocity3dWithConfidence;
class Velocity3dWithConfidenceDefaultTypeInternal;
extern Velocity3dWithConfidenceDefaultTypeInternal _Velocity3dWithConfidence_default_instance_;
class VelocityCartesian;
class VelocityCartesianDefaultTypeInternal;
extern VelocityCartesianDefaultTypeInternal _VelocityCartesian_default_instance_;
class VelocityComponent;
class VelocityComponentDefaultTypeInternal;
extern VelocityComponentDefaultTypeInternal _VelocityComponent_default_instance_;
class VelocityPolarWithZ;
class VelocityPolarWithZDefaultTypeInternal;
extern VelocityPolarWithZDefaultTypeInternal _VelocityPolarWithZ_default_instance_;
class VruClusterInformation;
class VruClusterInformationDefaultTypeInternal;
extern VruClusterInformationDefaultTypeInternal _VruClusterInformation_default_instance_;
class VruClusterProfiles;
class VruClusterProfilesDefaultTypeInternal;
extern VruClusterProfilesDefaultTypeInternal _VruClusterProfiles_default_instance_;
class VruProfileAndSubprofile;
class VruProfileAndSubprofileDefaultTypeInternal;
extern VruProfileAndSubprofileDefaultTypeInternal _VruProfileAndSubprofile_default_instance_;
class Wgs84Angle;
class Wgs84AngleDefaultTypeInternal;
extern Wgs84AngleDefaultTypeInternal _Wgs84Angle_default_instance_;
class YawRate;
class YawRateDefaultTypeInternal;
extern YawRateDefaultTypeInternal _YawRate_default_instance_;
namespace google {
namespace protobuf {
template<> ::Acceleration3dWithConfidence* Arena::CreateMaybeMessage<::Acceleration3dWithConfidence>(Arena*);
template<> ::AccelerationCartesian* Arena::CreateMaybeMessage<::AccelerationCartesian>(Arena*);
template<> ::AccelerationComponent* Arena::CreateMaybeMessage<::AccelerationComponent>(Arena*);
template<> ::AccelerationMagnitude* Arena::CreateMaybeMessage<::AccelerationMagnitude>(Arena*);
template<> ::AccelerationPolarWithZ* Arena::CreateMaybeMessage<::AccelerationPolarWithZ>(Arena*);
template<> ::ActionID* Arena::CreateMaybeMessage<::ActionID>(Arena*);
template<> ::Altitude* Arena::CreateMaybeMessage<::Altitude>(Arena*);
template<> ::CartesianAngle* Arena::CreateMaybeMessage<::CartesianAngle>(Arena*);
template<> ::CartesianAngularVelocityComponent* Arena::CreateMaybeMessage<::CartesianAngularVelocityComponent>(Arena*);
template<> ::CartesianCoordinateWithConfidence* Arena::CreateMaybeMessage<::CartesianCoordinateWithConfidence>(Arena*);
template<> ::CartesianPosition3d* Arena::CreateMaybeMessage<::CartesianPosition3d>(Arena*);
template<> ::CartesianPosition3dWithConfidence* Arena::CreateMaybeMessage<::CartesianPosition3dWithConfidence>(Arena*);
template<> ::CauseCode* Arena::CreateMaybeMessage<::CauseCode>(Arena*);
template<> ::CircularShape* Arena::CreateMaybeMessage<::CircularShape>(Arena*);
template<> ::ClosedLanes* Arena::CreateMaybeMessage<::ClosedLanes>(Arena*);
template<> ::CorrelationColumn* Arena::CreateMaybeMessage<::CorrelationColumn>(Arena*);
template<> ::Curvature* Arena::CreateMaybeMessage<::Curvature>(Arena*);
template<> ::DangerousGoodsExtended* Arena::CreateMaybeMessage<::DangerousGoodsExtended>(Arena*);
template<> ::DeltaReferencePosition* Arena::CreateMaybeMessage<::DeltaReferencePosition>(Arena*);
template<> ::EllipticalShape* Arena::CreateMaybeMessage<::EllipticalShape>(Arena*);
template<> ::EnergyStorageType* Arena::CreateMaybeMessage<::EnergyStorageType>(Arena*);
template<> ::EulerAnglesWithConfidence* Arena::CreateMaybeMessage<::EulerAnglesWithConfidence>(Arena*);
template<> ::EventHistory* Arena::CreateMaybeMessage<::EventHistory>(Arena*);
template<> ::EventPoint* Arena::CreateMaybeMessage<::EventPoint>(Arena*);
template<> ::Heading* Arena::CreateMaybeMessage<::Heading>(Arena*);
template<> ::IntersectionReferenceID* Arena::CreateMaybeMessage<::IntersectionReferenceID>(Arena*);
template<> ::ItineraryPath* Arena::CreateMaybeMessage<::ItineraryPath>(Arena*);
template<> ::LongitudinalAcceleration* Arena::CreateMaybeMessage<::LongitudinalAcceleration>(Arena*);
template<> ::LongitudinalLanePosition* Arena::CreateMaybeMessage<::LongitudinalLanePosition>(Arena*);
template<> ::LowerTriangularPositiveSemidefiniteMatrix* Arena::CreateMaybeMessage<::LowerTriangularPositiveSemidefiniteMatrix>(Arena*);
template<> ::LowerTriangularPositiveSemidefiniteMatrixColumns* Arena::CreateMaybeMessage<::LowerTriangularPositiveSemidefiniteMatrixColumns>(Arena*);
template<> ::MapPosition* Arena::CreateMaybeMessage<::MapPosition>(Arena*);
template<> ::MapReference* Arena::CreateMaybeMessage<::MapReference>(Arena*);
template<> ::MatrixIncludedComponents* Arena::CreateMaybeMessage<::MatrixIncludedComponents>(Arena*);
template<> ::MessageRateHz* Arena::CreateMaybeMessage<::MessageRateHz>(Arena*);
template<> ::MessageSegmentationInfo* Arena::CreateMaybeMessage<::MessageSegmentationInfo>(Arena*);
template<> ::ObjectClass* Arena::CreateMaybeMessage<::ObjectClass>(Arena*);
template<> ::ObjectClassWithConfidence* Arena::CreateMaybeMessage<::ObjectClassWithConfidence>(Arena*);
template<> ::ObjectDimension* Arena::CreateMaybeMessage<::ObjectDimension>(Arena*);
template<> ::OtherSubClass* Arena::CreateMaybeMessage<::OtherSubClass>(Arena*);
template<> ::PolygonalShape* Arena::CreateMaybeMessage<::PolygonalShape>(Arena*);
template<> ::PositionConfidenceEllipse* Arena::CreateMaybeMessage<::PositionConfidenceEllipse>(Arena*);
template<> ::RadialShape* Arena::CreateMaybeMessage<::RadialShape>(Arena*);
template<> ::RadialShapeDetails* Arena::CreateMaybeMessage<::RadialShapeDetails>(Arena*);
template<> ::RadialShapes* Arena::CreateMaybeMessage<::RadialShapes>(Arena*);
template<> ::RectangularShape* Arena::CreateMaybeMessage<::RectangularShape>(Arena*);
template<> ::ReferenceDenms* Arena::CreateMaybeMessage<::ReferenceDenms>(Arena*);
template<> ::ReferencePosition* Arena::CreateMaybeMessage<::ReferencePosition>(Arena*);
template<> ::RestrictedTypes* Arena::CreateMaybeMessage<::RestrictedTypes>(Arena*);
template<> ::RoadSegmentReferenceID* Arena::CreateMaybeMessage<::RoadSegmentReferenceID>(Arena*);
template<> ::Shape* Arena::CreateMaybeMessage<::Shape>(Arena*);
template<> ::Speed* Arena::CreateMaybeMessage<::Speed>(Arena*);
template<> ::VehicleIdentification* Arena::CreateMaybeMessage<::VehicleIdentification>(Arena*);
template<> ::VehicleLength* Arena::CreateMaybeMessage<::VehicleLength>(Arena*);
template<> ::VehicleWidth* Arena::CreateMaybeMessage<::VehicleWidth>(Arena*);
template<> ::Velocity3dWithConfidence* Arena::CreateMaybeMessage<::Velocity3dWithConfidence>(Arena*);
template<> ::VelocityCartesian* Arena::CreateMaybeMessage<::VelocityCartesian>(Arena*);
template<> ::VelocityComponent* Arena::CreateMaybeMessage<::VelocityComponent>(Arena*);
template<> ::VelocityPolarWithZ* Arena::CreateMaybeMessage<::VelocityPolarWithZ>(Arena*);
template<> ::VruClusterInformation* Arena::CreateMaybeMessage<::VruClusterInformation>(Arena*);
template<> ::VruClusterProfiles* Arena::CreateMaybeMessage<::VruClusterProfiles>(Arena*);
template<> ::VruProfileAndSubprofile* Arena::CreateMaybeMessage<::VruProfileAndSubprofile>(Arena*);
template<> ::Wgs84Angle* Arena::CreateMaybeMessage<::Wgs84Angle>(Arena*);
template<> ::YawRate* Arena::CreateMaybeMessage<::YawRate>(Arena*);
}  // namespace protobuf
}  // namespace google

enum AngularSpeedConfidence {
  ASC_DEGSEC_01 = 0,
  ASC_DEGSEC_02 = 1,
  ASC_DEGSEC_05 = 2,
  ASC_DEGSEC_10 = 3,
  ASC_DEGSEC_20 = 4,
  ASC_DEGSEC_50 = 5,
  ASC_OUTOFRANGE = 6,
  ASC_UNAVAILABLE = 7
};
bool AngularSpeedConfidence_IsValid(int value);
const AngularSpeedConfidence AngularSpeedConfidence_MIN = ASC_DEGSEC_01;
const AngularSpeedConfidence AngularSpeedConfidence_MAX = ASC_UNAVAILABLE;
const int AngularSpeedConfidence_ARRAYSIZE = AngularSpeedConfidence_MAX + 1;

const ::google::protobuf::EnumDescriptor* AngularSpeedConfidence_descriptor();
inline const ::std::string& AngularSpeedConfidence_Name(AngularSpeedConfidence value) {
  return ::google::protobuf::internal::NameOfEnum(
    AngularSpeedConfidence_descriptor(), value);
}
inline bool AngularSpeedConfidence_Parse(
    const ::std::string& name, AngularSpeedConfidence* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AngularSpeedConfidence>(
    AngularSpeedConfidence_descriptor(), name, value);
}
enum CurvatureCalculationMode {
  CCM_YAWRATEUSED = 0,
  CCM_YAWRATENOTUSED = 1,
  CCM_UNAVAILABLE = 2
};
bool CurvatureCalculationMode_IsValid(int value);
const CurvatureCalculationMode CurvatureCalculationMode_MIN = CCM_YAWRATEUSED;
const CurvatureCalculationMode CurvatureCalculationMode_MAX = CCM_UNAVAILABLE;
const int CurvatureCalculationMode_ARRAYSIZE = CurvatureCalculationMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CurvatureCalculationMode_descriptor();
inline const ::std::string& CurvatureCalculationMode_Name(CurvatureCalculationMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CurvatureCalculationMode_descriptor(), value);
}
inline bool CurvatureCalculationMode_Parse(
    const ::std::string& name, CurvatureCalculationMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CurvatureCalculationMode>(
    CurvatureCalculationMode_descriptor(), name, value);
}
enum CauseCodeType {
  CCT_TRAFFICCONDITION = 1,
  CCT_ACCIDENT = 2,
  CCT_ROADWORKS = 3,
  CCT_IMPASSABILITY = 5,
  CCT_ADVERSEWEATHERCONDITION_ADHESION = 6,
  CCT_AQUAPLANING = 7,
  CCT_HAZARDOUSLOCATION_SURFACECONDITION = 9,
  CCT_HAZARDOUSLOCATION_OBSTACLEONTHEROAD = 10,
  CCT_HAZARDOUSLOCATION_ANIMALONTHEROAD = 11,
  CCT_HUMANPRESENCEONTHEROAD = 12,
  CCT_WRONGWAYDRIVING = 14,
  CCT_RESCUEANDRECOVERYWORKINPROGRESS = 15,
  CCT_ADVERSEWEATHERCONDITION_EXTREMEWEATHERCONDITION = 17,
  CCT_ADVERSEWEATHERCONDITION_VISIBILITY = 18,
  CCT_ADVERSEWEATHERCONDITION_PRECIPITATION = 19,
  CCT_VIOLENCE = 20,
  CCT_SLOWVEHICLE = 26,
  CCT_DANGEROUSENDOFQUEUE = 27,
  CCT_VEHICLEBREAKDOWN = 91,
  CCT_POSTCRASH = 92,
  CCT_HUMANPROBLEM = 93,
  CCT_STATIONARYVEHICLE = 94,
  CCT_EMERGENCYVEHICLEAPPROACHING = 95,
  CCT_HAZARDOUSLOCATION_DANGEROUSCURVE = 96,
  CCT_COLLISIONRISK = 97,
  CCT_SIGNALVIOLATION = 98,
  CCT_DANGEROUSSITUATION = 99,
  CCT_RAILWAYLEVELCROSSING = 100
};
bool CauseCodeType_IsValid(int value);
const CauseCodeType CauseCodeType_MIN = CCT_TRAFFICCONDITION;
const CauseCodeType CauseCodeType_MAX = CCT_RAILWAYLEVELCROSSING;
const int CauseCodeType_ARRAYSIZE = CauseCodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CauseCodeType_descriptor();
inline const ::std::string& CauseCodeType_Name(CauseCodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CauseCodeType_descriptor(), value);
}
inline bool CauseCodeType_Parse(
    const ::std::string& name, CauseCodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CauseCodeType>(
    CauseCodeType_descriptor(), name, value);
}
enum DangerousGoodsBasic {
  DGB_EXPLOSIVES1 = 0,
  DGB_EXPLOSIVES2 = 1,
  DGB_EXPLOSIVES3 = 2,
  DGB_EXPLOSIVES4 = 3,
  DGB_EXPLOSIVES5 = 4,
  DGB_EXPLOSIVES6 = 5,
  DGB_FLAMMABLEGASES = 6,
  DGB_NONFLAMMABLEGASES = 7,
  DGB_TOXICGASES = 8,
  DGB_FLAMMABLELIQUIDS = 9,
  DGB_FLAMMABLESOLIDS = 10,
  DGB_SUBSTANCESLIABLETOSPONTANEOUSCOMBUSTION = 11,
  DGB_SUBSTANCESEMITTINGFLAMMABLEGASESUPONCONTACTWITHWATER = 12,
  DGB_OXIDIZINGSUBSTANCES = 13,
  DGB_ORGANICPEROXIDES = 14,
  DGB_TOXICSUBSTANCES = 15,
  DGB_INFECTIOUSSUBSTANCES = 16,
  DGB_RADIOACTIVEMATERIAL = 17,
  DGB_CORROSIVESUBSTANCES = 18,
  DGB_MISCELLANEOUSDANGEROUSSUBSTANCES = 19
};
bool DangerousGoodsBasic_IsValid(int value);
const DangerousGoodsBasic DangerousGoodsBasic_MIN = DGB_EXPLOSIVES1;
const DangerousGoodsBasic DangerousGoodsBasic_MAX = DGB_MISCELLANEOUSDANGEROUSSUBSTANCES;
const int DangerousGoodsBasic_ARRAYSIZE = DangerousGoodsBasic_MAX + 1;

const ::google::protobuf::EnumDescriptor* DangerousGoodsBasic_descriptor();
inline const ::std::string& DangerousGoodsBasic_Name(DangerousGoodsBasic value) {
  return ::google::protobuf::internal::NameOfEnum(
    DangerousGoodsBasic_descriptor(), value);
}
inline bool DangerousGoodsBasic_Parse(
    const ::std::string& name, DangerousGoodsBasic* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DangerousGoodsBasic>(
    DangerousGoodsBasic_descriptor(), name, value);
}
enum DriveDirection {
  DD_FORWARD = 0,
  DD_BACKWARD = 1,
  DD_UNAVAILABLE = 2
};
bool DriveDirection_IsValid(int value);
const DriveDirection DriveDirection_MIN = DD_FORWARD;
const DriveDirection DriveDirection_MAX = DD_UNAVAILABLE;
const int DriveDirection_ARRAYSIZE = DriveDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* DriveDirection_descriptor();
inline const ::std::string& DriveDirection_Name(DriveDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    DriveDirection_descriptor(), value);
}
inline bool DriveDirection_Parse(
    const ::std::string& name, DriveDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DriveDirection>(
    DriveDirection_descriptor(), name, value);
}
enum HardShoulderStatus {
  HSS_AVAILABLEFORSTOPPING = 0,
  HSS_CLOSED = 1,
  HSS_AVAILABLEFORDRIVING = 2
};
bool HardShoulderStatus_IsValid(int value);
const HardShoulderStatus HardShoulderStatus_MIN = HSS_AVAILABLEFORSTOPPING;
const HardShoulderStatus HardShoulderStatus_MAX = HSS_AVAILABLEFORDRIVING;
const int HardShoulderStatus_ARRAYSIZE = HardShoulderStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* HardShoulderStatus_descriptor();
inline const ::std::string& HardShoulderStatus_Name(HardShoulderStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    HardShoulderStatus_descriptor(), value);
}
inline bool HardShoulderStatus_Parse(
    const ::std::string& name, HardShoulderStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HardShoulderStatus>(
    HardShoulderStatus_descriptor(), name, value);
}
enum LightBarSirenInUse {
  LS_LIGHTBARACTIVATED = 0,
  LS_SIRENACTIVATED = 1
};
bool LightBarSirenInUse_IsValid(int value);
const LightBarSirenInUse LightBarSirenInUse_MIN = LS_LIGHTBARACTIVATED;
const LightBarSirenInUse LightBarSirenInUse_MAX = LS_SIRENACTIVATED;
const int LightBarSirenInUse_ARRAYSIZE = LightBarSirenInUse_MAX + 1;

const ::google::protobuf::EnumDescriptor* LightBarSirenInUse_descriptor();
inline const ::std::string& LightBarSirenInUse_Name(LightBarSirenInUse value) {
  return ::google::protobuf::internal::NameOfEnum(
    LightBarSirenInUse_descriptor(), value);
}
inline bool LightBarSirenInUse_Parse(
    const ::std::string& name, LightBarSirenInUse* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LightBarSirenInUse>(
    LightBarSirenInUse_descriptor(), name, value);
}
enum PositioningSolutionType {
  PST_NOPOSITIONINGSOLUTION = 0,
  PST_SGNSS = 1,
  PST_DGNSS = 2,
  PST_SGNSSPLUSDR = 3,
  PST_DGNSSPLUSDR = 4,
  PST_DR = 5
};
bool PositioningSolutionType_IsValid(int value);
const PositioningSolutionType PositioningSolutionType_MIN = PST_NOPOSITIONINGSOLUTION;
const PositioningSolutionType PositioningSolutionType_MAX = PST_DR;
const int PositioningSolutionType_ARRAYSIZE = PositioningSolutionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositioningSolutionType_descriptor();
inline const ::std::string& PositioningSolutionType_Name(PositioningSolutionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositioningSolutionType_descriptor(), value);
}
inline bool PositioningSolutionType_Parse(
    const ::std::string& name, PositioningSolutionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositioningSolutionType>(
    PositioningSolutionType_descriptor(), name, value);
}
enum PositionOfOccupants {
  POS_OCC_ROW1LEFTOCCUPIED = 0,
  POS_OCC_ROW1RIGHTOCCUPIED = 1,
  POS_OCC_ROW1MIDOCCUPIED = 2,
  POS_OCC_ROW1NOTDETECTABLE = 3,
  POS_OCC_ROW1NOTPRESENT = 4,
  POS_OCC_ROW2LEFTOCCUPIED = 5,
  POS_OCC_ROW2RIGHTOCCUPIED = 6,
  POS_OCC_ROW2MIDOCCUPIED = 7,
  POS_OCC_ROW2NOTDETECTABLE = 8,
  POS_OCC_ROW2NOTPRESENT = 9,
  POS_OCC_ROW3LEFTOCCUPIED = 10,
  POS_OCC_ROW3RIGHTOCCUPIED = 11,
  POS_OCC_ROW3MIDOCCUPIED = 12,
  POS_OCC_ROW3NOTDETECTABLE = 13,
  POS_OCC_ROW3NOTPRESENT = 14,
  POS_OCC_ROW4LEFTOCCUPIED = 15,
  POS_OCC_ROW4RIGHTOCCUPIED = 16,
  POS_OCC_ROW4MIDOCCUPIED = 17,
  POS_OCC_ROW4NOTDETECTABLE = 18,
  POS_OCC_ROW4NOTPRESENT = 19
};
bool PositionOfOccupants_IsValid(int value);
const PositionOfOccupants PositionOfOccupants_MIN = POS_OCC_ROW1LEFTOCCUPIED;
const PositionOfOccupants PositionOfOccupants_MAX = POS_OCC_ROW4NOTPRESENT;
const int PositionOfOccupants_ARRAYSIZE = PositionOfOccupants_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionOfOccupants_descriptor();
inline const ::std::string& PositionOfOccupants_Name(PositionOfOccupants value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionOfOccupants_descriptor(), value);
}
inline bool PositionOfOccupants_Parse(
    const ::std::string& name, PositionOfOccupants* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionOfOccupants>(
    PositionOfOccupants_descriptor(), name, value);
}
enum RelevanceDistance {
  REL_DIST_LESSTHAN50M = 0,
  REL_DIST_LESSTHAN100M = 1,
  REL_DIST_LESSTHAN200M = 2,
  REL_DIST_LESSTHAN500M = 3,
  REL_DIST_LESSTHAN1000M = 4,
  REL_DIST_LESSTHAN5KM = 5,
  REL_DIST_LESSTHAN10KM = 6,
  REL_DIST_OVER10KM = 7
};
bool RelevanceDistance_IsValid(int value);
const RelevanceDistance RelevanceDistance_MIN = REL_DIST_LESSTHAN50M;
const RelevanceDistance RelevanceDistance_MAX = REL_DIST_OVER10KM;
const int RelevanceDistance_ARRAYSIZE = RelevanceDistance_MAX + 1;

const ::google::protobuf::EnumDescriptor* RelevanceDistance_descriptor();
inline const ::std::string& RelevanceDistance_Name(RelevanceDistance value) {
  return ::google::protobuf::internal::NameOfEnum(
    RelevanceDistance_descriptor(), value);
}
inline bool RelevanceDistance_Parse(
    const ::std::string& name, RelevanceDistance* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RelevanceDistance>(
    RelevanceDistance_descriptor(), name, value);
}
enum RelevanceTrafficDirection {
  REL_TD_ALLTRAFFICDIRECTIONS = 0,
  REL_TD_UPSTREAMTRAFFIC = 1,
  REL_TD_DOWNSTREAMTRAFFIC = 2,
  REL_TD_OPPOSITETRAFFIC = 3
};
bool RelevanceTrafficDirection_IsValid(int value);
const RelevanceTrafficDirection RelevanceTrafficDirection_MIN = REL_TD_ALLTRAFFICDIRECTIONS;
const RelevanceTrafficDirection RelevanceTrafficDirection_MAX = REL_TD_OPPOSITETRAFFIC;
const int RelevanceTrafficDirection_ARRAYSIZE = RelevanceTrafficDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* RelevanceTrafficDirection_descriptor();
inline const ::std::string& RelevanceTrafficDirection_Name(RelevanceTrafficDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    RelevanceTrafficDirection_descriptor(), value);
}
inline bool RelevanceTrafficDirection_Parse(
    const ::std::string& name, RelevanceTrafficDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RelevanceTrafficDirection>(
    RelevanceTrafficDirection_descriptor(), name, value);
}
enum RequestResponseIndication {
  RRI_REQUEST = 0,
  RRI_RESPONSE = 1
};
bool RequestResponseIndication_IsValid(int value);
const RequestResponseIndication RequestResponseIndication_MIN = RRI_REQUEST;
const RequestResponseIndication RequestResponseIndication_MAX = RRI_RESPONSE;
const int RequestResponseIndication_ARRAYSIZE = RequestResponseIndication_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestResponseIndication_descriptor();
inline const ::std::string& RequestResponseIndication_Name(RequestResponseIndication value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestResponseIndication_descriptor(), value);
}
inline bool RequestResponseIndication_Parse(
    const ::std::string& name, RequestResponseIndication* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestResponseIndication>(
    RequestResponseIndication_descriptor(), name, value);
}
enum RoadType {
  RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES = 0,
  RT_URBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES = 1,
  RT_NONURBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES = 2,
  RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES = 3
};
bool RoadType_IsValid(int value);
const RoadType RoadType_MIN = RT_URBAN_NOSTRUCTURALSEPARATIONTOOPPOSITELANES;
const RoadType RoadType_MAX = RT_NONURBAN_WITHSTRUCTURALSEPARATIONTOOPPOSITELANES;
const int RoadType_ARRAYSIZE = RoadType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadType_descriptor();
inline const ::std::string& RoadType_Name(RoadType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadType_descriptor(), value);
}
inline bool RoadType_Parse(
    const ::std::string& name, RoadType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadType>(
    RoadType_descriptor(), name, value);
}
enum SensorType {
  SNSR_UNDEFINED = 0,
  SNSR_RADAR = 1,
  SNSR_LIDAR = 2,
  SNSR_MONOVIDEO = 3,
  SNSR_STEROVISION = 4,
  SNSR_NIGHTVISION = 5,
  SNSR_ULTRASONIC = 6,
  SNSR_PMD = 7,
  SNSR_INDUCTIONLOOP = 8,
  SNSR_SPHERICALCAMERA = 9,
  SNSR_UWB = 10,
  SNSR_ACOUSTIC = 11,
  SNSR_LOCALAGGREGATION = 12,
  SNSR_ITSAGGREGATION = 13
};
bool SensorType_IsValid(int value);
const SensorType SensorType_MIN = SNSR_UNDEFINED;
const SensorType SensorType_MAX = SNSR_ITSAGGREGATION;
const int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorType_descriptor();
inline const ::std::string& SensorType_Name(SensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorType_descriptor(), value);
}
inline bool SensorType_Parse(
    const ::std::string& name, SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
enum StationarySince {
  STATIONARY_SINCE_LESSTHAN1MINUTE = 0,
  STATIONARY_SINCE_LESSTHAN2MINUTES = 1,
  STATIONARY_SINCE_LESSTHAN15MINUTES = 2,
  STATIONARY_SINCE_EQUALORGREATER15MINUTES = 3
};
bool StationarySince_IsValid(int value);
const StationarySince StationarySince_MIN = STATIONARY_SINCE_LESSTHAN1MINUTE;
const StationarySince StationarySince_MAX = STATIONARY_SINCE_EQUALORGREATER15MINUTES;
const int StationarySince_ARRAYSIZE = StationarySince_MAX + 1;

const ::google::protobuf::EnumDescriptor* StationarySince_descriptor();
inline const ::std::string& StationarySince_Name(StationarySince value) {
  return ::google::protobuf::internal::NameOfEnum(
    StationarySince_descriptor(), value);
}
inline bool StationarySince_Parse(
    const ::std::string& name, StationarySince* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StationarySince>(
    StationarySince_descriptor(), name, value);
}
enum StationType {
  STN_TYPE_UNKNOWN = 0,
  STN_TYPE_PEDESTRIAN = 1,
  STN_TYPE_CYCLIST = 2,
  STN_TYPE_MOPED = 3,
  STN_TYPE_MOTORCYCLE = 4,
  STN_TYPE_PASSENGER_CAR = 5,
  STN_TYPE_BUS = 6,
  STN_TYPE_LIGHT_TRUCK = 7,
  STN_TYPE_HEAVY_TRUCK = 8,
  STN_TYPE_TRAILER = 9,
  STN_TYPE_SPECIAL_VEHICLE = 10,
  STN_TYPE_TRAM = 11,
  STN_TYPE_ROAD_SIDE_UNIT = 15
};
bool StationType_IsValid(int value);
const StationType StationType_MIN = STN_TYPE_UNKNOWN;
const StationType StationType_MAX = STN_TYPE_ROAD_SIDE_UNIT;
const int StationType_ARRAYSIZE = StationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StationType_descriptor();
inline const ::std::string& StationType_Name(StationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StationType_descriptor(), value);
}
inline bool StationType_Parse(
    const ::std::string& name, StationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StationType>(
    StationType_descriptor(), name, value);
}
enum TrafficParticipantType {
  TP_TYPE_UNKNOWN = 0,
  TP_TYPE_PEDESTRIAN = 1,
  TP_TYPE_CYCLIST = 2,
  TP_TYPE_MOPED = 3,
  TP_TYPE_MOTORCYCLE = 4,
  TP_TYPE_PASSENGERCAR = 5,
  TP_TYPE_BUS = 6,
  TP_TYPE_LIGHTTRUCK = 7,
  TP_TYPE_HEAVYTRUCK = 8,
  TP_TYPE_TRAILER = 9,
  TP_TYPE_SPECIALVEHICLE = 10,
  TP_TYPE_TRAM = 11,
  TP_TYPE_LIGHTVRUVEHICLE = 12,
  TP_TYPE_ANIMAL = 13,
  TP_TYPE_AGRICULTURAL = 14,
  TP_TYPE_ROADSIDEUNIT = 15
};
bool TrafficParticipantType_IsValid(int value);
const TrafficParticipantType TrafficParticipantType_MIN = TP_TYPE_UNKNOWN;
const TrafficParticipantType TrafficParticipantType_MAX = TP_TYPE_ROADSIDEUNIT;
const int TrafficParticipantType_ARRAYSIZE = TrafficParticipantType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficParticipantType_descriptor();
inline const ::std::string& TrafficParticipantType_Name(TrafficParticipantType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficParticipantType_descriptor(), value);
}
inline bool TrafficParticipantType_Parse(
    const ::std::string& name, TrafficParticipantType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficParticipantType>(
    TrafficParticipantType_descriptor(), name, value);
}
enum TrafficRule {
  TR_NOPASSING = 0,
  TR_NOPASSINGFORTRUCKS = 1,
  TR_PASSTORIGHT = 2,
  TR_PASSTOLEFT = 3
};
bool TrafficRule_IsValid(int value);
const TrafficRule TrafficRule_MIN = TR_NOPASSING;
const TrafficRule TrafficRule_MAX = TR_PASSTOLEFT;
const int TrafficRule_ARRAYSIZE = TrafficRule_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficRule_descriptor();
inline const ::std::string& TrafficRule_Name(TrafficRule value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficRule_descriptor(), value);
}
inline bool TrafficRule_Parse(
    const ::std::string& name, TrafficRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficRule>(
    TrafficRule_descriptor(), name, value);
}
enum VehicleLengthConfidenceIndication {
  VLCI_NO_TRAILER_PRESENT = 0,
  VLCI_TRAILER_PRESENT_WITH_KNOWN_LENGTH = 1,
  VLCI_TRAILER_PRESENT_WITH_UNKNOWN_LENGTH = 2,
  VLCI_TRAILER_PRESENCE_IS_UNKNOWN = 3,
  VLCI_UNAVAILABLE = 4
};
bool VehicleLengthConfidenceIndication_IsValid(int value);
const VehicleLengthConfidenceIndication VehicleLengthConfidenceIndication_MIN = VLCI_NO_TRAILER_PRESENT;
const VehicleLengthConfidenceIndication VehicleLengthConfidenceIndication_MAX = VLCI_UNAVAILABLE;
const int VehicleLengthConfidenceIndication_ARRAYSIZE = VehicleLengthConfidenceIndication_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleLengthConfidenceIndication_descriptor();
inline const ::std::string& VehicleLengthConfidenceIndication_Name(VehicleLengthConfidenceIndication value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleLengthConfidenceIndication_descriptor(), value);
}
inline bool VehicleLengthConfidenceIndication_Parse(
    const ::std::string& name, VehicleLengthConfidenceIndication* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleLengthConfidenceIndication>(
    VehicleLengthConfidenceIndication_descriptor(), name, value);
}
enum VruSubProfilePedestrian {
  PED_UNAVAILABLE = 0,
  PED_ORDINARY_PEDESTRIAN = 1,
  PED_ROAD_WORKER = 2,
  PED_FIRST_RESPONDER = 3,
  PED_MAX = 15
};
bool VruSubProfilePedestrian_IsValid(int value);
const VruSubProfilePedestrian VruSubProfilePedestrian_MIN = PED_UNAVAILABLE;
const VruSubProfilePedestrian VruSubProfilePedestrian_MAX = PED_MAX;
const int VruSubProfilePedestrian_ARRAYSIZE = VruSubProfilePedestrian_MAX + 1;

const ::google::protobuf::EnumDescriptor* VruSubProfilePedestrian_descriptor();
inline const ::std::string& VruSubProfilePedestrian_Name(VruSubProfilePedestrian value) {
  return ::google::protobuf::internal::NameOfEnum(
    VruSubProfilePedestrian_descriptor(), value);
}
inline bool VruSubProfilePedestrian_Parse(
    const ::std::string& name, VruSubProfilePedestrian* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VruSubProfilePedestrian>(
    VruSubProfilePedestrian_descriptor(), name, value);
}
enum VruSubProfileBicyclist {
  BC_UNAVAILABLE = 0,
  BC_BICYCLIST = 1,
  BC_WHEELCHAIR_USER = 2,
  BC_HORSE_AND_RIDER = 3,
  BC_ROLLERSKATER = 4,
  BC_E_SCOOTER = 5,
  BC_PERSONAL_TRANSPORTER = 6,
  BC_PEDELEC = 7,
  BC_SPEED_PEDELEC = 8,
  BC_MAX = 15
};
bool VruSubProfileBicyclist_IsValid(int value);
const VruSubProfileBicyclist VruSubProfileBicyclist_MIN = BC_UNAVAILABLE;
const VruSubProfileBicyclist VruSubProfileBicyclist_MAX = BC_MAX;
const int VruSubProfileBicyclist_ARRAYSIZE = VruSubProfileBicyclist_MAX + 1;

const ::google::protobuf::EnumDescriptor* VruSubProfileBicyclist_descriptor();
inline const ::std::string& VruSubProfileBicyclist_Name(VruSubProfileBicyclist value) {
  return ::google::protobuf::internal::NameOfEnum(
    VruSubProfileBicyclist_descriptor(), value);
}
inline bool VruSubProfileBicyclist_Parse(
    const ::std::string& name, VruSubProfileBicyclist* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VruSubProfileBicyclist>(
    VruSubProfileBicyclist_descriptor(), name, value);
}
enum VruSubProfileMotorcyclist {
  MC_UNAVAILABLE = 0,
  MC_MOPED = 1,
  MC_MOTORCYCLE = 2,
  MC_MOTORCYCLE_AND_SIDECAR_RIGHT = 3,
  MC_MOTORCYCLE_AND_SIDECAR_LEFT = 4,
  MC_MAX = 15
};
bool VruSubProfileMotorcyclist_IsValid(int value);
const VruSubProfileMotorcyclist VruSubProfileMotorcyclist_MIN = MC_UNAVAILABLE;
const VruSubProfileMotorcyclist VruSubProfileMotorcyclist_MAX = MC_MAX;
const int VruSubProfileMotorcyclist_ARRAYSIZE = VruSubProfileMotorcyclist_MAX + 1;

const ::google::protobuf::EnumDescriptor* VruSubProfileMotorcyclist_descriptor();
inline const ::std::string& VruSubProfileMotorcyclist_Name(VruSubProfileMotorcyclist value) {
  return ::google::protobuf::internal::NameOfEnum(
    VruSubProfileMotorcyclist_descriptor(), value);
}
inline bool VruSubProfileMotorcyclist_Parse(
    const ::std::string& name, VruSubProfileMotorcyclist* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VruSubProfileMotorcyclist>(
    VruSubProfileMotorcyclist_descriptor(), name, value);
}
enum VruSubProfileAnimal {
  AN_UNAVAILABLE = 0,
  AN_WILD_ANIMAL = 1,
  AN_FARM_ANIMAL = 2,
  AN_SERVICE_ANIMAL = 3,
  AN_MAX = 15
};
bool VruSubProfileAnimal_IsValid(int value);
const VruSubProfileAnimal VruSubProfileAnimal_MIN = AN_UNAVAILABLE;
const VruSubProfileAnimal VruSubProfileAnimal_MAX = AN_MAX;
const int VruSubProfileAnimal_ARRAYSIZE = VruSubProfileAnimal_MAX + 1;

const ::google::protobuf::EnumDescriptor* VruSubProfileAnimal_descriptor();
inline const ::std::string& VruSubProfileAnimal_Name(VruSubProfileAnimal value) {
  return ::google::protobuf::internal::NameOfEnum(
    VruSubProfileAnimal_descriptor(), value);
}
inline bool VruSubProfileAnimal_Parse(
    const ::std::string& name, VruSubProfileAnimal* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VruSubProfileAnimal>(
    VruSubProfileAnimal_descriptor(), name, value);
}
enum YawRateConfidence {
  YRC_degSec_000_01 = 0,
  YRC_degSec_000_05 = 1,
  YRC_degSec_000_10 = 2,
  YRC_degSec_001_00 = 3,
  YRC_degSec_005_00 = 4,
  YRC_degSec_010_00 = 5,
  YRC_degSec_100_00 = 6,
  YRC_OutOfRange = 7,
  YRC_UNAVAILABLE = 8
};
bool YawRateConfidence_IsValid(int value);
const YawRateConfidence YawRateConfidence_MIN = YRC_degSec_000_01;
const YawRateConfidence YawRateConfidence_MAX = YRC_UNAVAILABLE;
const int YawRateConfidence_ARRAYSIZE = YawRateConfidence_MAX + 1;

const ::google::protobuf::EnumDescriptor* YawRateConfidence_descriptor();
inline const ::std::string& YawRateConfidence_Name(YawRateConfidence value) {
  return ::google::protobuf::internal::NameOfEnum(
    YawRateConfidence_descriptor(), value);
}
inline bool YawRateConfidence_Parse(
    const ::std::string& name, YawRateConfidence* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YawRateConfidence>(
    YawRateConfidence_descriptor(), name, value);
}
// ===================================================================

class Acceleration3dWithConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Acceleration3dWithConfidence) */ {
 public:
  Acceleration3dWithConfidence();
  virtual ~Acceleration3dWithConfidence();

  Acceleration3dWithConfidence(const Acceleration3dWithConfidence& from);

  inline Acceleration3dWithConfidence& operator=(const Acceleration3dWithConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Acceleration3dWithConfidence(Acceleration3dWithConfidence&& from) noexcept
    : Acceleration3dWithConfidence() {
    *this = ::std::move(from);
  }

  inline Acceleration3dWithConfidence& operator=(Acceleration3dWithConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Acceleration3dWithConfidence& default_instance();

  enum AccelarationCase {
    kPolarAcceleration = 1,
    kCartesianAcceleration = 2,
    ACCELARATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Acceleration3dWithConfidence* internal_default_instance() {
    return reinterpret_cast<const Acceleration3dWithConfidence*>(
               &_Acceleration3dWithConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Acceleration3dWithConfidence* other);
  friend void swap(Acceleration3dWithConfidence& a, Acceleration3dWithConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Acceleration3dWithConfidence* New() const final {
    return CreateMaybeMessage<Acceleration3dWithConfidence>(NULL);
  }

  Acceleration3dWithConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Acceleration3dWithConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Acceleration3dWithConfidence& from);
  void MergeFrom(const Acceleration3dWithConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Acceleration3dWithConfidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AccelerationPolarWithZ polarAcceleration = 1;
  bool has_polaracceleration() const;
  void clear_polaracceleration();
  static const int kPolarAccelerationFieldNumber = 1;
  private:
  const ::AccelerationPolarWithZ& _internal_polaracceleration() const;
  public:
  const ::AccelerationPolarWithZ& polaracceleration() const;
  ::AccelerationPolarWithZ* release_polaracceleration();
  ::AccelerationPolarWithZ* mutable_polaracceleration();
  void set_allocated_polaracceleration(::AccelerationPolarWithZ* polaracceleration);

  // optional .AccelerationCartesian cartesianAcceleration = 2;
  bool has_cartesianacceleration() const;
  void clear_cartesianacceleration();
  static const int kCartesianAccelerationFieldNumber = 2;
  private:
  const ::AccelerationCartesian& _internal_cartesianacceleration() const;
  public:
  const ::AccelerationCartesian& cartesianacceleration() const;
  ::AccelerationCartesian* release_cartesianacceleration();
  ::AccelerationCartesian* mutable_cartesianacceleration();
  void set_allocated_cartesianacceleration(::AccelerationCartesian* cartesianacceleration);

  void clear_accelaration();
  AccelarationCase accelaration_case() const;
  // @@protoc_insertion_point(class_scope:Acceleration3dWithConfidence)
 private:
  void set_has_polaracceleration();
  void set_has_cartesianacceleration();

  inline bool has_accelaration() const;
  inline void clear_has_accelaration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union AccelarationUnion {
    AccelarationUnion() {}
    ::AccelerationPolarWithZ* polaracceleration_;
    ::AccelerationCartesian* cartesianacceleration_;
  } accelaration_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccelerationCartesian : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AccelerationCartesian) */ {
 public:
  AccelerationCartesian();
  virtual ~AccelerationCartesian();

  AccelerationCartesian(const AccelerationCartesian& from);

  inline AccelerationCartesian& operator=(const AccelerationCartesian& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccelerationCartesian(AccelerationCartesian&& from) noexcept
    : AccelerationCartesian() {
    *this = ::std::move(from);
  }

  inline AccelerationCartesian& operator=(AccelerationCartesian&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerationCartesian& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccelerationCartesian* internal_default_instance() {
    return reinterpret_cast<const AccelerationCartesian*>(
               &_AccelerationCartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AccelerationCartesian* other);
  friend void swap(AccelerationCartesian& a, AccelerationCartesian& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccelerationCartesian* New() const final {
    return CreateMaybeMessage<AccelerationCartesian>(NULL);
  }

  AccelerationCartesian* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccelerationCartesian>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccelerationCartesian& from);
  void MergeFrom(const AccelerationCartesian& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerationCartesian* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AccelerationComponent xAcceleration = 1;
  bool has_xacceleration() const;
  void clear_xacceleration();
  static const int kXAccelerationFieldNumber = 1;
  private:
  const ::AccelerationComponent& _internal_xacceleration() const;
  public:
  const ::AccelerationComponent& xacceleration() const;
  ::AccelerationComponent* release_xacceleration();
  ::AccelerationComponent* mutable_xacceleration();
  void set_allocated_xacceleration(::AccelerationComponent* xacceleration);

  // required .AccelerationComponent yAcceleration = 2;
  bool has_yacceleration() const;
  void clear_yacceleration();
  static const int kYAccelerationFieldNumber = 2;
  private:
  const ::AccelerationComponent& _internal_yacceleration() const;
  public:
  const ::AccelerationComponent& yacceleration() const;
  ::AccelerationComponent* release_yacceleration();
  ::AccelerationComponent* mutable_yacceleration();
  void set_allocated_yacceleration(::AccelerationComponent* yacceleration);

  // optional .AccelerationComponent zAcceleration = 3;
  bool has_zacceleration() const;
  void clear_zacceleration();
  static const int kZAccelerationFieldNumber = 3;
  private:
  const ::AccelerationComponent& _internal_zacceleration() const;
  public:
  const ::AccelerationComponent& zacceleration() const;
  ::AccelerationComponent* release_zacceleration();
  ::AccelerationComponent* mutable_zacceleration();
  void set_allocated_zacceleration(::AccelerationComponent* zacceleration);

  // @@protoc_insertion_point(class_scope:AccelerationCartesian)
 private:
  void set_has_xacceleration();
  void clear_has_xacceleration();
  void set_has_yacceleration();
  void clear_has_yacceleration();
  void set_has_zacceleration();
  void clear_has_zacceleration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::AccelerationComponent* xacceleration_;
  ::AccelerationComponent* yacceleration_;
  ::AccelerationComponent* zacceleration_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccelerationComponent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AccelerationComponent) */ {
 public:
  AccelerationComponent();
  virtual ~AccelerationComponent();

  AccelerationComponent(const AccelerationComponent& from);

  inline AccelerationComponent& operator=(const AccelerationComponent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccelerationComponent(AccelerationComponent&& from) noexcept
    : AccelerationComponent() {
    *this = ::std::move(from);
  }

  inline AccelerationComponent& operator=(AccelerationComponent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerationComponent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccelerationComponent* internal_default_instance() {
    return reinterpret_cast<const AccelerationComponent*>(
               &_AccelerationComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AccelerationComponent* other);
  friend void swap(AccelerationComponent& a, AccelerationComponent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccelerationComponent* New() const final {
    return CreateMaybeMessage<AccelerationComponent>(NULL);
  }

  AccelerationComponent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccelerationComponent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccelerationComponent& from);
  void MergeFrom(const AccelerationComponent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerationComponent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // required uint32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 confidence() const;
  void set_confidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AccelerationComponent)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::uint32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccelerationMagnitude : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AccelerationMagnitude) */ {
 public:
  AccelerationMagnitude();
  virtual ~AccelerationMagnitude();

  AccelerationMagnitude(const AccelerationMagnitude& from);

  inline AccelerationMagnitude& operator=(const AccelerationMagnitude& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccelerationMagnitude(AccelerationMagnitude&& from) noexcept
    : AccelerationMagnitude() {
    *this = ::std::move(from);
  }

  inline AccelerationMagnitude& operator=(AccelerationMagnitude&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerationMagnitude& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccelerationMagnitude* internal_default_instance() {
    return reinterpret_cast<const AccelerationMagnitude*>(
               &_AccelerationMagnitude_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AccelerationMagnitude* other);
  friend void swap(AccelerationMagnitude& a, AccelerationMagnitude& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccelerationMagnitude* New() const final {
    return CreateMaybeMessage<AccelerationMagnitude>(NULL);
  }

  AccelerationMagnitude* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccelerationMagnitude>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccelerationMagnitude& from);
  void MergeFrom(const AccelerationMagnitude& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerationMagnitude* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 accelerationMagnitudeValue = 1;
  bool has_accelerationmagnitudevalue() const;
  void clear_accelerationmagnitudevalue();
  static const int kAccelerationMagnitudeValueFieldNumber = 1;
  ::google::protobuf::uint32 accelerationmagnitudevalue() const;
  void set_accelerationmagnitudevalue(::google::protobuf::uint32 value);

  // required uint32 accelerationConfidence = 2;
  bool has_accelerationconfidence() const;
  void clear_accelerationconfidence();
  static const int kAccelerationConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 accelerationconfidence() const;
  void set_accelerationconfidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AccelerationMagnitude)
 private:
  void set_has_accelerationmagnitudevalue();
  void clear_has_accelerationmagnitudevalue();
  void set_has_accelerationconfidence();
  void clear_has_accelerationconfidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 accelerationmagnitudevalue_;
  ::google::protobuf::uint32 accelerationconfidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccelerationPolarWithZ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AccelerationPolarWithZ) */ {
 public:
  AccelerationPolarWithZ();
  virtual ~AccelerationPolarWithZ();

  AccelerationPolarWithZ(const AccelerationPolarWithZ& from);

  inline AccelerationPolarWithZ& operator=(const AccelerationPolarWithZ& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccelerationPolarWithZ(AccelerationPolarWithZ&& from) noexcept
    : AccelerationPolarWithZ() {
    *this = ::std::move(from);
  }

  inline AccelerationPolarWithZ& operator=(AccelerationPolarWithZ&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerationPolarWithZ& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccelerationPolarWithZ* internal_default_instance() {
    return reinterpret_cast<const AccelerationPolarWithZ*>(
               &_AccelerationPolarWithZ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AccelerationPolarWithZ* other);
  friend void swap(AccelerationPolarWithZ& a, AccelerationPolarWithZ& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccelerationPolarWithZ* New() const final {
    return CreateMaybeMessage<AccelerationPolarWithZ>(NULL);
  }

  AccelerationPolarWithZ* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccelerationPolarWithZ>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccelerationPolarWithZ& from);
  void MergeFrom(const AccelerationPolarWithZ& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerationPolarWithZ* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AccelerationMagnitude accelerationMagnitude = 1;
  bool has_accelerationmagnitude() const;
  void clear_accelerationmagnitude();
  static const int kAccelerationMagnitudeFieldNumber = 1;
  private:
  const ::AccelerationMagnitude& _internal_accelerationmagnitude() const;
  public:
  const ::AccelerationMagnitude& accelerationmagnitude() const;
  ::AccelerationMagnitude* release_accelerationmagnitude();
  ::AccelerationMagnitude* mutable_accelerationmagnitude();
  void set_allocated_accelerationmagnitude(::AccelerationMagnitude* accelerationmagnitude);

  // required .CartesianAngle accelerationDirection = 2;
  bool has_accelerationdirection() const;
  void clear_accelerationdirection();
  static const int kAccelerationDirectionFieldNumber = 2;
  private:
  const ::CartesianAngle& _internal_accelerationdirection() const;
  public:
  const ::CartesianAngle& accelerationdirection() const;
  ::CartesianAngle* release_accelerationdirection();
  ::CartesianAngle* mutable_accelerationdirection();
  void set_allocated_accelerationdirection(::CartesianAngle* accelerationdirection);

  // optional .AccelerationComponent zAcceleration = 3;
  bool has_zacceleration() const;
  void clear_zacceleration();
  static const int kZAccelerationFieldNumber = 3;
  private:
  const ::AccelerationComponent& _internal_zacceleration() const;
  public:
  const ::AccelerationComponent& zacceleration() const;
  ::AccelerationComponent* release_zacceleration();
  ::AccelerationComponent* mutable_zacceleration();
  void set_allocated_zacceleration(::AccelerationComponent* zacceleration);

  // @@protoc_insertion_point(class_scope:AccelerationPolarWithZ)
 private:
  void set_has_accelerationmagnitude();
  void clear_has_accelerationmagnitude();
  void set_has_accelerationdirection();
  void clear_has_accelerationdirection();
  void set_has_zacceleration();
  void clear_has_zacceleration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::AccelerationMagnitude* accelerationmagnitude_;
  ::CartesianAngle* accelerationdirection_;
  ::AccelerationComponent* zacceleration_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ActionID) */ {
 public:
  ActionID();
  virtual ~ActionID();

  ActionID(const ActionID& from);

  inline ActionID& operator=(const ActionID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionID(ActionID&& from) noexcept
    : ActionID() {
    *this = ::std::move(from);
  }

  inline ActionID& operator=(ActionID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionID* internal_default_instance() {
    return reinterpret_cast<const ActionID*>(
               &_ActionID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ActionID* other);
  friend void swap(ActionID& a, ActionID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionID* New() const final {
    return CreateMaybeMessage<ActionID>(NULL);
  }

  ActionID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionID& from);
  void MergeFrom(const ActionID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 originatingStationId = 1;
  bool has_originatingstationid() const;
  void clear_originatingstationid();
  static const int kOriginatingStationIdFieldNumber = 1;
  ::google::protobuf::uint64 originatingstationid() const;
  void set_originatingstationid(::google::protobuf::uint64 value);

  // required uint32 sequenceNumber = 2;
  bool has_sequencenumber() const;
  void clear_sequencenumber();
  static const int kSequenceNumberFieldNumber = 2;
  ::google::protobuf::uint32 sequencenumber() const;
  void set_sequencenumber(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ActionID)
 private:
  void set_has_originatingstationid();
  void clear_has_originatingstationid();
  void set_has_sequencenumber();
  void clear_has_sequencenumber();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 originatingstationid_;
  ::google::protobuf::uint32 sequencenumber_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Altitude : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Altitude) */ {
 public:
  Altitude();
  virtual ~Altitude();

  Altitude(const Altitude& from);

  inline Altitude& operator=(const Altitude& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Altitude(Altitude&& from) noexcept
    : Altitude() {
    *this = ::std::move(from);
  }

  inline Altitude& operator=(Altitude&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Altitude& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Altitude* internal_default_instance() {
    return reinterpret_cast<const Altitude*>(
               &_Altitude_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Altitude* other);
  friend void swap(Altitude& a, Altitude& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Altitude* New() const final {
    return CreateMaybeMessage<Altitude>(NULL);
  }

  Altitude* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Altitude>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Altitude& from);
  void MergeFrom(const Altitude& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Altitude* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // required uint32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 confidence() const;
  void set_confidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Altitude)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::uint32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CartesianAngle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CartesianAngle) */ {
 public:
  CartesianAngle();
  virtual ~CartesianAngle();

  CartesianAngle(const CartesianAngle& from);

  inline CartesianAngle& operator=(const CartesianAngle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianAngle(CartesianAngle&& from) noexcept
    : CartesianAngle() {
    *this = ::std::move(from);
  }

  inline CartesianAngle& operator=(CartesianAngle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianAngle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianAngle* internal_default_instance() {
    return reinterpret_cast<const CartesianAngle*>(
               &_CartesianAngle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CartesianAngle* other);
  friend void swap(CartesianAngle& a, CartesianAngle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianAngle* New() const final {
    return CreateMaybeMessage<CartesianAngle>(NULL);
  }

  CartesianAngle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CartesianAngle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CartesianAngle& from);
  void MergeFrom(const CartesianAngle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianAngle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 cartesian_value = 1;
  bool has_cartesian_value() const;
  void clear_cartesian_value();
  static const int kCartesianValueFieldNumber = 1;
  ::google::protobuf::int64 cartesian_value() const;
  void set_cartesian_value(::google::protobuf::int64 value);

  // required int64 cartesian_angle_confidence = 2;
  bool has_cartesian_angle_confidence() const;
  void clear_cartesian_angle_confidence();
  static const int kCartesianAngleConfidenceFieldNumber = 2;
  ::google::protobuf::int64 cartesian_angle_confidence() const;
  void set_cartesian_angle_confidence(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:CartesianAngle)
 private:
  void set_has_cartesian_value();
  void clear_has_cartesian_value();
  void set_has_cartesian_angle_confidence();
  void clear_has_cartesian_angle_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 cartesian_value_;
  ::google::protobuf::int64 cartesian_angle_confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CartesianAngularVelocityComponent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CartesianAngularVelocityComponent) */ {
 public:
  CartesianAngularVelocityComponent();
  virtual ~CartesianAngularVelocityComponent();

  CartesianAngularVelocityComponent(const CartesianAngularVelocityComponent& from);

  inline CartesianAngularVelocityComponent& operator=(const CartesianAngularVelocityComponent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianAngularVelocityComponent(CartesianAngularVelocityComponent&& from) noexcept
    : CartesianAngularVelocityComponent() {
    *this = ::std::move(from);
  }

  inline CartesianAngularVelocityComponent& operator=(CartesianAngularVelocityComponent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianAngularVelocityComponent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianAngularVelocityComponent* internal_default_instance() {
    return reinterpret_cast<const CartesianAngularVelocityComponent*>(
               &_CartesianAngularVelocityComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CartesianAngularVelocityComponent* other);
  friend void swap(CartesianAngularVelocityComponent& a, CartesianAngularVelocityComponent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianAngularVelocityComponent* New() const final {
    return CreateMaybeMessage<CartesianAngularVelocityComponent>(NULL);
  }

  CartesianAngularVelocityComponent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CartesianAngularVelocityComponent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CartesianAngularVelocityComponent& from);
  void MergeFrom(const CartesianAngularVelocityComponent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianAngularVelocityComponent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // required .AngularSpeedConfidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::AngularSpeedConfidence confidence() const;
  void set_confidence(::AngularSpeedConfidence value);

  // @@protoc_insertion_point(class_scope:CartesianAngularVelocityComponent)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  int confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CartesianPosition3d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CartesianPosition3d) */ {
 public:
  CartesianPosition3d();
  virtual ~CartesianPosition3d();

  CartesianPosition3d(const CartesianPosition3d& from);

  inline CartesianPosition3d& operator=(const CartesianPosition3d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianPosition3d(CartesianPosition3d&& from) noexcept
    : CartesianPosition3d() {
    *this = ::std::move(from);
  }

  inline CartesianPosition3d& operator=(CartesianPosition3d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianPosition3d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianPosition3d* internal_default_instance() {
    return reinterpret_cast<const CartesianPosition3d*>(
               &_CartesianPosition3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CartesianPosition3d* other);
  friend void swap(CartesianPosition3d& a, CartesianPosition3d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianPosition3d* New() const final {
    return CreateMaybeMessage<CartesianPosition3d>(NULL);
  }

  CartesianPosition3d* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CartesianPosition3d>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CartesianPosition3d& from);
  void MergeFrom(const CartesianPosition3d& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianPosition3d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x_cord = 1;
  bool has_x_cord() const;
  void clear_x_cord();
  static const int kXCordFieldNumber = 1;
  ::google::protobuf::int32 x_cord() const;
  void set_x_cord(::google::protobuf::int32 value);

  // required int32 y_cord = 2;
  bool has_y_cord() const;
  void clear_y_cord();
  static const int kYCordFieldNumber = 2;
  ::google::protobuf::int32 y_cord() const;
  void set_y_cord(::google::protobuf::int32 value);

  // required int32 z_cord = 3;
  bool has_z_cord() const;
  void clear_z_cord();
  static const int kZCordFieldNumber = 3;
  ::google::protobuf::int32 z_cord() const;
  void set_z_cord(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CartesianPosition3d)
 private:
  void set_has_x_cord();
  void clear_has_x_cord();
  void set_has_y_cord();
  void clear_has_y_cord();
  void set_has_z_cord();
  void clear_has_z_cord();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_cord_;
  ::google::protobuf::int32 y_cord_;
  ::google::protobuf::int32 z_cord_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CartesianCoordinateWithConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CartesianCoordinateWithConfidence) */ {
 public:
  CartesianCoordinateWithConfidence();
  virtual ~CartesianCoordinateWithConfidence();

  CartesianCoordinateWithConfidence(const CartesianCoordinateWithConfidence& from);

  inline CartesianCoordinateWithConfidence& operator=(const CartesianCoordinateWithConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianCoordinateWithConfidence(CartesianCoordinateWithConfidence&& from) noexcept
    : CartesianCoordinateWithConfidence() {
    *this = ::std::move(from);
  }

  inline CartesianCoordinateWithConfidence& operator=(CartesianCoordinateWithConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianCoordinateWithConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianCoordinateWithConfidence* internal_default_instance() {
    return reinterpret_cast<const CartesianCoordinateWithConfidence*>(
               &_CartesianCoordinateWithConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CartesianCoordinateWithConfidence* other);
  friend void swap(CartesianCoordinateWithConfidence& a, CartesianCoordinateWithConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianCoordinateWithConfidence* New() const final {
    return CreateMaybeMessage<CartesianCoordinateWithConfidence>(NULL);
  }

  CartesianCoordinateWithConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CartesianCoordinateWithConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CartesianCoordinateWithConfidence& from);
  void MergeFrom(const CartesianCoordinateWithConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianCoordinateWithConfidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // required uint32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 confidence() const;
  void set_confidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CartesianCoordinateWithConfidence)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::uint32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CartesianPosition3dWithConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CartesianPosition3dWithConfidence) */ {
 public:
  CartesianPosition3dWithConfidence();
  virtual ~CartesianPosition3dWithConfidence();

  CartesianPosition3dWithConfidence(const CartesianPosition3dWithConfidence& from);

  inline CartesianPosition3dWithConfidence& operator=(const CartesianPosition3dWithConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CartesianPosition3dWithConfidence(CartesianPosition3dWithConfidence&& from) noexcept
    : CartesianPosition3dWithConfidence() {
    *this = ::std::move(from);
  }

  inline CartesianPosition3dWithConfidence& operator=(CartesianPosition3dWithConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianPosition3dWithConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CartesianPosition3dWithConfidence* internal_default_instance() {
    return reinterpret_cast<const CartesianPosition3dWithConfidence*>(
               &_CartesianPosition3dWithConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CartesianPosition3dWithConfidence* other);
  friend void swap(CartesianPosition3dWithConfidence& a, CartesianPosition3dWithConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CartesianPosition3dWithConfidence* New() const final {
    return CreateMaybeMessage<CartesianPosition3dWithConfidence>(NULL);
  }

  CartesianPosition3dWithConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CartesianPosition3dWithConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CartesianPosition3dWithConfidence& from);
  void MergeFrom(const CartesianPosition3dWithConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CartesianPosition3dWithConfidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CartesianCoordinateWithConfidence x_cord = 1;
  bool has_x_cord() const;
  void clear_x_cord();
  static const int kXCordFieldNumber = 1;
  private:
  const ::CartesianCoordinateWithConfidence& _internal_x_cord() const;
  public:
  const ::CartesianCoordinateWithConfidence& x_cord() const;
  ::CartesianCoordinateWithConfidence* release_x_cord();
  ::CartesianCoordinateWithConfidence* mutable_x_cord();
  void set_allocated_x_cord(::CartesianCoordinateWithConfidence* x_cord);

  // required .CartesianCoordinateWithConfidence y_cord = 2;
  bool has_y_cord() const;
  void clear_y_cord();
  static const int kYCordFieldNumber = 2;
  private:
  const ::CartesianCoordinateWithConfidence& _internal_y_cord() const;
  public:
  const ::CartesianCoordinateWithConfidence& y_cord() const;
  ::CartesianCoordinateWithConfidence* release_y_cord();
  ::CartesianCoordinateWithConfidence* mutable_y_cord();
  void set_allocated_y_cord(::CartesianCoordinateWithConfidence* y_cord);

  // optional .CartesianCoordinateWithConfidence z_cord = 3;
  bool has_z_cord() const;
  void clear_z_cord();
  static const int kZCordFieldNumber = 3;
  private:
  const ::CartesianCoordinateWithConfidence& _internal_z_cord() const;
  public:
  const ::CartesianCoordinateWithConfidence& z_cord() const;
  ::CartesianCoordinateWithConfidence* release_z_cord();
  ::CartesianCoordinateWithConfidence* mutable_z_cord();
  void set_allocated_z_cord(::CartesianCoordinateWithConfidence* z_cord);

  // @@protoc_insertion_point(class_scope:CartesianPosition3dWithConfidence)
 private:
  void set_has_x_cord();
  void clear_has_x_cord();
  void set_has_y_cord();
  void clear_has_y_cord();
  void set_has_z_cord();
  void clear_has_z_cord();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CartesianCoordinateWithConfidence* x_cord_;
  ::CartesianCoordinateWithConfidence* y_cord_;
  ::CartesianCoordinateWithConfidence* z_cord_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CircularShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CircularShape) */ {
 public:
  CircularShape();
  virtual ~CircularShape();

  CircularShape(const CircularShape& from);

  inline CircularShape& operator=(const CircularShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CircularShape(CircularShape&& from) noexcept
    : CircularShape() {
    *this = ::std::move(from);
  }

  inline CircularShape& operator=(CircularShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CircularShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CircularShape* internal_default_instance() {
    return reinterpret_cast<const CircularShape*>(
               &_CircularShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CircularShape* other);
  friend void swap(CircularShape& a, CircularShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CircularShape* New() const final {
    return CreateMaybeMessage<CircularShape>(NULL);
  }

  CircularShape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CircularShape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CircularShape& from);
  void MergeFrom(const CircularShape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircularShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CartesianPosition3d shapeRefPoint = 1;
  bool has_shaperefpoint() const;
  void clear_shaperefpoint();
  static const int kShapeRefPointFieldNumber = 1;
  private:
  const ::CartesianPosition3d& _internal_shaperefpoint() const;
  public:
  const ::CartesianPosition3d& shaperefpoint() const;
  ::CartesianPosition3d* release_shaperefpoint();
  ::CartesianPosition3d* mutable_shaperefpoint();
  void set_allocated_shaperefpoint(::CartesianPosition3d* shaperefpoint);

  // required int32 radius = 2;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  ::google::protobuf::int32 radius() const;
  void set_radius(::google::protobuf::int32 value);

  // optional uint32 height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CircularShape)
 private:
  void set_has_shaperefpoint();
  void clear_has_shaperefpoint();
  void set_has_radius();
  void clear_has_radius();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CartesianPosition3d* shaperefpoint_;
  ::google::protobuf::int32 radius_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClosedLanes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ClosedLanes) */ {
 public:
  ClosedLanes();
  virtual ~ClosedLanes();

  ClosedLanes(const ClosedLanes& from);

  inline ClosedLanes& operator=(const ClosedLanes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClosedLanes(ClosedLanes&& from) noexcept
    : ClosedLanes() {
    *this = ::std::move(from);
  }

  inline ClosedLanes& operator=(ClosedLanes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClosedLanes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClosedLanes* internal_default_instance() {
    return reinterpret_cast<const ClosedLanes*>(
               &_ClosedLanes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ClosedLanes* other);
  friend void swap(ClosedLanes& a, ClosedLanes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClosedLanes* New() const final {
    return CreateMaybeMessage<ClosedLanes>(NULL);
  }

  ClosedLanes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClosedLanes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClosedLanes& from);
  void MergeFrom(const ClosedLanes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClosedLanes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .HardShoulderStatus innerhardShoulderStatus = 1;
  bool has_innerhardshoulderstatus() const;
  void clear_innerhardshoulderstatus();
  static const int kInnerhardShoulderStatusFieldNumber = 1;
  ::HardShoulderStatus innerhardshoulderstatus() const;
  void set_innerhardshoulderstatus(::HardShoulderStatus value);

  // optional .HardShoulderStatus outerhardShoulderStatus = 2;
  bool has_outerhardshoulderstatus() const;
  void clear_outerhardshoulderstatus();
  static const int kOuterhardShoulderStatusFieldNumber = 2;
  ::HardShoulderStatus outerhardshoulderstatus() const;
  void set_outerhardshoulderstatus(::HardShoulderStatus value);

  // optional uint32 drivingLaneStatus = 3;
  bool has_drivinglanestatus() const;
  void clear_drivinglanestatus();
  static const int kDrivingLaneStatusFieldNumber = 3;
  ::google::protobuf::uint32 drivinglanestatus() const;
  void set_drivinglanestatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ClosedLanes)
 private:
  void set_has_innerhardshoulderstatus();
  void clear_has_innerhardshoulderstatus();
  void set_has_outerhardshoulderstatus();
  void clear_has_outerhardshoulderstatus();
  void set_has_drivinglanestatus();
  void clear_has_drivinglanestatus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int innerhardshoulderstatus_;
  int outerhardshoulderstatus_;
  ::google::protobuf::uint32 drivinglanestatus_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CorrelationColumn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CorrelationColumn) */ {
 public:
  CorrelationColumn();
  virtual ~CorrelationColumn();

  CorrelationColumn(const CorrelationColumn& from);

  inline CorrelationColumn& operator=(const CorrelationColumn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CorrelationColumn(CorrelationColumn&& from) noexcept
    : CorrelationColumn() {
    *this = ::std::move(from);
  }

  inline CorrelationColumn& operator=(CorrelationColumn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CorrelationColumn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CorrelationColumn* internal_default_instance() {
    return reinterpret_cast<const CorrelationColumn*>(
               &_CorrelationColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CorrelationColumn* other);
  friend void swap(CorrelationColumn& a, CorrelationColumn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CorrelationColumn* New() const final {
    return CreateMaybeMessage<CorrelationColumn>(NULL);
  }

  CorrelationColumn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CorrelationColumn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CorrelationColumn& from);
  void MergeFrom(const CorrelationColumn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CorrelationColumn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value(int index) const;
  void set_value(int index, ::google::protobuf::int32 value);
  void add_value(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:CorrelationColumn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > value_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Curvature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Curvature) */ {
 public:
  Curvature();
  virtual ~Curvature();

  Curvature(const Curvature& from);

  inline Curvature& operator=(const Curvature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Curvature(Curvature&& from) noexcept
    : Curvature() {
    *this = ::std::move(from);
  }

  inline Curvature& operator=(Curvature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Curvature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Curvature* internal_default_instance() {
    return reinterpret_cast<const Curvature*>(
               &_Curvature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Curvature* other);
  friend void swap(Curvature& a, Curvature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Curvature* New() const final {
    return CreateMaybeMessage<Curvature>(NULL);
  }

  Curvature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Curvature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Curvature& from);
  void MergeFrom(const Curvature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Curvature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // optional int32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::int32 confidence() const;
  void set_confidence(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Curvature)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::int32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CauseCode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CauseCode) */ {
 public:
  CauseCode();
  virtual ~CauseCode();

  CauseCode(const CauseCode& from);

  inline CauseCode& operator=(const CauseCode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CauseCode(CauseCode&& from) noexcept
    : CauseCode() {
    *this = ::std::move(from);
  }

  inline CauseCode& operator=(CauseCode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CauseCode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CauseCode* internal_default_instance() {
    return reinterpret_cast<const CauseCode*>(
               &_CauseCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CauseCode* other);
  friend void swap(CauseCode& a, CauseCode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CauseCode* New() const final {
    return CreateMaybeMessage<CauseCode>(NULL);
  }

  CauseCode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CauseCode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CauseCode& from);
  void MergeFrom(const CauseCode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CauseCode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 subCauseCode = 2;
  bool has_subcausecode() const;
  void clear_subcausecode();
  static const int kSubCauseCodeFieldNumber = 2;
  ::google::protobuf::uint32 subcausecode() const;
  void set_subcausecode(::google::protobuf::uint32 value);

  // required .CauseCodeType causeCode = 1;
  bool has_causecode() const;
  void clear_causecode();
  static const int kCauseCodeFieldNumber = 1;
  ::CauseCodeType causecode() const;
  void set_causecode(::CauseCodeType value);

  // @@protoc_insertion_point(class_scope:CauseCode)
 private:
  void set_has_causecode();
  void clear_has_causecode();
  void set_has_subcausecode();
  void clear_has_subcausecode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 subcausecode_;
  int causecode_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DangerousGoodsExtended : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DangerousGoodsExtended) */ {
 public:
  DangerousGoodsExtended();
  virtual ~DangerousGoodsExtended();

  DangerousGoodsExtended(const DangerousGoodsExtended& from);

  inline DangerousGoodsExtended& operator=(const DangerousGoodsExtended& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DangerousGoodsExtended(DangerousGoodsExtended&& from) noexcept
    : DangerousGoodsExtended() {
    *this = ::std::move(from);
  }

  inline DangerousGoodsExtended& operator=(DangerousGoodsExtended&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DangerousGoodsExtended& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DangerousGoodsExtended* internal_default_instance() {
    return reinterpret_cast<const DangerousGoodsExtended*>(
               &_DangerousGoodsExtended_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(DangerousGoodsExtended* other);
  friend void swap(DangerousGoodsExtended& a, DangerousGoodsExtended& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DangerousGoodsExtended* New() const final {
    return CreateMaybeMessage<DangerousGoodsExtended>(NULL);
  }

  DangerousGoodsExtended* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DangerousGoodsExtended>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DangerousGoodsExtended& from);
  void MergeFrom(const DangerousGoodsExtended& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DangerousGoodsExtended* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string emergencyActionCode = 6;
  bool has_emergencyactioncode() const;
  void clear_emergencyactioncode();
  static const int kEmergencyActionCodeFieldNumber = 6;
  const ::std::string& emergencyactioncode() const;
  void set_emergencyactioncode(const ::std::string& value);
  #if LANG_CXX11
  void set_emergencyactioncode(::std::string&& value);
  #endif
  void set_emergencyactioncode(const char* value);
  void set_emergencyactioncode(const char* value, size_t size);
  ::std::string* mutable_emergencyactioncode();
  ::std::string* release_emergencyactioncode();
  void set_allocated_emergencyactioncode(::std::string* emergencyactioncode);

  // optional string phoneNumber = 7;
  bool has_phonenumber() const;
  void clear_phonenumber();
  static const int kPhoneNumberFieldNumber = 7;
  const ::std::string& phonenumber() const;
  void set_phonenumber(const ::std::string& value);
  #if LANG_CXX11
  void set_phonenumber(::std::string&& value);
  #endif
  void set_phonenumber(const char* value);
  void set_phonenumber(const char* value, size_t size);
  ::std::string* mutable_phonenumber();
  ::std::string* release_phonenumber();
  void set_allocated_phonenumber(::std::string* phonenumber);

  // optional string companyName = 8;
  bool has_companyname() const;
  void clear_companyname();
  static const int kCompanyNameFieldNumber = 8;
  const ::std::string& companyname() const;
  void set_companyname(const ::std::string& value);
  #if LANG_CXX11
  void set_companyname(::std::string&& value);
  #endif
  void set_companyname(const char* value);
  void set_companyname(const char* value, size_t size);
  ::std::string* mutable_companyname();
  ::std::string* release_companyname();
  void set_allocated_companyname(::std::string* companyname);

  // required .DangerousGoodsBasic dangerousGoodsType = 1;
  bool has_dangerousgoodstype() const;
  void clear_dangerousgoodstype();
  static const int kDangerousGoodsTypeFieldNumber = 1;
  ::DangerousGoodsBasic dangerousgoodstype() const;
  void set_dangerousgoodstype(::DangerousGoodsBasic value);

  // required uint32 unNumber = 2;
  bool has_unnumber() const;
  void clear_unnumber();
  static const int kUnNumberFieldNumber = 2;
  ::google::protobuf::uint32 unnumber() const;
  void set_unnumber(::google::protobuf::uint32 value);

  // required bool elevatedTemperature = 3;
  bool has_elevatedtemperature() const;
  void clear_elevatedtemperature();
  static const int kElevatedTemperatureFieldNumber = 3;
  bool elevatedtemperature() const;
  void set_elevatedtemperature(bool value);

  // required bool tunnelsRestricted = 4;
  bool has_tunnelsrestricted() const;
  void clear_tunnelsrestricted();
  static const int kTunnelsRestrictedFieldNumber = 4;
  bool tunnelsrestricted() const;
  void set_tunnelsrestricted(bool value);

  // required bool limitedQuantity = 5;
  bool has_limitedquantity() const;
  void clear_limitedquantity();
  static const int kLimitedQuantityFieldNumber = 5;
  bool limitedquantity() const;
  void set_limitedquantity(bool value);

  // @@protoc_insertion_point(class_scope:DangerousGoodsExtended)
 private:
  void set_has_dangerousgoodstype();
  void clear_has_dangerousgoodstype();
  void set_has_unnumber();
  void clear_has_unnumber();
  void set_has_elevatedtemperature();
  void clear_has_elevatedtemperature();
  void set_has_tunnelsrestricted();
  void clear_has_tunnelsrestricted();
  void set_has_limitedquantity();
  void clear_has_limitedquantity();
  void set_has_emergencyactioncode();
  void clear_has_emergencyactioncode();
  void set_has_phonenumber();
  void clear_has_phonenumber();
  void set_has_companyname();
  void clear_has_companyname();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr emergencyactioncode_;
  ::google::protobuf::internal::ArenaStringPtr phonenumber_;
  ::google::protobuf::internal::ArenaStringPtr companyname_;
  int dangerousgoodstype_;
  ::google::protobuf::uint32 unnumber_;
  bool elevatedtemperature_;
  bool tunnelsrestricted_;
  bool limitedquantity_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeltaReferencePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DeltaReferencePosition) */ {
 public:
  DeltaReferencePosition();
  virtual ~DeltaReferencePosition();

  DeltaReferencePosition(const DeltaReferencePosition& from);

  inline DeltaReferencePosition& operator=(const DeltaReferencePosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeltaReferencePosition(DeltaReferencePosition&& from) noexcept
    : DeltaReferencePosition() {
    *this = ::std::move(from);
  }

  inline DeltaReferencePosition& operator=(DeltaReferencePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeltaReferencePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeltaReferencePosition* internal_default_instance() {
    return reinterpret_cast<const DeltaReferencePosition*>(
               &_DeltaReferencePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(DeltaReferencePosition* other);
  friend void swap(DeltaReferencePosition& a, DeltaReferencePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeltaReferencePosition* New() const final {
    return CreateMaybeMessage<DeltaReferencePosition>(NULL);
  }

  DeltaReferencePosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeltaReferencePosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeltaReferencePosition& from);
  void MergeFrom(const DeltaReferencePosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeltaReferencePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 deltaLatitude = 1;
  bool has_deltalatitude() const;
  void clear_deltalatitude();
  static const int kDeltaLatitudeFieldNumber = 1;
  ::google::protobuf::int32 deltalatitude() const;
  void set_deltalatitude(::google::protobuf::int32 value);

  // required int32 deltaLongitude = 2;
  bool has_deltalongitude() const;
  void clear_deltalongitude();
  static const int kDeltaLongitudeFieldNumber = 2;
  ::google::protobuf::int32 deltalongitude() const;
  void set_deltalongitude(::google::protobuf::int32 value);

  // required int32 deltaAltitude = 3;
  bool has_deltaaltitude() const;
  void clear_deltaaltitude();
  static const int kDeltaAltitudeFieldNumber = 3;
  ::google::protobuf::int32 deltaaltitude() const;
  void set_deltaaltitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DeltaReferencePosition)
 private:
  void set_has_deltalatitude();
  void clear_has_deltalatitude();
  void set_has_deltalongitude();
  void clear_has_deltalongitude();
  void set_has_deltaaltitude();
  void clear_has_deltaaltitude();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 deltalatitude_;
  ::google::protobuf::int32 deltalongitude_;
  ::google::protobuf::int32 deltaaltitude_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnergyStorageType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EnergyStorageType) */ {
 public:
  EnergyStorageType();
  virtual ~EnergyStorageType();

  EnergyStorageType(const EnergyStorageType& from);

  inline EnergyStorageType& operator=(const EnergyStorageType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnergyStorageType(EnergyStorageType&& from) noexcept
    : EnergyStorageType() {
    *this = ::std::move(from);
  }

  inline EnergyStorageType& operator=(EnergyStorageType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnergyStorageType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnergyStorageType* internal_default_instance() {
    return reinterpret_cast<const EnergyStorageType*>(
               &_EnergyStorageType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(EnergyStorageType* other);
  friend void swap(EnergyStorageType& a, EnergyStorageType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnergyStorageType* New() const final {
    return CreateMaybeMessage<EnergyStorageType>(NULL);
  }

  EnergyStorageType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnergyStorageType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnergyStorageType& from);
  void MergeFrom(const EnergyStorageType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnergyStorageType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool hydrogenStorage = 1;
  bool has_hydrogenstorage() const;
  void clear_hydrogenstorage();
  static const int kHydrogenStorageFieldNumber = 1;
  bool hydrogenstorage() const;
  void set_hydrogenstorage(bool value);

  // required bool electricEnergyStorage = 2;
  bool has_electricenergystorage() const;
  void clear_electricenergystorage();
  static const int kElectricEnergyStorageFieldNumber = 2;
  bool electricenergystorage() const;
  void set_electricenergystorage(bool value);

  // required bool liquidPropaneGas = 3;
  bool has_liquidpropanegas() const;
  void clear_liquidpropanegas();
  static const int kLiquidPropaneGasFieldNumber = 3;
  bool liquidpropanegas() const;
  void set_liquidpropanegas(bool value);

  // required bool compressedNaturalGas = 4;
  bool has_compressednaturalgas() const;
  void clear_compressednaturalgas();
  static const int kCompressedNaturalGasFieldNumber = 4;
  bool compressednaturalgas() const;
  void set_compressednaturalgas(bool value);

  // required bool diesel = 5;
  bool has_diesel() const;
  void clear_diesel();
  static const int kDieselFieldNumber = 5;
  bool diesel() const;
  void set_diesel(bool value);

  // required bool gasoline = 6;
  bool has_gasoline() const;
  void clear_gasoline();
  static const int kGasolineFieldNumber = 6;
  bool gasoline() const;
  void set_gasoline(bool value);

  // required bool ammonia = 7;
  bool has_ammonia() const;
  void clear_ammonia();
  static const int kAmmoniaFieldNumber = 7;
  bool ammonia() const;
  void set_ammonia(bool value);

  // @@protoc_insertion_point(class_scope:EnergyStorageType)
 private:
  void set_has_hydrogenstorage();
  void clear_has_hydrogenstorage();
  void set_has_electricenergystorage();
  void clear_has_electricenergystorage();
  void set_has_liquidpropanegas();
  void clear_has_liquidpropanegas();
  void set_has_compressednaturalgas();
  void clear_has_compressednaturalgas();
  void set_has_diesel();
  void clear_has_diesel();
  void set_has_gasoline();
  void clear_has_gasoline();
  void set_has_ammonia();
  void clear_has_ammonia();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool hydrogenstorage_;
  bool electricenergystorage_;
  bool liquidpropanegas_;
  bool compressednaturalgas_;
  bool diesel_;
  bool gasoline_;
  bool ammonia_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EllipticalShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EllipticalShape) */ {
 public:
  EllipticalShape();
  virtual ~EllipticalShape();

  EllipticalShape(const EllipticalShape& from);

  inline EllipticalShape& operator=(const EllipticalShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EllipticalShape(EllipticalShape&& from) noexcept
    : EllipticalShape() {
    *this = ::std::move(from);
  }

  inline EllipticalShape& operator=(EllipticalShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EllipticalShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EllipticalShape* internal_default_instance() {
    return reinterpret_cast<const EllipticalShape*>(
               &_EllipticalShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(EllipticalShape* other);
  friend void swap(EllipticalShape& a, EllipticalShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EllipticalShape* New() const final {
    return CreateMaybeMessage<EllipticalShape>(NULL);
  }

  EllipticalShape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EllipticalShape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EllipticalShape& from);
  void MergeFrom(const EllipticalShape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EllipticalShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CartesianPosition3d shapeReferencePoint = 1;
  bool has_shapereferencepoint() const;
  void clear_shapereferencepoint();
  static const int kShapeReferencePointFieldNumber = 1;
  private:
  const ::CartesianPosition3d& _internal_shapereferencepoint() const;
  public:
  const ::CartesianPosition3d& shapereferencepoint() const;
  ::CartesianPosition3d* release_shapereferencepoint();
  ::CartesianPosition3d* mutable_shapereferencepoint();
  void set_allocated_shapereferencepoint(::CartesianPosition3d* shapereferencepoint);

  // required uint32 semiMajorAxisLength = 2;
  bool has_semimajoraxislength() const;
  void clear_semimajoraxislength();
  static const int kSemiMajorAxisLengthFieldNumber = 2;
  ::google::protobuf::uint32 semimajoraxislength() const;
  void set_semimajoraxislength(::google::protobuf::uint32 value);

  // required uint32 semiMinorAxisLength = 3;
  bool has_semiminoraxislength() const;
  void clear_semiminoraxislength();
  static const int kSemiMinorAxisLengthFieldNumber = 3;
  ::google::protobuf::uint32 semiminoraxislength() const;
  void set_semiminoraxislength(::google::protobuf::uint32 value);

  // optional uint32 orientation = 4;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  ::google::protobuf::uint32 orientation() const;
  void set_orientation(::google::protobuf::uint32 value);

  // optional uint32 height = 5;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EllipticalShape)
 private:
  void set_has_shapereferencepoint();
  void clear_has_shapereferencepoint();
  void set_has_semimajoraxislength();
  void clear_has_semimajoraxislength();
  void set_has_semiminoraxislength();
  void clear_has_semiminoraxislength();
  void set_has_orientation();
  void clear_has_orientation();
  void set_has_height();
  void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CartesianPosition3d* shapereferencepoint_;
  ::google::protobuf::uint32 semimajoraxislength_;
  ::google::protobuf::uint32 semiminoraxislength_;
  ::google::protobuf::uint32 orientation_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EulerAnglesWithConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EulerAnglesWithConfidence) */ {
 public:
  EulerAnglesWithConfidence();
  virtual ~EulerAnglesWithConfidence();

  EulerAnglesWithConfidence(const EulerAnglesWithConfidence& from);

  inline EulerAnglesWithConfidence& operator=(const EulerAnglesWithConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EulerAnglesWithConfidence(EulerAnglesWithConfidence&& from) noexcept
    : EulerAnglesWithConfidence() {
    *this = ::std::move(from);
  }

  inline EulerAnglesWithConfidence& operator=(EulerAnglesWithConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EulerAnglesWithConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EulerAnglesWithConfidence* internal_default_instance() {
    return reinterpret_cast<const EulerAnglesWithConfidence*>(
               &_EulerAnglesWithConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(EulerAnglesWithConfidence* other);
  friend void swap(EulerAnglesWithConfidence& a, EulerAnglesWithConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EulerAnglesWithConfidence* New() const final {
    return CreateMaybeMessage<EulerAnglesWithConfidence>(NULL);
  }

  EulerAnglesWithConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EulerAnglesWithConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EulerAnglesWithConfidence& from);
  void MergeFrom(const EulerAnglesWithConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EulerAnglesWithConfidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CartesianAngle zAngle = 1;
  bool has_zangle() const;
  void clear_zangle();
  static const int kZAngleFieldNumber = 1;
  private:
  const ::CartesianAngle& _internal_zangle() const;
  public:
  const ::CartesianAngle& zangle() const;
  ::CartesianAngle* release_zangle();
  ::CartesianAngle* mutable_zangle();
  void set_allocated_zangle(::CartesianAngle* zangle);

  // optional .CartesianAngle yAngle = 2;
  bool has_yangle() const;
  void clear_yangle();
  static const int kYAngleFieldNumber = 2;
  private:
  const ::CartesianAngle& _internal_yangle() const;
  public:
  const ::CartesianAngle& yangle() const;
  ::CartesianAngle* release_yangle();
  ::CartesianAngle* mutable_yangle();
  void set_allocated_yangle(::CartesianAngle* yangle);

  // optional .CartesianAngle xAngle = 3;
  bool has_xangle() const;
  void clear_xangle();
  static const int kXAngleFieldNumber = 3;
  private:
  const ::CartesianAngle& _internal_xangle() const;
  public:
  const ::CartesianAngle& xangle() const;
  ::CartesianAngle* release_xangle();
  ::CartesianAngle* mutable_xangle();
  void set_allocated_xangle(::CartesianAngle* xangle);

  // @@protoc_insertion_point(class_scope:EulerAnglesWithConfidence)
 private:
  void set_has_zangle();
  void clear_has_zangle();
  void set_has_yangle();
  void clear_has_yangle();
  void set_has_xangle();
  void clear_has_xangle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CartesianAngle* zangle_;
  ::CartesianAngle* yangle_;
  ::CartesianAngle* xangle_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EventHistory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EventHistory) */ {
 public:
  EventHistory();
  virtual ~EventHistory();

  EventHistory(const EventHistory& from);

  inline EventHistory& operator=(const EventHistory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventHistory(EventHistory&& from) noexcept
    : EventHistory() {
    *this = ::std::move(from);
  }

  inline EventHistory& operator=(EventHistory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventHistory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventHistory* internal_default_instance() {
    return reinterpret_cast<const EventHistory*>(
               &_EventHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(EventHistory* other);
  friend void swap(EventHistory& a, EventHistory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventHistory* New() const final {
    return CreateMaybeMessage<EventHistory>(NULL);
  }

  EventHistory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventHistory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventHistory& from);
  void MergeFrom(const EventHistory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventHistory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .EventPoint event_points = 1;
  int event_points_size() const;
  void clear_event_points();
  static const int kEventPointsFieldNumber = 1;
  ::EventPoint* mutable_event_points(int index);
  ::google::protobuf::RepeatedPtrField< ::EventPoint >*
      mutable_event_points();
  const ::EventPoint& event_points(int index) const;
  ::EventPoint* add_event_points();
  const ::google::protobuf::RepeatedPtrField< ::EventPoint >&
      event_points() const;

  // @@protoc_insertion_point(class_scope:EventHistory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::EventPoint > event_points_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EventPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EventPoint) */ {
 public:
  EventPoint();
  virtual ~EventPoint();

  EventPoint(const EventPoint& from);

  inline EventPoint& operator=(const EventPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventPoint(EventPoint&& from) noexcept
    : EventPoint() {
    *this = ::std::move(from);
  }

  inline EventPoint& operator=(EventPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventPoint* internal_default_instance() {
    return reinterpret_cast<const EventPoint*>(
               &_EventPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(EventPoint* other);
  friend void swap(EventPoint& a, EventPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventPoint* New() const final {
    return CreateMaybeMessage<EventPoint>(NULL);
  }

  EventPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventPoint& from);
  void MergeFrom(const EventPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DeltaReferencePosition eventPosition = 1;
  bool has_eventposition() const;
  void clear_eventposition();
  static const int kEventPositionFieldNumber = 1;
  private:
  const ::DeltaReferencePosition& _internal_eventposition() const;
  public:
  const ::DeltaReferencePosition& eventposition() const;
  ::DeltaReferencePosition* release_eventposition();
  ::DeltaReferencePosition* mutable_eventposition();
  void set_allocated_eventposition(::DeltaReferencePosition* eventposition);

  // optional uint32 eventDeltaTime = 2;
  bool has_eventdeltatime() const;
  void clear_eventdeltatime();
  static const int kEventDeltaTimeFieldNumber = 2;
  ::google::protobuf::uint32 eventdeltatime() const;
  void set_eventdeltatime(::google::protobuf::uint32 value);

  // required uint32 informationQuality = 3;
  bool has_informationquality() const;
  void clear_informationquality();
  static const int kInformationQualityFieldNumber = 3;
  ::google::protobuf::uint32 informationquality() const;
  void set_informationquality(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EventPoint)
 private:
  void set_has_eventposition();
  void clear_has_eventposition();
  void set_has_eventdeltatime();
  void clear_has_eventdeltatime();
  void set_has_informationquality();
  void clear_has_informationquality();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::DeltaReferencePosition* eventposition_;
  ::google::protobuf::uint32 eventdeltatime_;
  ::google::protobuf::uint32 informationquality_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Heading : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Heading) */ {
 public:
  Heading();
  virtual ~Heading();

  Heading(const Heading& from);

  inline Heading& operator=(const Heading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Heading(Heading&& from) noexcept
    : Heading() {
    *this = ::std::move(from);
  }

  inline Heading& operator=(Heading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Heading* internal_default_instance() {
    return reinterpret_cast<const Heading*>(
               &_Heading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Heading* other);
  friend void swap(Heading& a, Heading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Heading* New() const final {
    return CreateMaybeMessage<Heading>(NULL);
  }

  Heading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Heading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Heading& from);
  void MergeFrom(const Heading& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // required uint32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 confidence() const;
  void set_confidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Heading)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::uint32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IntersectionReferenceID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IntersectionReferenceID) */ {
 public:
  IntersectionReferenceID();
  virtual ~IntersectionReferenceID();

  IntersectionReferenceID(const IntersectionReferenceID& from);

  inline IntersectionReferenceID& operator=(const IntersectionReferenceID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntersectionReferenceID(IntersectionReferenceID&& from) noexcept
    : IntersectionReferenceID() {
    *this = ::std::move(from);
  }

  inline IntersectionReferenceID& operator=(IntersectionReferenceID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntersectionReferenceID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntersectionReferenceID* internal_default_instance() {
    return reinterpret_cast<const IntersectionReferenceID*>(
               &_IntersectionReferenceID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(IntersectionReferenceID* other);
  friend void swap(IntersectionReferenceID& a, IntersectionReferenceID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntersectionReferenceID* New() const final {
    return CreateMaybeMessage<IntersectionReferenceID>(NULL);
  }

  IntersectionReferenceID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IntersectionReferenceID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IntersectionReferenceID& from);
  void MergeFrom(const IntersectionReferenceID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntersectionReferenceID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 region = 1;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 1;
  ::google::protobuf::int64 region() const;
  void set_region(::google::protobuf::int64 value);

  // optional int64 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:IntersectionReferenceID)
 private:
  void set_has_region();
  void clear_has_region();
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 region_;
  ::google::protobuf::int64 id_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ItineraryPath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ItineraryPath) */ {
 public:
  ItineraryPath();
  virtual ~ItineraryPath();

  ItineraryPath(const ItineraryPath& from);

  inline ItineraryPath& operator=(const ItineraryPath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItineraryPath(ItineraryPath&& from) noexcept
    : ItineraryPath() {
    *this = ::std::move(from);
  }

  inline ItineraryPath& operator=(ItineraryPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItineraryPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItineraryPath* internal_default_instance() {
    return reinterpret_cast<const ItineraryPath*>(
               &_ItineraryPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ItineraryPath* other);
  friend void swap(ItineraryPath& a, ItineraryPath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItineraryPath* New() const final {
    return CreateMaybeMessage<ItineraryPath>(NULL);
  }

  ItineraryPath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItineraryPath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItineraryPath& from);
  void MergeFrom(const ItineraryPath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItineraryPath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ReferencePosition path = 1;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  ::ReferencePosition* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::ReferencePosition >*
      mutable_path();
  const ::ReferencePosition& path(int index) const;
  ::ReferencePosition* add_path();
  const ::google::protobuf::RepeatedPtrField< ::ReferencePosition >&
      path() const;

  // @@protoc_insertion_point(class_scope:ItineraryPath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ReferencePosition > path_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LongitudinalAcceleration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LongitudinalAcceleration) */ {
 public:
  LongitudinalAcceleration();
  virtual ~LongitudinalAcceleration();

  LongitudinalAcceleration(const LongitudinalAcceleration& from);

  inline LongitudinalAcceleration& operator=(const LongitudinalAcceleration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LongitudinalAcceleration(LongitudinalAcceleration&& from) noexcept
    : LongitudinalAcceleration() {
    *this = ::std::move(from);
  }

  inline LongitudinalAcceleration& operator=(LongitudinalAcceleration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LongitudinalAcceleration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LongitudinalAcceleration* internal_default_instance() {
    return reinterpret_cast<const LongitudinalAcceleration*>(
               &_LongitudinalAcceleration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(LongitudinalAcceleration* other);
  friend void swap(LongitudinalAcceleration& a, LongitudinalAcceleration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LongitudinalAcceleration* New() const final {
    return CreateMaybeMessage<LongitudinalAcceleration>(NULL);
  }

  LongitudinalAcceleration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LongitudinalAcceleration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LongitudinalAcceleration& from);
  void MergeFrom(const LongitudinalAcceleration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongitudinalAcceleration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // optional int32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::int32 confidence() const;
  void set_confidence(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LongitudinalAcceleration)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::int32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LongitudinalLanePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LongitudinalLanePosition) */ {
 public:
  LongitudinalLanePosition();
  virtual ~LongitudinalLanePosition();

  LongitudinalLanePosition(const LongitudinalLanePosition& from);

  inline LongitudinalLanePosition& operator=(const LongitudinalLanePosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LongitudinalLanePosition(LongitudinalLanePosition&& from) noexcept
    : LongitudinalLanePosition() {
    *this = ::std::move(from);
  }

  inline LongitudinalLanePosition& operator=(LongitudinalLanePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LongitudinalLanePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LongitudinalLanePosition* internal_default_instance() {
    return reinterpret_cast<const LongitudinalLanePosition*>(
               &_LongitudinalLanePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(LongitudinalLanePosition* other);
  friend void swap(LongitudinalLanePosition& a, LongitudinalLanePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LongitudinalLanePosition* New() const final {
    return CreateMaybeMessage<LongitudinalLanePosition>(NULL);
  }

  LongitudinalLanePosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LongitudinalLanePosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LongitudinalLanePosition& from);
  void MergeFrom(const LongitudinalLanePosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongitudinalLanePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 longitudinalLanePositionValue = 1;
  bool has_longitudinallanepositionvalue() const;
  void clear_longitudinallanepositionvalue();
  static const int kLongitudinalLanePositionValueFieldNumber = 1;
  ::google::protobuf::uint32 longitudinallanepositionvalue() const;
  void set_longitudinallanepositionvalue(::google::protobuf::uint32 value);

  // required uint32 longitudinalLanePositionConfidence = 2;
  bool has_longitudinallanepositionconfidence() const;
  void clear_longitudinallanepositionconfidence();
  static const int kLongitudinalLanePositionConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 longitudinallanepositionconfidence() const;
  void set_longitudinallanepositionconfidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LongitudinalLanePosition)
 private:
  void set_has_longitudinallanepositionvalue();
  void clear_has_longitudinallanepositionvalue();
  void set_has_longitudinallanepositionconfidence();
  void clear_has_longitudinallanepositionconfidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 longitudinallanepositionvalue_;
  ::google::protobuf::uint32 longitudinallanepositionconfidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LowerTriangularPositiveSemidefiniteMatrix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LowerTriangularPositiveSemidefiniteMatrix) */ {
 public:
  LowerTriangularPositiveSemidefiniteMatrix();
  virtual ~LowerTriangularPositiveSemidefiniteMatrix();

  LowerTriangularPositiveSemidefiniteMatrix(const LowerTriangularPositiveSemidefiniteMatrix& from);

  inline LowerTriangularPositiveSemidefiniteMatrix& operator=(const LowerTriangularPositiveSemidefiniteMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LowerTriangularPositiveSemidefiniteMatrix(LowerTriangularPositiveSemidefiniteMatrix&& from) noexcept
    : LowerTriangularPositiveSemidefiniteMatrix() {
    *this = ::std::move(from);
  }

  inline LowerTriangularPositiveSemidefiniteMatrix& operator=(LowerTriangularPositiveSemidefiniteMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LowerTriangularPositiveSemidefiniteMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LowerTriangularPositiveSemidefiniteMatrix* internal_default_instance() {
    return reinterpret_cast<const LowerTriangularPositiveSemidefiniteMatrix*>(
               &_LowerTriangularPositiveSemidefiniteMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(LowerTriangularPositiveSemidefiniteMatrix* other);
  friend void swap(LowerTriangularPositiveSemidefiniteMatrix& a, LowerTriangularPositiveSemidefiniteMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LowerTriangularPositiveSemidefiniteMatrix* New() const final {
    return CreateMaybeMessage<LowerTriangularPositiveSemidefiniteMatrix>(NULL);
  }

  LowerTriangularPositiveSemidefiniteMatrix* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LowerTriangularPositiveSemidefiniteMatrix>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LowerTriangularPositiveSemidefiniteMatrix& from);
  void MergeFrom(const LowerTriangularPositiveSemidefiniteMatrix& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LowerTriangularPositiveSemidefiniteMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MatrixIncludedComponents componentsIncludedIntheMatrix = 1;
  bool has_componentsincludedinthematrix() const;
  void clear_componentsincludedinthematrix();
  static const int kComponentsIncludedIntheMatrixFieldNumber = 1;
  private:
  const ::MatrixIncludedComponents& _internal_componentsincludedinthematrix() const;
  public:
  const ::MatrixIncludedComponents& componentsincludedinthematrix() const;
  ::MatrixIncludedComponents* release_componentsincludedinthematrix();
  ::MatrixIncludedComponents* mutable_componentsincludedinthematrix();
  void set_allocated_componentsincludedinthematrix(::MatrixIncludedComponents* componentsincludedinthematrix);

  // required .LowerTriangularPositiveSemidefiniteMatrixColumns matrix = 2;
  bool has_matrix() const;
  void clear_matrix();
  static const int kMatrixFieldNumber = 2;
  private:
  const ::LowerTriangularPositiveSemidefiniteMatrixColumns& _internal_matrix() const;
  public:
  const ::LowerTriangularPositiveSemidefiniteMatrixColumns& matrix() const;
  ::LowerTriangularPositiveSemidefiniteMatrixColumns* release_matrix();
  ::LowerTriangularPositiveSemidefiniteMatrixColumns* mutable_matrix();
  void set_allocated_matrix(::LowerTriangularPositiveSemidefiniteMatrixColumns* matrix);

  // @@protoc_insertion_point(class_scope:LowerTriangularPositiveSemidefiniteMatrix)
 private:
  void set_has_componentsincludedinthematrix();
  void clear_has_componentsincludedinthematrix();
  void set_has_matrix();
  void clear_has_matrix();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MatrixIncludedComponents* componentsincludedinthematrix_;
  ::LowerTriangularPositiveSemidefiniteMatrixColumns* matrix_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LowerTriangularPositiveSemidefiniteMatrixColumns : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LowerTriangularPositiveSemidefiniteMatrixColumns) */ {
 public:
  LowerTriangularPositiveSemidefiniteMatrixColumns();
  virtual ~LowerTriangularPositiveSemidefiniteMatrixColumns();

  LowerTriangularPositiveSemidefiniteMatrixColumns(const LowerTriangularPositiveSemidefiniteMatrixColumns& from);

  inline LowerTriangularPositiveSemidefiniteMatrixColumns& operator=(const LowerTriangularPositiveSemidefiniteMatrixColumns& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LowerTriangularPositiveSemidefiniteMatrixColumns(LowerTriangularPositiveSemidefiniteMatrixColumns&& from) noexcept
    : LowerTriangularPositiveSemidefiniteMatrixColumns() {
    *this = ::std::move(from);
  }

  inline LowerTriangularPositiveSemidefiniteMatrixColumns& operator=(LowerTriangularPositiveSemidefiniteMatrixColumns&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LowerTriangularPositiveSemidefiniteMatrixColumns& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LowerTriangularPositiveSemidefiniteMatrixColumns* internal_default_instance() {
    return reinterpret_cast<const LowerTriangularPositiveSemidefiniteMatrixColumns*>(
               &_LowerTriangularPositiveSemidefiniteMatrixColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(LowerTriangularPositiveSemidefiniteMatrixColumns* other);
  friend void swap(LowerTriangularPositiveSemidefiniteMatrixColumns& a, LowerTriangularPositiveSemidefiniteMatrixColumns& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LowerTriangularPositiveSemidefiniteMatrixColumns* New() const final {
    return CreateMaybeMessage<LowerTriangularPositiveSemidefiniteMatrixColumns>(NULL);
  }

  LowerTriangularPositiveSemidefiniteMatrixColumns* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LowerTriangularPositiveSemidefiniteMatrixColumns>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LowerTriangularPositiveSemidefiniteMatrixColumns& from);
  void MergeFrom(const LowerTriangularPositiveSemidefiniteMatrixColumns& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LowerTriangularPositiveSemidefiniteMatrixColumns* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CorrelationColumn columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  ::CorrelationColumn* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::CorrelationColumn >*
      mutable_columns();
  const ::CorrelationColumn& columns(int index) const;
  ::CorrelationColumn* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::CorrelationColumn >&
      columns() const;

  // @@protoc_insertion_point(class_scope:LowerTriangularPositiveSemidefiniteMatrixColumns)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CorrelationColumn > columns_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MapPosition) */ {
 public:
  MapPosition();
  virtual ~MapPosition();

  MapPosition(const MapPosition& from);

  inline MapPosition& operator=(const MapPosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapPosition(MapPosition&& from) noexcept
    : MapPosition() {
    *this = ::std::move(from);
  }

  inline MapPosition& operator=(MapPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapPosition* internal_default_instance() {
    return reinterpret_cast<const MapPosition*>(
               &_MapPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(MapPosition* other);
  friend void swap(MapPosition& a, MapPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapPosition* New() const final {
    return CreateMaybeMessage<MapPosition>(NULL);
  }

  MapPosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapPosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapPosition& from);
  void MergeFrom(const MapPosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MapReference mapReference = 1;
  bool has_mapreference() const;
  void clear_mapreference();
  static const int kMapReferenceFieldNumber = 1;
  private:
  const ::MapReference& _internal_mapreference() const;
  public:
  const ::MapReference& mapreference() const;
  ::MapReference* release_mapreference();
  ::MapReference* mutable_mapreference();
  void set_allocated_mapreference(::MapReference* mapreference);

  // optional .LongitudinalLanePosition longitudinalLanePosition = 4;
  bool has_longitudinallaneposition() const;
  void clear_longitudinallaneposition();
  static const int kLongitudinalLanePositionFieldNumber = 4;
  private:
  const ::LongitudinalLanePosition& _internal_longitudinallaneposition() const;
  public:
  const ::LongitudinalLanePosition& longitudinallaneposition() const;
  ::LongitudinalLanePosition* release_longitudinallaneposition();
  ::LongitudinalLanePosition* mutable_longitudinallaneposition();
  void set_allocated_longitudinallaneposition(::LongitudinalLanePosition* longitudinallaneposition);

  // optional uint32 laneId = 2;
  bool has_laneid() const;
  void clear_laneid();
  static const int kLaneIdFieldNumber = 2;
  ::google::protobuf::uint32 laneid() const;
  void set_laneid(::google::protobuf::uint32 value);

  // optional uint32 connectionId = 3;
  bool has_connectionid() const;
  void clear_connectionid();
  static const int kConnectionIdFieldNumber = 3;
  ::google::protobuf::uint32 connectionid() const;
  void set_connectionid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MapPosition)
 private:
  void set_has_mapreference();
  void clear_has_mapreference();
  void set_has_laneid();
  void clear_has_laneid();
  void set_has_connectionid();
  void clear_has_connectionid();
  void set_has_longitudinallaneposition();
  void clear_has_longitudinallaneposition();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::MapReference* mapreference_;
  ::LongitudinalLanePosition* longitudinallaneposition_;
  ::google::protobuf::uint32 laneid_;
  ::google::protobuf::uint32 connectionid_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MapReference) */ {
 public:
  MapReference();
  virtual ~MapReference();

  MapReference(const MapReference& from);

  inline MapReference& operator=(const MapReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapReference(MapReference&& from) noexcept
    : MapReference() {
    *this = ::std::move(from);
  }

  inline MapReference& operator=(MapReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapReference& default_instance();

  enum MaprefCase {
    kRoadsegment = 1,
    kIntersection = 2,
    MAPREF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapReference* internal_default_instance() {
    return reinterpret_cast<const MapReference*>(
               &_MapReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(MapReference* other);
  friend void swap(MapReference& a, MapReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapReference* New() const final {
    return CreateMaybeMessage<MapReference>(NULL);
  }

  MapReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapReference& from);
  void MergeFrom(const MapReference& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RoadSegmentReferenceID roadsegment = 1;
  bool has_roadsegment() const;
  void clear_roadsegment();
  static const int kRoadsegmentFieldNumber = 1;
  private:
  const ::RoadSegmentReferenceID& _internal_roadsegment() const;
  public:
  const ::RoadSegmentReferenceID& roadsegment() const;
  ::RoadSegmentReferenceID* release_roadsegment();
  ::RoadSegmentReferenceID* mutable_roadsegment();
  void set_allocated_roadsegment(::RoadSegmentReferenceID* roadsegment);

  // optional .IntersectionReferenceID intersection = 2;
  bool has_intersection() const;
  void clear_intersection();
  static const int kIntersectionFieldNumber = 2;
  private:
  const ::IntersectionReferenceID& _internal_intersection() const;
  public:
  const ::IntersectionReferenceID& intersection() const;
  ::IntersectionReferenceID* release_intersection();
  ::IntersectionReferenceID* mutable_intersection();
  void set_allocated_intersection(::IntersectionReferenceID* intersection);

  void clear_mapref();
  MaprefCase mapref_case() const;
  // @@protoc_insertion_point(class_scope:MapReference)
 private:
  void set_has_roadsegment();
  void set_has_intersection();

  inline bool has_mapref() const;
  inline void clear_has_mapref();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union MaprefUnion {
    MaprefUnion() {}
    ::RoadSegmentReferenceID* roadsegment_;
    ::IntersectionReferenceID* intersection_;
  } mapref_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatrixIncludedComponents : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MatrixIncludedComponents) */ {
 public:
  MatrixIncludedComponents();
  virtual ~MatrixIncludedComponents();

  MatrixIncludedComponents(const MatrixIncludedComponents& from);

  inline MatrixIncludedComponents& operator=(const MatrixIncludedComponents& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatrixIncludedComponents(MatrixIncludedComponents&& from) noexcept
    : MatrixIncludedComponents() {
    *this = ::std::move(from);
  }

  inline MatrixIncludedComponents& operator=(MatrixIncludedComponents&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatrixIncludedComponents& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatrixIncludedComponents* internal_default_instance() {
    return reinterpret_cast<const MatrixIncludedComponents*>(
               &_MatrixIncludedComponents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(MatrixIncludedComponents* other);
  friend void swap(MatrixIncludedComponents& a, MatrixIncludedComponents& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatrixIncludedComponents* New() const final {
    return CreateMaybeMessage<MatrixIncludedComponents>(NULL);
  }

  MatrixIncludedComponents* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatrixIncludedComponents>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatrixIncludedComponents& from);
  void MergeFrom(const MatrixIncludedComponents& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatrixIncludedComponents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool xPosition = 1;
  bool has_xposition() const;
  void clear_xposition();
  static const int kXPositionFieldNumber = 1;
  bool xposition() const;
  void set_xposition(bool value);

  // required bool yPosition = 2;
  bool has_yposition() const;
  void clear_yposition();
  static const int kYPositionFieldNumber = 2;
  bool yposition() const;
  void set_yposition(bool value);

  // required bool zPosition = 3;
  bool has_zposition() const;
  void clear_zposition();
  static const int kZPositionFieldNumber = 3;
  bool zposition() const;
  void set_zposition(bool value);

  // required bool xVelocityOrVelocityMagnitude = 4;
  bool has_xvelocityorvelocitymagnitude() const;
  void clear_xvelocityorvelocitymagnitude();
  static const int kXVelocityOrVelocityMagnitudeFieldNumber = 4;
  bool xvelocityorvelocitymagnitude() const;
  void set_xvelocityorvelocitymagnitude(bool value);

  // required bool yVelocityOrVelocityDirection = 5;
  bool has_yvelocityorvelocitydirection() const;
  void clear_yvelocityorvelocitydirection();
  static const int kYVelocityOrVelocityDirectionFieldNumber = 5;
  bool yvelocityorvelocitydirection() const;
  void set_yvelocityorvelocitydirection(bool value);

  // required bool zSpeed = 6;
  bool has_zspeed() const;
  void clear_zspeed();
  static const int kZSpeedFieldNumber = 6;
  bool zspeed() const;
  void set_zspeed(bool value);

  // required bool xAccelOrAccelMagnitude = 7;
  bool has_xacceloraccelmagnitude() const;
  void clear_xacceloraccelmagnitude();
  static const int kXAccelOrAccelMagnitudeFieldNumber = 7;
  bool xacceloraccelmagnitude() const;
  void set_xacceloraccelmagnitude(bool value);

  // required bool yAccelOrAccelDirection = 8;
  bool has_yacceloracceldirection() const;
  void clear_yacceloracceldirection();
  static const int kYAccelOrAccelDirectionFieldNumber = 8;
  bool yacceloracceldirection() const;
  void set_yacceloracceldirection(bool value);

  // required bool zAcceleration = 9;
  bool has_zacceleration() const;
  void clear_zacceleration();
  static const int kZAccelerationFieldNumber = 9;
  bool zacceleration() const;
  void set_zacceleration(bool value);

  // required bool zAngle = 10;
  bool has_zangle() const;
  void clear_zangle();
  static const int kZAngleFieldNumber = 10;
  bool zangle() const;
  void set_zangle(bool value);

  // required bool yAngle = 11;
  bool has_yangle() const;
  void clear_yangle();
  static const int kYAngleFieldNumber = 11;
  bool yangle() const;
  void set_yangle(bool value);

  // required bool xAngle = 12;
  bool has_xangle() const;
  void clear_xangle();
  static const int kXAngleFieldNumber = 12;
  bool xangle() const;
  void set_xangle(bool value);

  // required bool zAngularVelocity = 13;
  bool has_zangularvelocity() const;
  void clear_zangularvelocity();
  static const int kZAngularVelocityFieldNumber = 13;
  bool zangularvelocity() const;
  void set_zangularvelocity(bool value);

  // @@protoc_insertion_point(class_scope:MatrixIncludedComponents)
 private:
  void set_has_xposition();
  void clear_has_xposition();
  void set_has_yposition();
  void clear_has_yposition();
  void set_has_zposition();
  void clear_has_zposition();
  void set_has_xvelocityorvelocitymagnitude();
  void clear_has_xvelocityorvelocitymagnitude();
  void set_has_yvelocityorvelocitydirection();
  void clear_has_yvelocityorvelocitydirection();
  void set_has_zspeed();
  void clear_has_zspeed();
  void set_has_xacceloraccelmagnitude();
  void clear_has_xacceloraccelmagnitude();
  void set_has_yacceloracceldirection();
  void clear_has_yacceloracceldirection();
  void set_has_zacceleration();
  void clear_has_zacceleration();
  void set_has_zangle();
  void clear_has_zangle();
  void set_has_yangle();
  void clear_has_yangle();
  void set_has_xangle();
  void clear_has_xangle();
  void set_has_zangularvelocity();
  void clear_has_zangularvelocity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool xposition_;
  bool yposition_;
  bool zposition_;
  bool xvelocityorvelocitymagnitude_;
  bool yvelocityorvelocitydirection_;
  bool zspeed_;
  bool xacceloraccelmagnitude_;
  bool yacceloracceldirection_;
  bool zacceleration_;
  bool zangle_;
  bool yangle_;
  bool xangle_;
  bool zangularvelocity_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageRateHz : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageRateHz) */ {
 public:
  MessageRateHz();
  virtual ~MessageRateHz();

  MessageRateHz(const MessageRateHz& from);

  inline MessageRateHz& operator=(const MessageRateHz& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageRateHz(MessageRateHz&& from) noexcept
    : MessageRateHz() {
    *this = ::std::move(from);
  }

  inline MessageRateHz& operator=(MessageRateHz&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageRateHz& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageRateHz* internal_default_instance() {
    return reinterpret_cast<const MessageRateHz*>(
               &_MessageRateHz_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(MessageRateHz* other);
  friend void swap(MessageRateHz& a, MessageRateHz& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageRateHz* New() const final {
    return CreateMaybeMessage<MessageRateHz>(NULL);
  }

  MessageRateHz* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageRateHz>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageRateHz& from);
  void MergeFrom(const MessageRateHz& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageRateHz* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mantissa = 1;
  bool has_mantissa() const;
  void clear_mantissa();
  static const int kMantissaFieldNumber = 1;
  ::google::protobuf::uint32 mantissa() const;
  void set_mantissa(::google::protobuf::uint32 value);

  // required int32 exponent = 2;
  bool has_exponent() const;
  void clear_exponent();
  static const int kExponentFieldNumber = 2;
  ::google::protobuf::int32 exponent() const;
  void set_exponent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MessageRateHz)
 private:
  void set_has_mantissa();
  void clear_has_mantissa();
  void set_has_exponent();
  void clear_has_exponent();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 mantissa_;
  ::google::protobuf::int32 exponent_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageSegmentationInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageSegmentationInfo) */ {
 public:
  MessageSegmentationInfo();
  virtual ~MessageSegmentationInfo();

  MessageSegmentationInfo(const MessageSegmentationInfo& from);

  inline MessageSegmentationInfo& operator=(const MessageSegmentationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageSegmentationInfo(MessageSegmentationInfo&& from) noexcept
    : MessageSegmentationInfo() {
    *this = ::std::move(from);
  }

  inline MessageSegmentationInfo& operator=(MessageSegmentationInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageSegmentationInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageSegmentationInfo* internal_default_instance() {
    return reinterpret_cast<const MessageSegmentationInfo*>(
               &_MessageSegmentationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(MessageSegmentationInfo* other);
  friend void swap(MessageSegmentationInfo& a, MessageSegmentationInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageSegmentationInfo* New() const final {
    return CreateMaybeMessage<MessageSegmentationInfo>(NULL);
  }

  MessageSegmentationInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageSegmentationInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageSegmentationInfo& from);
  void MergeFrom(const MessageSegmentationInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageSegmentationInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 totalMsgNo = 1;
  bool has_totalmsgno() const;
  void clear_totalmsgno();
  static const int kTotalMsgNoFieldNumber = 1;
  ::google::protobuf::uint32 totalmsgno() const;
  void set_totalmsgno(::google::protobuf::uint32 value);

  // required uint32 thisMsgNo = 2;
  bool has_thismsgno() const;
  void clear_thismsgno();
  static const int kThisMsgNoFieldNumber = 2;
  ::google::protobuf::uint32 thismsgno() const;
  void set_thismsgno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MessageSegmentationInfo)
 private:
  void set_has_totalmsgno();
  void clear_has_totalmsgno();
  void set_has_thismsgno();
  void clear_has_thismsgno();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 totalmsgno_;
  ::google::protobuf::uint32 thismsgno_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectClass : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ObjectClass) */ {
 public:
  ObjectClass();
  virtual ~ObjectClass();

  ObjectClass(const ObjectClass& from);

  inline ObjectClass& operator=(const ObjectClass& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectClass(ObjectClass&& from) noexcept
    : ObjectClass() {
    *this = ::std::move(from);
  }

  inline ObjectClass& operator=(ObjectClass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectClass& default_instance();

  enum ClassCase {
    kVehicleSubClass = 1,
    kVruSubClass = 2,
    kGroupSubClass = 3,
    kOtherSubClass = 4,
    CLASS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectClass* internal_default_instance() {
    return reinterpret_cast<const ObjectClass*>(
               &_ObjectClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(ObjectClass* other);
  friend void swap(ObjectClass& a, ObjectClass& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectClass* New() const final {
    return CreateMaybeMessage<ObjectClass>(NULL);
  }

  ObjectClass* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectClass>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectClass& from);
  void MergeFrom(const ObjectClass& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectClass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TrafficParticipantType vehicleSubClass = 1;
  bool has_vehiclesubclass() const;
  void clear_vehiclesubclass();
  static const int kVehicleSubClassFieldNumber = 1;
  ::TrafficParticipantType vehiclesubclass() const;
  void set_vehiclesubclass(::TrafficParticipantType value);

  // optional .VruProfileAndSubprofile vruSubClass = 2;
  bool has_vrusubclass() const;
  void clear_vrusubclass();
  static const int kVruSubClassFieldNumber = 2;
  private:
  const ::VruProfileAndSubprofile& _internal_vrusubclass() const;
  public:
  const ::VruProfileAndSubprofile& vrusubclass() const;
  ::VruProfileAndSubprofile* release_vrusubclass();
  ::VruProfileAndSubprofile* mutable_vrusubclass();
  void set_allocated_vrusubclass(::VruProfileAndSubprofile* vrusubclass);

  // optional .VruClusterInformation groupSubClass = 3;
  bool has_groupsubclass() const;
  void clear_groupsubclass();
  static const int kGroupSubClassFieldNumber = 3;
  private:
  const ::VruClusterInformation& _internal_groupsubclass() const;
  public:
  const ::VruClusterInformation& groupsubclass() const;
  ::VruClusterInformation* release_groupsubclass();
  ::VruClusterInformation* mutable_groupsubclass();
  void set_allocated_groupsubclass(::VruClusterInformation* groupsubclass);

  // optional .OtherSubClass otherSubClass = 4;
  bool has_othersubclass() const;
  void clear_othersubclass();
  static const int kOtherSubClassFieldNumber = 4;
  private:
  const ::OtherSubClass& _internal_othersubclass() const;
  public:
  const ::OtherSubClass& othersubclass() const;
  ::OtherSubClass* release_othersubclass();
  ::OtherSubClass* mutable_othersubclass();
  void set_allocated_othersubclass(::OtherSubClass* othersubclass);

  void clear_class();
  ClassCase class_case() const;
  // @@protoc_insertion_point(class_scope:ObjectClass)
 private:
  void set_has_vehiclesubclass();
  void set_has_vrusubclass();
  void set_has_groupsubclass();
  void set_has_othersubclass();

  inline bool has_class() const;
  inline void clear_has_class();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ClassUnion {
    ClassUnion() {}
    int vehiclesubclass_;
    ::VruProfileAndSubprofile* vrusubclass_;
    ::VruClusterInformation* groupsubclass_;
    ::OtherSubClass* othersubclass_;
  } class_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectClassWithConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ObjectClassWithConfidence) */ {
 public:
  ObjectClassWithConfidence();
  virtual ~ObjectClassWithConfidence();

  ObjectClassWithConfidence(const ObjectClassWithConfidence& from);

  inline ObjectClassWithConfidence& operator=(const ObjectClassWithConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectClassWithConfidence(ObjectClassWithConfidence&& from) noexcept
    : ObjectClassWithConfidence() {
    *this = ::std::move(from);
  }

  inline ObjectClassWithConfidence& operator=(ObjectClassWithConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectClassWithConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectClassWithConfidence* internal_default_instance() {
    return reinterpret_cast<const ObjectClassWithConfidence*>(
               &_ObjectClassWithConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(ObjectClassWithConfidence* other);
  friend void swap(ObjectClassWithConfidence& a, ObjectClassWithConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectClassWithConfidence* New() const final {
    return CreateMaybeMessage<ObjectClassWithConfidence>(NULL);
  }

  ObjectClassWithConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectClassWithConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectClassWithConfidence& from);
  void MergeFrom(const ObjectClassWithConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectClassWithConfidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ObjectClass objectClass = 1;
  bool has_objectclass() const;
  void clear_objectclass();
  static const int kObjectClassFieldNumber = 1;
  private:
  const ::ObjectClass& _internal_objectclass() const;
  public:
  const ::ObjectClass& objectclass() const;
  ::ObjectClass* release_objectclass();
  ::ObjectClass* mutable_objectclass();
  void set_allocated_objectclass(::ObjectClass* objectclass);

  // required uint32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 confidence() const;
  void set_confidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ObjectClassWithConfidence)
 private:
  void set_has_objectclass();
  void clear_has_objectclass();
  void set_has_confidence();
  void clear_has_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ObjectClass* objectclass_;
  ::google::protobuf::uint32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectDimension : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ObjectDimension) */ {
 public:
  ObjectDimension();
  virtual ~ObjectDimension();

  ObjectDimension(const ObjectDimension& from);

  inline ObjectDimension& operator=(const ObjectDimension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectDimension(ObjectDimension&& from) noexcept
    : ObjectDimension() {
    *this = ::std::move(from);
  }

  inline ObjectDimension& operator=(ObjectDimension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectDimension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDimension* internal_default_instance() {
    return reinterpret_cast<const ObjectDimension*>(
               &_ObjectDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(ObjectDimension* other);
  friend void swap(ObjectDimension& a, ObjectDimension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectDimension* New() const final {
    return CreateMaybeMessage<ObjectDimension>(NULL);
  }

  ObjectDimension* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectDimension>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectDimension& from);
  void MergeFrom(const ObjectDimension& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDimension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // required uint32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 confidence() const;
  void set_confidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ObjectDimension)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OtherSubClass : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OtherSubClass) */ {
 public:
  OtherSubClass();
  virtual ~OtherSubClass();

  OtherSubClass(const OtherSubClass& from);

  inline OtherSubClass& operator=(const OtherSubClass& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OtherSubClass(OtherSubClass&& from) noexcept
    : OtherSubClass() {
    *this = ::std::move(from);
  }

  inline OtherSubClass& operator=(OtherSubClass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OtherSubClass& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OtherSubClass* internal_default_instance() {
    return reinterpret_cast<const OtherSubClass*>(
               &_OtherSubClass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(OtherSubClass* other);
  friend void swap(OtherSubClass& a, OtherSubClass& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OtherSubClass* New() const final {
    return CreateMaybeMessage<OtherSubClass>(NULL);
  }

  OtherSubClass* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OtherSubClass>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OtherSubClass& from);
  void MergeFrom(const OtherSubClass& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OtherSubClass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool unknown = 1;
  bool has_unknown() const;
  void clear_unknown();
  static const int kUnknownFieldNumber = 1;
  bool unknown() const;
  void set_unknown(bool value);

  // required bool singleObject = 2;
  bool has_singleobject() const;
  void clear_singleobject();
  static const int kSingleObjectFieldNumber = 2;
  bool singleobject() const;
  void set_singleobject(bool value);

  // required bool multipleObjects = 3;
  bool has_multipleobjects() const;
  void clear_multipleobjects();
  static const int kMultipleObjectsFieldNumber = 3;
  bool multipleobjects() const;
  void set_multipleobjects(bool value);

  // required bool bulkMaterial = 4;
  bool has_bulkmaterial() const;
  void clear_bulkmaterial();
  static const int kBulkMaterialFieldNumber = 4;
  bool bulkmaterial() const;
  void set_bulkmaterial(bool value);

  // @@protoc_insertion_point(class_scope:OtherSubClass)
 private:
  void set_has_unknown();
  void clear_has_unknown();
  void set_has_singleobject();
  void clear_has_singleobject();
  void set_has_multipleobjects();
  void clear_has_multipleobjects();
  void set_has_bulkmaterial();
  void clear_has_bulkmaterial();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool unknown_;
  bool singleobject_;
  bool multipleobjects_;
  bool bulkmaterial_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PolygonalShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PolygonalShape) */ {
 public:
  PolygonalShape();
  virtual ~PolygonalShape();

  PolygonalShape(const PolygonalShape& from);

  inline PolygonalShape& operator=(const PolygonalShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PolygonalShape(PolygonalShape&& from) noexcept
    : PolygonalShape() {
    *this = ::std::move(from);
  }

  inline PolygonalShape& operator=(PolygonalShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PolygonalShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PolygonalShape* internal_default_instance() {
    return reinterpret_cast<const PolygonalShape*>(
               &_PolygonalShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(PolygonalShape* other);
  friend void swap(PolygonalShape& a, PolygonalShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PolygonalShape* New() const final {
    return CreateMaybeMessage<PolygonalShape>(NULL);
  }

  PolygonalShape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PolygonalShape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PolygonalShape& from);
  void MergeFrom(const PolygonalShape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolygonalShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CartesianPosition3d polygon = 2;
  int polygon_size() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  ::CartesianPosition3d* mutable_polygon(int index);
  ::google::protobuf::RepeatedPtrField< ::CartesianPosition3d >*
      mutable_polygon();
  const ::CartesianPosition3d& polygon(int index) const;
  ::CartesianPosition3d* add_polygon();
  const ::google::protobuf::RepeatedPtrField< ::CartesianPosition3d >&
      polygon() const;

  // optional .CartesianPosition3d shapeReferencePoint = 1;
  bool has_shapereferencepoint() const;
  void clear_shapereferencepoint();
  static const int kShapeReferencePointFieldNumber = 1;
  private:
  const ::CartesianPosition3d& _internal_shapereferencepoint() const;
  public:
  const ::CartesianPosition3d& shapereferencepoint() const;
  ::CartesianPosition3d* release_shapereferencepoint();
  ::CartesianPosition3d* mutable_shapereferencepoint();
  void set_allocated_shapereferencepoint(::CartesianPosition3d* shapereferencepoint);

  // optional uint32 height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PolygonalShape)
 private:
  void set_has_shapereferencepoint();
  void clear_has_shapereferencepoint();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CartesianPosition3d > polygon_;
  ::CartesianPosition3d* shapereferencepoint_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PositionConfidenceEllipse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PositionConfidenceEllipse) */ {
 public:
  PositionConfidenceEllipse();
  virtual ~PositionConfidenceEllipse();

  PositionConfidenceEllipse(const PositionConfidenceEllipse& from);

  inline PositionConfidenceEllipse& operator=(const PositionConfidenceEllipse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionConfidenceEllipse(PositionConfidenceEllipse&& from) noexcept
    : PositionConfidenceEllipse() {
    *this = ::std::move(from);
  }

  inline PositionConfidenceEllipse& operator=(PositionConfidenceEllipse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionConfidenceEllipse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionConfidenceEllipse* internal_default_instance() {
    return reinterpret_cast<const PositionConfidenceEllipse*>(
               &_PositionConfidenceEllipse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(PositionConfidenceEllipse* other);
  friend void swap(PositionConfidenceEllipse& a, PositionConfidenceEllipse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionConfidenceEllipse* New() const final {
    return CreateMaybeMessage<PositionConfidenceEllipse>(NULL);
  }

  PositionConfidenceEllipse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionConfidenceEllipse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionConfidenceEllipse& from);
  void MergeFrom(const PositionConfidenceEllipse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionConfidenceEllipse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 semi_major_confidence = 1;
  bool has_semi_major_confidence() const;
  void clear_semi_major_confidence();
  static const int kSemiMajorConfidenceFieldNumber = 1;
  ::google::protobuf::uint32 semi_major_confidence() const;
  void set_semi_major_confidence(::google::protobuf::uint32 value);

  // required uint32 semi_minor_confidence = 2;
  bool has_semi_minor_confidence() const;
  void clear_semi_minor_confidence();
  static const int kSemiMinorConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 semi_minor_confidence() const;
  void set_semi_minor_confidence(::google::protobuf::uint32 value);

  // required uint32 semi_major_orientation = 3;
  bool has_semi_major_orientation() const;
  void clear_semi_major_orientation();
  static const int kSemiMajorOrientationFieldNumber = 3;
  ::google::protobuf::uint32 semi_major_orientation() const;
  void set_semi_major_orientation(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PositionConfidenceEllipse)
 private:
  void set_has_semi_major_confidence();
  void clear_has_semi_major_confidence();
  void set_has_semi_minor_confidence();
  void clear_has_semi_minor_confidence();
  void set_has_semi_major_orientation();
  void clear_has_semi_major_orientation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 semi_major_confidence_;
  ::google::protobuf::uint32 semi_minor_confidence_;
  ::google::protobuf::uint32 semi_major_orientation_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RadialShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RadialShape) */ {
 public:
  RadialShape();
  virtual ~RadialShape();

  RadialShape(const RadialShape& from);

  inline RadialShape& operator=(const RadialShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RadialShape(RadialShape&& from) noexcept
    : RadialShape() {
    *this = ::std::move(from);
  }

  inline RadialShape& operator=(RadialShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadialShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadialShape* internal_default_instance() {
    return reinterpret_cast<const RadialShape*>(
               &_RadialShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(RadialShape* other);
  friend void swap(RadialShape& a, RadialShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RadialShape* New() const final {
    return CreateMaybeMessage<RadialShape>(NULL);
  }

  RadialShape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RadialShape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RadialShape& from);
  void MergeFrom(const RadialShape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadialShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CartesianPosition3d sharedRefPoint = 1;
  bool has_sharedrefpoint() const;
  void clear_sharedrefpoint();
  static const int kSharedRefPointFieldNumber = 1;
  private:
  const ::CartesianPosition3d& _internal_sharedrefpoint() const;
  public:
  const ::CartesianPosition3d& sharedrefpoint() const;
  ::CartesianPosition3d* release_sharedrefpoint();
  ::CartesianPosition3d* mutable_sharedrefpoint();
  void set_allocated_sharedrefpoint(::CartesianPosition3d* sharedrefpoint);

  // required uint32 range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  ::google::protobuf::uint32 range() const;
  void set_range(::google::protobuf::uint32 value);

  // required uint32 stationaryHorizontalOpeningAngleStart = 3;
  bool has_stationaryhorizontalopeninganglestart() const;
  void clear_stationaryhorizontalopeninganglestart();
  static const int kStationaryHorizontalOpeningAngleStartFieldNumber = 3;
  ::google::protobuf::uint32 stationaryhorizontalopeninganglestart() const;
  void set_stationaryhorizontalopeninganglestart(::google::protobuf::uint32 value);

  // required uint32 stationaryHorizontalOpeningAngleEnd = 4;
  bool has_stationaryhorizontalopeningangleend() const;
  void clear_stationaryhorizontalopeningangleend();
  static const int kStationaryHorizontalOpeningAngleEndFieldNumber = 4;
  ::google::protobuf::uint32 stationaryhorizontalopeningangleend() const;
  void set_stationaryhorizontalopeningangleend(::google::protobuf::uint32 value);

  // optional uint32 verticalOpeningAngleStart = 5;
  bool has_verticalopeninganglestart() const;
  void clear_verticalopeninganglestart();
  static const int kVerticalOpeningAngleStartFieldNumber = 5;
  ::google::protobuf::uint32 verticalopeninganglestart() const;
  void set_verticalopeninganglestart(::google::protobuf::uint32 value);

  // optional uint32 verticalOpeningAngleEnd = 6;
  bool has_verticalopeningangleend() const;
  void clear_verticalopeningangleend();
  static const int kVerticalOpeningAngleEndFieldNumber = 6;
  ::google::protobuf::uint32 verticalopeningangleend() const;
  void set_verticalopeningangleend(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RadialShape)
 private:
  void set_has_sharedrefpoint();
  void clear_has_sharedrefpoint();
  void set_has_range();
  void clear_has_range();
  void set_has_stationaryhorizontalopeninganglestart();
  void clear_has_stationaryhorizontalopeninganglestart();
  void set_has_stationaryhorizontalopeningangleend();
  void clear_has_stationaryhorizontalopeningangleend();
  void set_has_verticalopeninganglestart();
  void clear_has_verticalopeninganglestart();
  void set_has_verticalopeningangleend();
  void clear_has_verticalopeningangleend();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CartesianPosition3d* sharedrefpoint_;
  ::google::protobuf::uint32 range_;
  ::google::protobuf::uint32 stationaryhorizontalopeninganglestart_;
  ::google::protobuf::uint32 stationaryhorizontalopeningangleend_;
  ::google::protobuf::uint32 verticalopeninganglestart_;
  ::google::protobuf::uint32 verticalopeningangleend_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RadialShapes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RadialShapes) */ {
 public:
  RadialShapes();
  virtual ~RadialShapes();

  RadialShapes(const RadialShapes& from);

  inline RadialShapes& operator=(const RadialShapes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RadialShapes(RadialShapes&& from) noexcept
    : RadialShapes() {
    *this = ::std::move(from);
  }

  inline RadialShapes& operator=(RadialShapes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadialShapes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadialShapes* internal_default_instance() {
    return reinterpret_cast<const RadialShapes*>(
               &_RadialShapes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(RadialShapes* other);
  friend void swap(RadialShapes& a, RadialShapes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RadialShapes* New() const final {
    return CreateMaybeMessage<RadialShapes>(NULL);
  }

  RadialShapes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RadialShapes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RadialShapes& from);
  void MergeFrom(const RadialShapes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadialShapes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RadialShapeDetails radialShapesList = 6;
  int radialshapeslist_size() const;
  void clear_radialshapeslist();
  static const int kRadialShapesListFieldNumber = 6;
  ::RadialShapeDetails* mutable_radialshapeslist(int index);
  ::google::protobuf::RepeatedPtrField< ::RadialShapeDetails >*
      mutable_radialshapeslist();
  const ::RadialShapeDetails& radialshapeslist(int index) const;
  ::RadialShapeDetails* add_radialshapeslist();
  const ::google::protobuf::RepeatedPtrField< ::RadialShapeDetails >&
      radialshapeslist() const;

  // required uint32 refPointID = 1;
  bool has_refpointid() const;
  void clear_refpointid();
  static const int kRefPointIDFieldNumber = 1;
  ::google::protobuf::uint32 refpointid() const;
  void set_refpointid(::google::protobuf::uint32 value);

  // required int32 x_cord = 2;
  bool has_x_cord() const;
  void clear_x_cord();
  static const int kXCordFieldNumber = 2;
  ::google::protobuf::int32 x_cord() const;
  void set_x_cord(::google::protobuf::int32 value);

  // required int32 y_cord = 3;
  bool has_y_cord() const;
  void clear_y_cord();
  static const int kYCordFieldNumber = 3;
  ::google::protobuf::int32 y_cord() const;
  void set_y_cord(::google::protobuf::int32 value);

  // optional int32 z_cord = 4;
  bool has_z_cord() const;
  void clear_z_cord();
  static const int kZCordFieldNumber = 4;
  ::google::protobuf::int32 z_cord() const;
  void set_z_cord(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RadialShapes)
 private:
  void set_has_refpointid();
  void clear_has_refpointid();
  void set_has_x_cord();
  void clear_has_x_cord();
  void set_has_y_cord();
  void clear_has_y_cord();
  void set_has_z_cord();
  void clear_has_z_cord();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RadialShapeDetails > radialshapeslist_;
  ::google::protobuf::uint32 refpointid_;
  ::google::protobuf::int32 x_cord_;
  ::google::protobuf::int32 y_cord_;
  ::google::protobuf::int32 z_cord_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RadialShapeDetails : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RadialShapeDetails) */ {
 public:
  RadialShapeDetails();
  virtual ~RadialShapeDetails();

  RadialShapeDetails(const RadialShapeDetails& from);

  inline RadialShapeDetails& operator=(const RadialShapeDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RadialShapeDetails(RadialShapeDetails&& from) noexcept
    : RadialShapeDetails() {
    *this = ::std::move(from);
  }

  inline RadialShapeDetails& operator=(RadialShapeDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadialShapeDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadialShapeDetails* internal_default_instance() {
    return reinterpret_cast<const RadialShapeDetails*>(
               &_RadialShapeDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(RadialShapeDetails* other);
  friend void swap(RadialShapeDetails& a, RadialShapeDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RadialShapeDetails* New() const final {
    return CreateMaybeMessage<RadialShapeDetails>(NULL);
  }

  RadialShapeDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RadialShapeDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RadialShapeDetails& from);
  void MergeFrom(const RadialShapeDetails& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadialShapeDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 range = 1;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 1;
  ::google::protobuf::int32 range() const;
  void set_range(::google::protobuf::int32 value);

  // required uint32 horizontalOpeningAngleStart = 2;
  bool has_horizontalopeninganglestart() const;
  void clear_horizontalopeninganglestart();
  static const int kHorizontalOpeningAngleStartFieldNumber = 2;
  ::google::protobuf::uint32 horizontalopeninganglestart() const;
  void set_horizontalopeninganglestart(::google::protobuf::uint32 value);

  // required uint32 horizontalOpeningAngleEnd = 3;
  bool has_horizontalopeningangleend() const;
  void clear_horizontalopeningangleend();
  static const int kHorizontalOpeningAngleEndFieldNumber = 3;
  ::google::protobuf::uint32 horizontalopeningangleend() const;
  void set_horizontalopeningangleend(::google::protobuf::uint32 value);

  // optional uint32 verticalOpeningAngleStart = 4;
  bool has_verticalopeninganglestart() const;
  void clear_verticalopeninganglestart();
  static const int kVerticalOpeningAngleStartFieldNumber = 4;
  ::google::protobuf::uint32 verticalopeninganglestart() const;
  void set_verticalopeninganglestart(::google::protobuf::uint32 value);

  // optional uint32 verticalOpeningAngleEnd = 5;
  bool has_verticalopeningangleend() const;
  void clear_verticalopeningangleend();
  static const int kVerticalOpeningAngleEndFieldNumber = 5;
  ::google::protobuf::uint32 verticalopeningangleend() const;
  void set_verticalopeningangleend(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RadialShapeDetails)
 private:
  void set_has_range();
  void clear_has_range();
  void set_has_horizontalopeninganglestart();
  void clear_has_horizontalopeninganglestart();
  void set_has_horizontalopeningangleend();
  void clear_has_horizontalopeningangleend();
  void set_has_verticalopeninganglestart();
  void clear_has_verticalopeninganglestart();
  void set_has_verticalopeningangleend();
  void clear_has_verticalopeningangleend();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 range_;
  ::google::protobuf::uint32 horizontalopeninganglestart_;
  ::google::protobuf::uint32 horizontalopeningangleend_;
  ::google::protobuf::uint32 verticalopeninganglestart_;
  ::google::protobuf::uint32 verticalopeningangleend_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RectangularShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RectangularShape) */ {
 public:
  RectangularShape();
  virtual ~RectangularShape();

  RectangularShape(const RectangularShape& from);

  inline RectangularShape& operator=(const RectangularShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RectangularShape(RectangularShape&& from) noexcept
    : RectangularShape() {
    *this = ::std::move(from);
  }

  inline RectangularShape& operator=(RectangularShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RectangularShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RectangularShape* internal_default_instance() {
    return reinterpret_cast<const RectangularShape*>(
               &_RectangularShape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(RectangularShape* other);
  friend void swap(RectangularShape& a, RectangularShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RectangularShape* New() const final {
    return CreateMaybeMessage<RectangularShape>(NULL);
  }

  RectangularShape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RectangularShape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RectangularShape& from);
  void MergeFrom(const RectangularShape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectangularShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CartesianPosition3d center_point = 1;
  bool has_center_point() const;
  void clear_center_point();
  static const int kCenterPointFieldNumber = 1;
  private:
  const ::CartesianPosition3d& _internal_center_point() const;
  public:
  const ::CartesianPosition3d& center_point() const;
  ::CartesianPosition3d* release_center_point();
  ::CartesianPosition3d* mutable_center_point();
  void set_allocated_center_point(::CartesianPosition3d* center_point);

  // required uint32 semiLength = 2;
  bool has_semilength() const;
  void clear_semilength();
  static const int kSemiLengthFieldNumber = 2;
  ::google::protobuf::uint32 semilength() const;
  void set_semilength(::google::protobuf::uint32 value);

  // required uint32 semiBreadth = 3;
  bool has_semibreadth() const;
  void clear_semibreadth();
  static const int kSemiBreadthFieldNumber = 3;
  ::google::protobuf::uint32 semibreadth() const;
  void set_semibreadth(::google::protobuf::uint32 value);

  // optional uint32 orientation = 4;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  ::google::protobuf::uint32 orientation() const;
  void set_orientation(::google::protobuf::uint32 value);

  // optional uint32 height = 5;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RectangularShape)
 private:
  void set_has_center_point();
  void clear_has_center_point();
  void set_has_semilength();
  void clear_has_semilength();
  void set_has_semibreadth();
  void clear_has_semibreadth();
  void set_has_orientation();
  void clear_has_orientation();
  void set_has_height();
  void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CartesianPosition3d* center_point_;
  ::google::protobuf::uint32 semilength_;
  ::google::protobuf::uint32 semibreadth_;
  ::google::protobuf::uint32 orientation_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReferenceDenms : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReferenceDenms) */ {
 public:
  ReferenceDenms();
  virtual ~ReferenceDenms();

  ReferenceDenms(const ReferenceDenms& from);

  inline ReferenceDenms& operator=(const ReferenceDenms& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReferenceDenms(ReferenceDenms&& from) noexcept
    : ReferenceDenms() {
    *this = ::std::move(from);
  }

  inline ReferenceDenms& operator=(ReferenceDenms&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceDenms& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceDenms* internal_default_instance() {
    return reinterpret_cast<const ReferenceDenms*>(
               &_ReferenceDenms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(ReferenceDenms* other);
  friend void swap(ReferenceDenms& a, ReferenceDenms& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReferenceDenms* New() const final {
    return CreateMaybeMessage<ReferenceDenms>(NULL);
  }

  ReferenceDenms* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceDenms>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReferenceDenms& from);
  void MergeFrom(const ReferenceDenms& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceDenms* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ActionID action_IDs = 1;
  int action_ids_size() const;
  void clear_action_ids();
  static const int kActionIDsFieldNumber = 1;
  ::ActionID* mutable_action_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::ActionID >*
      mutable_action_ids();
  const ::ActionID& action_ids(int index) const;
  ::ActionID* add_action_ids();
  const ::google::protobuf::RepeatedPtrField< ::ActionID >&
      action_ids() const;

  // @@protoc_insertion_point(class_scope:ReferenceDenms)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ActionID > action_ids_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReferencePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReferencePosition) */ {
 public:
  ReferencePosition();
  virtual ~ReferencePosition();

  ReferencePosition(const ReferencePosition& from);

  inline ReferencePosition& operator=(const ReferencePosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReferencePosition(ReferencePosition&& from) noexcept
    : ReferencePosition() {
    *this = ::std::move(from);
  }

  inline ReferencePosition& operator=(ReferencePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferencePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferencePosition* internal_default_instance() {
    return reinterpret_cast<const ReferencePosition*>(
               &_ReferencePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(ReferencePosition* other);
  friend void swap(ReferencePosition& a, ReferencePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReferencePosition* New() const final {
    return CreateMaybeMessage<ReferencePosition>(NULL);
  }

  ReferencePosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReferencePosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReferencePosition& from);
  void MergeFrom(const ReferencePosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferencePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PositionConfidenceEllipse position_confidence = 3;
  bool has_position_confidence() const;
  void clear_position_confidence();
  static const int kPositionConfidenceFieldNumber = 3;
  private:
  const ::PositionConfidenceEllipse& _internal_position_confidence() const;
  public:
  const ::PositionConfidenceEllipse& position_confidence() const;
  ::PositionConfidenceEllipse* release_position_confidence();
  ::PositionConfidenceEllipse* mutable_position_confidence();
  void set_allocated_position_confidence(::PositionConfidenceEllipse* position_confidence);

  // required .Altitude altitude = 4;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 4;
  private:
  const ::Altitude& _internal_altitude() const;
  public:
  const ::Altitude& altitude() const;
  ::Altitude* release_altitude();
  ::Altitude* mutable_altitude();
  void set_allocated_altitude(::Altitude* altitude);

  // required int64 latitude = 1;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  ::google::protobuf::int64 latitude() const;
  void set_latitude(::google::protobuf::int64 value);

  // required int64 longitude = 2;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  ::google::protobuf::int64 longitude() const;
  void set_longitude(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ReferencePosition)
 private:
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_position_confidence();
  void clear_has_position_confidence();
  void set_has_altitude();
  void clear_has_altitude();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::PositionConfidenceEllipse* position_confidence_;
  ::Altitude* altitude_;
  ::google::protobuf::int64 latitude_;
  ::google::protobuf::int64 longitude_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RestrictedTypes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RestrictedTypes) */ {
 public:
  RestrictedTypes();
  virtual ~RestrictedTypes();

  RestrictedTypes(const RestrictedTypes& from);

  inline RestrictedTypes& operator=(const RestrictedTypes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RestrictedTypes(RestrictedTypes&& from) noexcept
    : RestrictedTypes() {
    *this = ::std::move(from);
  }

  inline RestrictedTypes& operator=(RestrictedTypes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestrictedTypes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestrictedTypes* internal_default_instance() {
    return reinterpret_cast<const RestrictedTypes*>(
               &_RestrictedTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(RestrictedTypes* other);
  friend void swap(RestrictedTypes& a, RestrictedTypes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RestrictedTypes* New() const final {
    return CreateMaybeMessage<RestrictedTypes>(NULL);
  }

  RestrictedTypes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RestrictedTypes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RestrictedTypes& from);
  void MergeFrom(const RestrictedTypes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestrictedTypes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .StationType restricted_vehicles = 1;
  int restricted_vehicles_size() const;
  void clear_restricted_vehicles();
  static const int kRestrictedVehiclesFieldNumber = 1;
  ::StationType restricted_vehicles(int index) const;
  void set_restricted_vehicles(int index, ::StationType value);
  void add_restricted_vehicles(::StationType value);
  const ::google::protobuf::RepeatedField<int>& restricted_vehicles() const;
  ::google::protobuf::RepeatedField<int>* mutable_restricted_vehicles();

  // @@protoc_insertion_point(class_scope:RestrictedTypes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> restricted_vehicles_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadSegmentReferenceID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoadSegmentReferenceID) */ {
 public:
  RoadSegmentReferenceID();
  virtual ~RoadSegmentReferenceID();

  RoadSegmentReferenceID(const RoadSegmentReferenceID& from);

  inline RoadSegmentReferenceID& operator=(const RoadSegmentReferenceID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadSegmentReferenceID(RoadSegmentReferenceID&& from) noexcept
    : RoadSegmentReferenceID() {
    *this = ::std::move(from);
  }

  inline RoadSegmentReferenceID& operator=(RoadSegmentReferenceID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadSegmentReferenceID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadSegmentReferenceID* internal_default_instance() {
    return reinterpret_cast<const RoadSegmentReferenceID*>(
               &_RoadSegmentReferenceID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(RoadSegmentReferenceID* other);
  friend void swap(RoadSegmentReferenceID& a, RoadSegmentReferenceID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadSegmentReferenceID* New() const final {
    return CreateMaybeMessage<RoadSegmentReferenceID>(NULL);
  }

  RoadSegmentReferenceID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadSegmentReferenceID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadSegmentReferenceID& from);
  void MergeFrom(const RoadSegmentReferenceID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadSegmentReferenceID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 region = 1;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 1;
  ::google::protobuf::int64 region() const;
  void set_region(::google::protobuf::int64 value);

  // required int64 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RoadSegmentReferenceID)
 private:
  void set_has_region();
  void clear_has_region();
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 region_;
  ::google::protobuf::int64 id_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Shape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Shape) */ {
 public:
  Shape();
  virtual ~Shape();

  Shape(const Shape& from);

  inline Shape& operator=(const Shape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Shape(Shape&& from) noexcept
    : Shape() {
    *this = ::std::move(from);
  }

  inline Shape& operator=(Shape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shape& default_instance();

  enum ShapeCase {
    kRectangular = 1,
    kCircular = 2,
    kPolygonal = 3,
    kElliptical = 4,
    kRadial = 5,
    kRadialShapes = 6,
    SHAPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shape* internal_default_instance() {
    return reinterpret_cast<const Shape*>(
               &_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(Shape* other);
  friend void swap(Shape& a, Shape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Shape* New() const final {
    return CreateMaybeMessage<Shape>(NULL);
  }

  Shape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Shape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Shape& from);
  void MergeFrom(const Shape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RectangularShape rectangular = 1;
  bool has_rectangular() const;
  void clear_rectangular();
  static const int kRectangularFieldNumber = 1;
  private:
  const ::RectangularShape& _internal_rectangular() const;
  public:
  const ::RectangularShape& rectangular() const;
  ::RectangularShape* release_rectangular();
  ::RectangularShape* mutable_rectangular();
  void set_allocated_rectangular(::RectangularShape* rectangular);

  // optional .CircularShape circular = 2;
  bool has_circular() const;
  void clear_circular();
  static const int kCircularFieldNumber = 2;
  private:
  const ::CircularShape& _internal_circular() const;
  public:
  const ::CircularShape& circular() const;
  ::CircularShape* release_circular();
  ::CircularShape* mutable_circular();
  void set_allocated_circular(::CircularShape* circular);

  // optional .PolygonalShape polygonal = 3;
  bool has_polygonal() const;
  void clear_polygonal();
  static const int kPolygonalFieldNumber = 3;
  private:
  const ::PolygonalShape& _internal_polygonal() const;
  public:
  const ::PolygonalShape& polygonal() const;
  ::PolygonalShape* release_polygonal();
  ::PolygonalShape* mutable_polygonal();
  void set_allocated_polygonal(::PolygonalShape* polygonal);

  // optional .EllipticalShape elliptical = 4;
  bool has_elliptical() const;
  void clear_elliptical();
  static const int kEllipticalFieldNumber = 4;
  private:
  const ::EllipticalShape& _internal_elliptical() const;
  public:
  const ::EllipticalShape& elliptical() const;
  ::EllipticalShape* release_elliptical();
  ::EllipticalShape* mutable_elliptical();
  void set_allocated_elliptical(::EllipticalShape* elliptical);

  // optional .RadialShape radial = 5;
  bool has_radial() const;
  void clear_radial();
  static const int kRadialFieldNumber = 5;
  private:
  const ::RadialShape& _internal_radial() const;
  public:
  const ::RadialShape& radial() const;
  ::RadialShape* release_radial();
  ::RadialShape* mutable_radial();
  void set_allocated_radial(::RadialShape* radial);

  // optional .RadialShapes radialShapes = 6;
  bool has_radialshapes() const;
  void clear_radialshapes();
  static const int kRadialShapesFieldNumber = 6;
  private:
  const ::RadialShapes& _internal_radialshapes() const;
  public:
  const ::RadialShapes& radialshapes() const;
  ::RadialShapes* release_radialshapes();
  ::RadialShapes* mutable_radialshapes();
  void set_allocated_radialshapes(::RadialShapes* radialshapes);

  void clear_shape();
  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:Shape)
 private:
  void set_has_rectangular();
  void set_has_circular();
  void set_has_polygonal();
  void set_has_elliptical();
  void set_has_radial();
  void set_has_radialshapes();

  inline bool has_shape() const;
  inline void clear_has_shape();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ShapeUnion {
    ShapeUnion() {}
    ::RectangularShape* rectangular_;
    ::CircularShape* circular_;
    ::PolygonalShape* polygonal_;
    ::EllipticalShape* elliptical_;
    ::RadialShape* radial_;
    ::RadialShapes* radialshapes_;
  } shape_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Speed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Speed) */ {
 public:
  Speed();
  virtual ~Speed();

  Speed(const Speed& from);

  inline Speed& operator=(const Speed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Speed(Speed&& from) noexcept
    : Speed() {
    *this = ::std::move(from);
  }

  inline Speed& operator=(Speed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Speed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Speed* internal_default_instance() {
    return reinterpret_cast<const Speed*>(
               &_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(Speed* other);
  friend void swap(Speed& a, Speed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Speed* New() const final {
    return CreateMaybeMessage<Speed>(NULL);
  }

  Speed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Speed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Speed& from);
  void MergeFrom(const Speed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Speed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // required uint32 confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 confidence() const;
  void set_confidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Speed)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_confidence();
  void clear_has_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::uint32 confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleIdentification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VehicleIdentification) */ {
 public:
  VehicleIdentification();
  virtual ~VehicleIdentification();

  VehicleIdentification(const VehicleIdentification& from);

  inline VehicleIdentification& operator=(const VehicleIdentification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleIdentification(VehicleIdentification&& from) noexcept
    : VehicleIdentification() {
    *this = ::std::move(from);
  }

  inline VehicleIdentification& operator=(VehicleIdentification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleIdentification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleIdentification* internal_default_instance() {
    return reinterpret_cast<const VehicleIdentification*>(
               &_VehicleIdentification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(VehicleIdentification* other);
  friend void swap(VehicleIdentification& a, VehicleIdentification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleIdentification* New() const final {
    return CreateMaybeMessage<VehicleIdentification>(NULL);
  }

  VehicleIdentification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleIdentification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleIdentification& from);
  void MergeFrom(const VehicleIdentification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleIdentification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string WMInumber = 1;
  bool has_wminumber() const;
  void clear_wminumber();
  static const int kWMInumberFieldNumber = 1;
  const ::std::string& wminumber() const;
  void set_wminumber(const ::std::string& value);
  #if LANG_CXX11
  void set_wminumber(::std::string&& value);
  #endif
  void set_wminumber(const char* value);
  void set_wminumber(const char* value, size_t size);
  ::std::string* mutable_wminumber();
  ::std::string* release_wminumber();
  void set_allocated_wminumber(::std::string* wminumber);

  // optional string VDS = 2;
  bool has_vds() const;
  void clear_vds();
  static const int kVDSFieldNumber = 2;
  const ::std::string& vds() const;
  void set_vds(const ::std::string& value);
  #if LANG_CXX11
  void set_vds(::std::string&& value);
  #endif
  void set_vds(const char* value);
  void set_vds(const char* value, size_t size);
  ::std::string* mutable_vds();
  ::std::string* release_vds();
  void set_allocated_vds(::std::string* vds);

  // @@protoc_insertion_point(class_scope:VehicleIdentification)
 private:
  void set_has_wminumber();
  void clear_has_wminumber();
  void set_has_vds();
  void clear_has_vds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr wminumber_;
  ::google::protobuf::internal::ArenaStringPtr vds_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleLength : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VehicleLength) */ {
 public:
  VehicleLength();
  virtual ~VehicleLength();

  VehicleLength(const VehicleLength& from);

  inline VehicleLength& operator=(const VehicleLength& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleLength(VehicleLength&& from) noexcept
    : VehicleLength() {
    *this = ::std::move(from);
  }

  inline VehicleLength& operator=(VehicleLength&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleLength& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleLength* internal_default_instance() {
    return reinterpret_cast<const VehicleLength*>(
               &_VehicleLength_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(VehicleLength* other);
  friend void swap(VehicleLength& a, VehicleLength& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleLength* New() const final {
    return CreateMaybeMessage<VehicleLength>(NULL);
  }

  VehicleLength* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleLength>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleLength& from);
  void MergeFrom(const VehicleLength& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleLength* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // optional .VehicleLengthConfidenceIndication veh_len_conf_ind = 2;
  bool has_veh_len_conf_ind() const;
  void clear_veh_len_conf_ind();
  static const int kVehLenConfIndFieldNumber = 2;
  ::VehicleLengthConfidenceIndication veh_len_conf_ind() const;
  void set_veh_len_conf_ind(::VehicleLengthConfidenceIndication value);

  // @@protoc_insertion_point(class_scope:VehicleLength)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_veh_len_conf_ind();
  void clear_has_veh_len_conf_ind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  int veh_len_conf_ind_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleWidth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VehicleWidth) */ {
 public:
  VehicleWidth();
  virtual ~VehicleWidth();

  VehicleWidth(const VehicleWidth& from);

  inline VehicleWidth& operator=(const VehicleWidth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleWidth(VehicleWidth&& from) noexcept
    : VehicleWidth() {
    *this = ::std::move(from);
  }

  inline VehicleWidth& operator=(VehicleWidth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleWidth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleWidth* internal_default_instance() {
    return reinterpret_cast<const VehicleWidth*>(
               &_VehicleWidth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(VehicleWidth* other);
  friend void swap(VehicleWidth& a, VehicleWidth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleWidth* New() const final {
    return CreateMaybeMessage<VehicleWidth>(NULL);
  }

  VehicleWidth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleWidth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleWidth& from);
  void MergeFrom(const VehicleWidth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleWidth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:VehicleWidth)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VelocityCartesian : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VelocityCartesian) */ {
 public:
  VelocityCartesian();
  virtual ~VelocityCartesian();

  VelocityCartesian(const VelocityCartesian& from);

  inline VelocityCartesian& operator=(const VelocityCartesian& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VelocityCartesian(VelocityCartesian&& from) noexcept
    : VelocityCartesian() {
    *this = ::std::move(from);
  }

  inline VelocityCartesian& operator=(VelocityCartesian&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VelocityCartesian& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VelocityCartesian* internal_default_instance() {
    return reinterpret_cast<const VelocityCartesian*>(
               &_VelocityCartesian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(VelocityCartesian* other);
  friend void swap(VelocityCartesian& a, VelocityCartesian& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VelocityCartesian* New() const final {
    return CreateMaybeMessage<VelocityCartesian>(NULL);
  }

  VelocityCartesian* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VelocityCartesian>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VelocityCartesian& from);
  void MergeFrom(const VelocityCartesian& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VelocityCartesian* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .VelocityComponent xVelocity = 1;
  bool has_xvelocity() const;
  void clear_xvelocity();
  static const int kXVelocityFieldNumber = 1;
  private:
  const ::VelocityComponent& _internal_xvelocity() const;
  public:
  const ::VelocityComponent& xvelocity() const;
  ::VelocityComponent* release_xvelocity();
  ::VelocityComponent* mutable_xvelocity();
  void set_allocated_xvelocity(::VelocityComponent* xvelocity);

  // required .VelocityComponent yVelocity = 2;
  bool has_yvelocity() const;
  void clear_yvelocity();
  static const int kYVelocityFieldNumber = 2;
  private:
  const ::VelocityComponent& _internal_yvelocity() const;
  public:
  const ::VelocityComponent& yvelocity() const;
  ::VelocityComponent* release_yvelocity();
  ::VelocityComponent* mutable_yvelocity();
  void set_allocated_yvelocity(::VelocityComponent* yvelocity);

  // optional .VelocityComponent zVelocity = 3;
  bool has_zvelocity() const;
  void clear_zvelocity();
  static const int kZVelocityFieldNumber = 3;
  private:
  const ::VelocityComponent& _internal_zvelocity() const;
  public:
  const ::VelocityComponent& zvelocity() const;
  ::VelocityComponent* release_zvelocity();
  ::VelocityComponent* mutable_zvelocity();
  void set_allocated_zvelocity(::VelocityComponent* zvelocity);

  // @@protoc_insertion_point(class_scope:VelocityCartesian)
 private:
  void set_has_xvelocity();
  void clear_has_xvelocity();
  void set_has_yvelocity();
  void clear_has_yvelocity();
  void set_has_zvelocity();
  void clear_has_zvelocity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::VelocityComponent* xvelocity_;
  ::VelocityComponent* yvelocity_;
  ::VelocityComponent* zvelocity_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VelocityComponent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VelocityComponent) */ {
 public:
  VelocityComponent();
  virtual ~VelocityComponent();

  VelocityComponent(const VelocityComponent& from);

  inline VelocityComponent& operator=(const VelocityComponent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VelocityComponent(VelocityComponent&& from) noexcept
    : VelocityComponent() {
    *this = ::std::move(from);
  }

  inline VelocityComponent& operator=(VelocityComponent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VelocityComponent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VelocityComponent* internal_default_instance() {
    return reinterpret_cast<const VelocityComponent*>(
               &_VelocityComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(VelocityComponent* other);
  friend void swap(VelocityComponent& a, VelocityComponent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VelocityComponent* New() const final {
    return CreateMaybeMessage<VelocityComponent>(NULL);
  }

  VelocityComponent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VelocityComponent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VelocityComponent& from);
  void MergeFrom(const VelocityComponent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VelocityComponent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 vel_comp_value = 1;
  bool has_vel_comp_value() const;
  void clear_vel_comp_value();
  static const int kVelCompValueFieldNumber = 1;
  ::google::protobuf::int32 vel_comp_value() const;
  void set_vel_comp_value(::google::protobuf::int32 value);

  // required uint32 speed_confidence = 2;
  bool has_speed_confidence() const;
  void clear_speed_confidence();
  static const int kSpeedConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 speed_confidence() const;
  void set_speed_confidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:VelocityComponent)
 private:
  void set_has_vel_comp_value();
  void clear_has_vel_comp_value();
  void set_has_speed_confidence();
  void clear_has_speed_confidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 vel_comp_value_;
  ::google::protobuf::uint32 speed_confidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VelocityPolarWithZ : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VelocityPolarWithZ) */ {
 public:
  VelocityPolarWithZ();
  virtual ~VelocityPolarWithZ();

  VelocityPolarWithZ(const VelocityPolarWithZ& from);

  inline VelocityPolarWithZ& operator=(const VelocityPolarWithZ& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VelocityPolarWithZ(VelocityPolarWithZ&& from) noexcept
    : VelocityPolarWithZ() {
    *this = ::std::move(from);
  }

  inline VelocityPolarWithZ& operator=(VelocityPolarWithZ&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VelocityPolarWithZ& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VelocityPolarWithZ* internal_default_instance() {
    return reinterpret_cast<const VelocityPolarWithZ*>(
               &_VelocityPolarWithZ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(VelocityPolarWithZ* other);
  friend void swap(VelocityPolarWithZ& a, VelocityPolarWithZ& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VelocityPolarWithZ* New() const final {
    return CreateMaybeMessage<VelocityPolarWithZ>(NULL);
  }

  VelocityPolarWithZ* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VelocityPolarWithZ>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VelocityPolarWithZ& from);
  void MergeFrom(const VelocityPolarWithZ& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VelocityPolarWithZ* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Speed velocityMagnitude = 1;
  bool has_velocitymagnitude() const;
  void clear_velocitymagnitude();
  static const int kVelocityMagnitudeFieldNumber = 1;
  private:
  const ::Speed& _internal_velocitymagnitude() const;
  public:
  const ::Speed& velocitymagnitude() const;
  ::Speed* release_velocitymagnitude();
  ::Speed* mutable_velocitymagnitude();
  void set_allocated_velocitymagnitude(::Speed* velocitymagnitude);

  // required .CartesianAngle velocityDirection = 2;
  bool has_velocitydirection() const;
  void clear_velocitydirection();
  static const int kVelocityDirectionFieldNumber = 2;
  private:
  const ::CartesianAngle& _internal_velocitydirection() const;
  public:
  const ::CartesianAngle& velocitydirection() const;
  ::CartesianAngle* release_velocitydirection();
  ::CartesianAngle* mutable_velocitydirection();
  void set_allocated_velocitydirection(::CartesianAngle* velocitydirection);

  // optional .VelocityComponent zVelocity = 3;
  bool has_zvelocity() const;
  void clear_zvelocity();
  static const int kZVelocityFieldNumber = 3;
  private:
  const ::VelocityComponent& _internal_zvelocity() const;
  public:
  const ::VelocityComponent& zvelocity() const;
  ::VelocityComponent* release_zvelocity();
  ::VelocityComponent* mutable_zvelocity();
  void set_allocated_zvelocity(::VelocityComponent* zvelocity);

  // @@protoc_insertion_point(class_scope:VelocityPolarWithZ)
 private:
  void set_has_velocitymagnitude();
  void clear_has_velocitymagnitude();
  void set_has_velocitydirection();
  void clear_has_velocitydirection();
  void set_has_zvelocity();
  void clear_has_zvelocity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Speed* velocitymagnitude_;
  ::CartesianAngle* velocitydirection_;
  ::VelocityComponent* zvelocity_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Velocity3dWithConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Velocity3dWithConfidence) */ {
 public:
  Velocity3dWithConfidence();
  virtual ~Velocity3dWithConfidence();

  Velocity3dWithConfidence(const Velocity3dWithConfidence& from);

  inline Velocity3dWithConfidence& operator=(const Velocity3dWithConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Velocity3dWithConfidence(Velocity3dWithConfidence&& from) noexcept
    : Velocity3dWithConfidence() {
    *this = ::std::move(from);
  }

  inline Velocity3dWithConfidence& operator=(Velocity3dWithConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Velocity3dWithConfidence& default_instance();

  enum VelocityCase {
    kPolarVelocity = 1,
    kCartesianVelocity = 2,
    VELOCITY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Velocity3dWithConfidence* internal_default_instance() {
    return reinterpret_cast<const Velocity3dWithConfidence*>(
               &_Velocity3dWithConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(Velocity3dWithConfidence* other);
  friend void swap(Velocity3dWithConfidence& a, Velocity3dWithConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Velocity3dWithConfidence* New() const final {
    return CreateMaybeMessage<Velocity3dWithConfidence>(NULL);
  }

  Velocity3dWithConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Velocity3dWithConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Velocity3dWithConfidence& from);
  void MergeFrom(const Velocity3dWithConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Velocity3dWithConfidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .VelocityPolarWithZ polarVelocity = 1;
  bool has_polarvelocity() const;
  void clear_polarvelocity();
  static const int kPolarVelocityFieldNumber = 1;
  private:
  const ::VelocityPolarWithZ& _internal_polarvelocity() const;
  public:
  const ::VelocityPolarWithZ& polarvelocity() const;
  ::VelocityPolarWithZ* release_polarvelocity();
  ::VelocityPolarWithZ* mutable_polarvelocity();
  void set_allocated_polarvelocity(::VelocityPolarWithZ* polarvelocity);

  // optional .VelocityCartesian cartesianVelocity = 2;
  bool has_cartesianvelocity() const;
  void clear_cartesianvelocity();
  static const int kCartesianVelocityFieldNumber = 2;
  private:
  const ::VelocityCartesian& _internal_cartesianvelocity() const;
  public:
  const ::VelocityCartesian& cartesianvelocity() const;
  ::VelocityCartesian* release_cartesianvelocity();
  ::VelocityCartesian* mutable_cartesianvelocity();
  void set_allocated_cartesianvelocity(::VelocityCartesian* cartesianvelocity);

  void clear_velocity();
  VelocityCase velocity_case() const;
  // @@protoc_insertion_point(class_scope:Velocity3dWithConfidence)
 private:
  void set_has_polarvelocity();
  void set_has_cartesianvelocity();

  inline bool has_velocity() const;
  inline void clear_has_velocity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union VelocityUnion {
    VelocityUnion() {}
    ::VelocityPolarWithZ* polarvelocity_;
    ::VelocityCartesian* cartesianvelocity_;
  } velocity_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VruClusterInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VruClusterInformation) */ {
 public:
  VruClusterInformation();
  virtual ~VruClusterInformation();

  VruClusterInformation(const VruClusterInformation& from);

  inline VruClusterInformation& operator=(const VruClusterInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VruClusterInformation(VruClusterInformation&& from) noexcept
    : VruClusterInformation() {
    *this = ::std::move(from);
  }

  inline VruClusterInformation& operator=(VruClusterInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VruClusterInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VruClusterInformation* internal_default_instance() {
    return reinterpret_cast<const VruClusterInformation*>(
               &_VruClusterInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(VruClusterInformation* other);
  friend void swap(VruClusterInformation& a, VruClusterInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VruClusterInformation* New() const final {
    return CreateMaybeMessage<VruClusterInformation>(NULL);
  }

  VruClusterInformation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VruClusterInformation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VruClusterInformation& from);
  void MergeFrom(const VruClusterInformation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VruClusterInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Shape clusterBoundingBoxShape = 2;
  bool has_clusterboundingboxshape() const;
  void clear_clusterboundingboxshape();
  static const int kClusterBoundingBoxShapeFieldNumber = 2;
  private:
  const ::Shape& _internal_clusterboundingboxshape() const;
  public:
  const ::Shape& clusterboundingboxshape() const;
  ::Shape* release_clusterboundingboxshape();
  ::Shape* mutable_clusterboundingboxshape();
  void set_allocated_clusterboundingboxshape(::Shape* clusterboundingboxshape);

  // optional .VruClusterProfiles clusterProfiles = 4;
  bool has_clusterprofiles() const;
  void clear_clusterprofiles();
  static const int kClusterProfilesFieldNumber = 4;
  private:
  const ::VruClusterProfiles& _internal_clusterprofiles() const;
  public:
  const ::VruClusterProfiles& clusterprofiles() const;
  ::VruClusterProfiles* release_clusterprofiles();
  ::VruClusterProfiles* mutable_clusterprofiles();
  void set_allocated_clusterprofiles(::VruClusterProfiles* clusterprofiles);

  // optional uint32 clusterId = 1;
  bool has_clusterid() const;
  void clear_clusterid();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint32 clusterid() const;
  void set_clusterid(::google::protobuf::uint32 value);

  // required uint32 clusterCardinalitySize = 3;
  bool has_clustercardinalitysize() const;
  void clear_clustercardinalitysize();
  static const int kClusterCardinalitySizeFieldNumber = 3;
  ::google::protobuf::uint32 clustercardinalitysize() const;
  void set_clustercardinalitysize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:VruClusterInformation)
 private:
  void set_has_clusterid();
  void clear_has_clusterid();
  void set_has_clusterboundingboxshape();
  void clear_has_clusterboundingboxshape();
  void set_has_clustercardinalitysize();
  void clear_has_clustercardinalitysize();
  void set_has_clusterprofiles();
  void clear_has_clusterprofiles();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Shape* clusterboundingboxshape_;
  ::VruClusterProfiles* clusterprofiles_;
  ::google::protobuf::uint32 clusterid_;
  ::google::protobuf::uint32 clustercardinalitysize_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VruClusterProfiles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VruClusterProfiles) */ {
 public:
  VruClusterProfiles();
  virtual ~VruClusterProfiles();

  VruClusterProfiles(const VruClusterProfiles& from);

  inline VruClusterProfiles& operator=(const VruClusterProfiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VruClusterProfiles(VruClusterProfiles&& from) noexcept
    : VruClusterProfiles() {
    *this = ::std::move(from);
  }

  inline VruClusterProfiles& operator=(VruClusterProfiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VruClusterProfiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VruClusterProfiles* internal_default_instance() {
    return reinterpret_cast<const VruClusterProfiles*>(
               &_VruClusterProfiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(VruClusterProfiles* other);
  friend void swap(VruClusterProfiles& a, VruClusterProfiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VruClusterProfiles* New() const final {
    return CreateMaybeMessage<VruClusterProfiles>(NULL);
  }

  VruClusterProfiles* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VruClusterProfiles>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VruClusterProfiles& from);
  void MergeFrom(const VruClusterProfiles& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VruClusterProfiles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool pedestrian = 1;
  bool has_pedestrian() const;
  void clear_pedestrian();
  static const int kPedestrianFieldNumber = 1;
  bool pedestrian() const;
  void set_pedestrian(bool value);

  // required bool bicyclist = 2;
  bool has_bicyclist() const;
  void clear_bicyclist();
  static const int kBicyclistFieldNumber = 2;
  bool bicyclist() const;
  void set_bicyclist(bool value);

  // required bool motorcyclist = 3;
  bool has_motorcyclist() const;
  void clear_motorcyclist();
  static const int kMotorcyclistFieldNumber = 3;
  bool motorcyclist() const;
  void set_motorcyclist(bool value);

  // required bool animal = 4;
  bool has_animal() const;
  void clear_animal();
  static const int kAnimalFieldNumber = 4;
  bool animal() const;
  void set_animal(bool value);

  // @@protoc_insertion_point(class_scope:VruClusterProfiles)
 private:
  void set_has_pedestrian();
  void clear_has_pedestrian();
  void set_has_bicyclist();
  void clear_has_bicyclist();
  void set_has_motorcyclist();
  void clear_has_motorcyclist();
  void set_has_animal();
  void clear_has_animal();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool pedestrian_;
  bool bicyclist_;
  bool motorcyclist_;
  bool animal_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VruProfileAndSubprofile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VruProfileAndSubprofile) */ {
 public:
  VruProfileAndSubprofile();
  virtual ~VruProfileAndSubprofile();

  VruProfileAndSubprofile(const VruProfileAndSubprofile& from);

  inline VruProfileAndSubprofile& operator=(const VruProfileAndSubprofile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VruProfileAndSubprofile(VruProfileAndSubprofile&& from) noexcept
    : VruProfileAndSubprofile() {
    *this = ::std::move(from);
  }

  inline VruProfileAndSubprofile& operator=(VruProfileAndSubprofile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VruProfileAndSubprofile& default_instance();

  enum VruCase {
    kPedestrian = 1,
    kBicyclistAndLightVruVehicle = 2,
    kMotorcyclist = 3,
    kAnimal = 4,
    VRU_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VruProfileAndSubprofile* internal_default_instance() {
    return reinterpret_cast<const VruProfileAndSubprofile*>(
               &_VruProfileAndSubprofile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(VruProfileAndSubprofile* other);
  friend void swap(VruProfileAndSubprofile& a, VruProfileAndSubprofile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VruProfileAndSubprofile* New() const final {
    return CreateMaybeMessage<VruProfileAndSubprofile>(NULL);
  }

  VruProfileAndSubprofile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VruProfileAndSubprofile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VruProfileAndSubprofile& from);
  void MergeFrom(const VruProfileAndSubprofile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VruProfileAndSubprofile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .VruSubProfilePedestrian pedestrian = 1;
  bool has_pedestrian() const;
  void clear_pedestrian();
  static const int kPedestrianFieldNumber = 1;
  ::VruSubProfilePedestrian pedestrian() const;
  void set_pedestrian(::VruSubProfilePedestrian value);

  // optional .VruSubProfileBicyclist bicyclistAndLightVruVehicle = 2;
  bool has_bicyclistandlightvruvehicle() const;
  void clear_bicyclistandlightvruvehicle();
  static const int kBicyclistAndLightVruVehicleFieldNumber = 2;
  ::VruSubProfileBicyclist bicyclistandlightvruvehicle() const;
  void set_bicyclistandlightvruvehicle(::VruSubProfileBicyclist value);

  // optional .VruSubProfileMotorcyclist motorcyclist = 3;
  bool has_motorcyclist() const;
  void clear_motorcyclist();
  static const int kMotorcyclistFieldNumber = 3;
  ::VruSubProfileMotorcyclist motorcyclist() const;
  void set_motorcyclist(::VruSubProfileMotorcyclist value);

  // optional .VruSubProfileAnimal animal = 4;
  bool has_animal() const;
  void clear_animal();
  static const int kAnimalFieldNumber = 4;
  ::VruSubProfileAnimal animal() const;
  void set_animal(::VruSubProfileAnimal value);

  void clear_vru();
  VruCase vru_case() const;
  // @@protoc_insertion_point(class_scope:VruProfileAndSubprofile)
 private:
  void set_has_pedestrian();
  void set_has_bicyclistandlightvruvehicle();
  void set_has_motorcyclist();
  void set_has_animal();

  inline bool has_vru() const;
  inline void clear_has_vru();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union VruUnion {
    VruUnion() {}
    int pedestrian_;
    int bicyclistandlightvruvehicle_;
    int motorcyclist_;
    int animal_;
  } vru_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Wgs84Angle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Wgs84Angle) */ {
 public:
  Wgs84Angle();
  virtual ~Wgs84Angle();

  Wgs84Angle(const Wgs84Angle& from);

  inline Wgs84Angle& operator=(const Wgs84Angle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Wgs84Angle(Wgs84Angle&& from) noexcept
    : Wgs84Angle() {
    *this = ::std::move(from);
  }

  inline Wgs84Angle& operator=(Wgs84Angle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Wgs84Angle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wgs84Angle* internal_default_instance() {
    return reinterpret_cast<const Wgs84Angle*>(
               &_Wgs84Angle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(Wgs84Angle* other);
  friend void swap(Wgs84Angle& a, Wgs84Angle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Wgs84Angle* New() const final {
    return CreateMaybeMessage<Wgs84Angle>(NULL);
  }

  Wgs84Angle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Wgs84Angle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Wgs84Angle& from);
  void MergeFrom(const Wgs84Angle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wgs84Angle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 wgsAngleValue = 1;
  bool has_wgsanglevalue() const;
  void clear_wgsanglevalue();
  static const int kWgsAngleValueFieldNumber = 1;
  ::google::protobuf::uint32 wgsanglevalue() const;
  void set_wgsanglevalue(::google::protobuf::uint32 value);

  // required uint32 wgs84AngleConfidence = 2;
  bool has_wgs84angleconfidence() const;
  void clear_wgs84angleconfidence();
  static const int kWgs84AngleConfidenceFieldNumber = 2;
  ::google::protobuf::uint32 wgs84angleconfidence() const;
  void set_wgs84angleconfidence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Wgs84Angle)
 private:
  void set_has_wgsanglevalue();
  void clear_has_wgsanglevalue();
  void set_has_wgs84angleconfidence();
  void clear_has_wgs84angleconfidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 wgsanglevalue_;
  ::google::protobuf::uint32 wgs84angleconfidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YawRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:YawRate) */ {
 public:
  YawRate();
  virtual ~YawRate();

  YawRate(const YawRate& from);

  inline YawRate& operator=(const YawRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YawRate(YawRate&& from) noexcept
    : YawRate() {
    *this = ::std::move(from);
  }

  inline YawRate& operator=(YawRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YawRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const YawRate* internal_default_instance() {
    return reinterpret_cast<const YawRate*>(
               &_YawRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(YawRate* other);
  friend void swap(YawRate& a, YawRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YawRate* New() const final {
    return CreateMaybeMessage<YawRate>(NULL);
  }

  YawRate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<YawRate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const YawRate& from);
  void MergeFrom(const YawRate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YawRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 yawratevalue = 1;
  bool has_yawratevalue() const;
  void clear_yawratevalue();
  static const int kYawratevalueFieldNumber = 1;
  ::google::protobuf::int32 yawratevalue() const;
  void set_yawratevalue(::google::protobuf::int32 value);

  // required .YawRateConfidence yawrateconfidence = 2;
  bool has_yawrateconfidence() const;
  void clear_yawrateconfidence();
  static const int kYawrateconfidenceFieldNumber = 2;
  ::YawRateConfidence yawrateconfidence() const;
  void set_yawrateconfidence(::YawRateConfidence value);

  // @@protoc_insertion_point(class_scope:YawRate)
 private:
  void set_has_yawratevalue();
  void clear_has_yawratevalue();
  void set_has_yawrateconfidence();
  void clear_has_yawrateconfidence();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 yawratevalue_;
  int yawrateconfidence_;
  friend struct ::protobuf_etsi_5fits_5fcdd_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Acceleration3dWithConfidence

// optional .AccelerationPolarWithZ polarAcceleration = 1;
inline bool Acceleration3dWithConfidence::has_polaracceleration() const {
  return accelaration_case() == kPolarAcceleration;
}
inline void Acceleration3dWithConfidence::set_has_polaracceleration() {
  _oneof_case_[0] = kPolarAcceleration;
}
inline void Acceleration3dWithConfidence::clear_polaracceleration() {
  if (has_polaracceleration()) {
    delete accelaration_.polaracceleration_;
    clear_has_accelaration();
  }
}
inline const ::AccelerationPolarWithZ& Acceleration3dWithConfidence::_internal_polaracceleration() const {
  return *accelaration_.polaracceleration_;
}
inline ::AccelerationPolarWithZ* Acceleration3dWithConfidence::release_polaracceleration() {
  // @@protoc_insertion_point(field_release:Acceleration3dWithConfidence.polarAcceleration)
  if (has_polaracceleration()) {
    clear_has_accelaration();
      ::AccelerationPolarWithZ* temp = accelaration_.polaracceleration_;
    accelaration_.polaracceleration_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::AccelerationPolarWithZ& Acceleration3dWithConfidence::polaracceleration() const {
  // @@protoc_insertion_point(field_get:Acceleration3dWithConfidence.polarAcceleration)
  return has_polaracceleration()
      ? *accelaration_.polaracceleration_
      : *reinterpret_cast< ::AccelerationPolarWithZ*>(&::_AccelerationPolarWithZ_default_instance_);
}
inline ::AccelerationPolarWithZ* Acceleration3dWithConfidence::mutable_polaracceleration() {
  if (!has_polaracceleration()) {
    clear_accelaration();
    set_has_polaracceleration();
    accelaration_.polaracceleration_ = CreateMaybeMessage< ::AccelerationPolarWithZ >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Acceleration3dWithConfidence.polarAcceleration)
  return accelaration_.polaracceleration_;
}

// optional .AccelerationCartesian cartesianAcceleration = 2;
inline bool Acceleration3dWithConfidence::has_cartesianacceleration() const {
  return accelaration_case() == kCartesianAcceleration;
}
inline void Acceleration3dWithConfidence::set_has_cartesianacceleration() {
  _oneof_case_[0] = kCartesianAcceleration;
}
inline void Acceleration3dWithConfidence::clear_cartesianacceleration() {
  if (has_cartesianacceleration()) {
    delete accelaration_.cartesianacceleration_;
    clear_has_accelaration();
  }
}
inline const ::AccelerationCartesian& Acceleration3dWithConfidence::_internal_cartesianacceleration() const {
  return *accelaration_.cartesianacceleration_;
}
inline ::AccelerationCartesian* Acceleration3dWithConfidence::release_cartesianacceleration() {
  // @@protoc_insertion_point(field_release:Acceleration3dWithConfidence.cartesianAcceleration)
  if (has_cartesianacceleration()) {
    clear_has_accelaration();
      ::AccelerationCartesian* temp = accelaration_.cartesianacceleration_;
    accelaration_.cartesianacceleration_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::AccelerationCartesian& Acceleration3dWithConfidence::cartesianacceleration() const {
  // @@protoc_insertion_point(field_get:Acceleration3dWithConfidence.cartesianAcceleration)
  return has_cartesianacceleration()
      ? *accelaration_.cartesianacceleration_
      : *reinterpret_cast< ::AccelerationCartesian*>(&::_AccelerationCartesian_default_instance_);
}
inline ::AccelerationCartesian* Acceleration3dWithConfidence::mutable_cartesianacceleration() {
  if (!has_cartesianacceleration()) {
    clear_accelaration();
    set_has_cartesianacceleration();
    accelaration_.cartesianacceleration_ = CreateMaybeMessage< ::AccelerationCartesian >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Acceleration3dWithConfidence.cartesianAcceleration)
  return accelaration_.cartesianacceleration_;
}

inline bool Acceleration3dWithConfidence::has_accelaration() const {
  return accelaration_case() != ACCELARATION_NOT_SET;
}
inline void Acceleration3dWithConfidence::clear_has_accelaration() {
  _oneof_case_[0] = ACCELARATION_NOT_SET;
}
inline Acceleration3dWithConfidence::AccelarationCase Acceleration3dWithConfidence::accelaration_case() const {
  return Acceleration3dWithConfidence::AccelarationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AccelerationCartesian

// required .AccelerationComponent xAcceleration = 1;
inline bool AccelerationCartesian::has_xacceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerationCartesian::set_has_xacceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerationCartesian::clear_has_xacceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerationCartesian::clear_xacceleration() {
  if (xacceleration_ != NULL) xacceleration_->Clear();
  clear_has_xacceleration();
}
inline const ::AccelerationComponent& AccelerationCartesian::_internal_xacceleration() const {
  return *xacceleration_;
}
inline const ::AccelerationComponent& AccelerationCartesian::xacceleration() const {
  const ::AccelerationComponent* p = xacceleration_;
  // @@protoc_insertion_point(field_get:AccelerationCartesian.xAcceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::AccelerationComponent*>(
      &::_AccelerationComponent_default_instance_);
}
inline ::AccelerationComponent* AccelerationCartesian::release_xacceleration() {
  // @@protoc_insertion_point(field_release:AccelerationCartesian.xAcceleration)
  clear_has_xacceleration();
  ::AccelerationComponent* temp = xacceleration_;
  xacceleration_ = NULL;
  return temp;
}
inline ::AccelerationComponent* AccelerationCartesian::mutable_xacceleration() {
  set_has_xacceleration();
  if (xacceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::AccelerationComponent>(GetArenaNoVirtual());
    xacceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AccelerationCartesian.xAcceleration)
  return xacceleration_;
}
inline void AccelerationCartesian::set_allocated_xacceleration(::AccelerationComponent* xacceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete xacceleration_;
  }
  if (xacceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      xacceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xacceleration, submessage_arena);
    }
    set_has_xacceleration();
  } else {
    clear_has_xacceleration();
  }
  xacceleration_ = xacceleration;
  // @@protoc_insertion_point(field_set_allocated:AccelerationCartesian.xAcceleration)
}

// required .AccelerationComponent yAcceleration = 2;
inline bool AccelerationCartesian::has_yacceleration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccelerationCartesian::set_has_yacceleration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccelerationCartesian::clear_has_yacceleration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccelerationCartesian::clear_yacceleration() {
  if (yacceleration_ != NULL) yacceleration_->Clear();
  clear_has_yacceleration();
}
inline const ::AccelerationComponent& AccelerationCartesian::_internal_yacceleration() const {
  return *yacceleration_;
}
inline const ::AccelerationComponent& AccelerationCartesian::yacceleration() const {
  const ::AccelerationComponent* p = yacceleration_;
  // @@protoc_insertion_point(field_get:AccelerationCartesian.yAcceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::AccelerationComponent*>(
      &::_AccelerationComponent_default_instance_);
}
inline ::AccelerationComponent* AccelerationCartesian::release_yacceleration() {
  // @@protoc_insertion_point(field_release:AccelerationCartesian.yAcceleration)
  clear_has_yacceleration();
  ::AccelerationComponent* temp = yacceleration_;
  yacceleration_ = NULL;
  return temp;
}
inline ::AccelerationComponent* AccelerationCartesian::mutable_yacceleration() {
  set_has_yacceleration();
  if (yacceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::AccelerationComponent>(GetArenaNoVirtual());
    yacceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AccelerationCartesian.yAcceleration)
  return yacceleration_;
}
inline void AccelerationCartesian::set_allocated_yacceleration(::AccelerationComponent* yacceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete yacceleration_;
  }
  if (yacceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yacceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yacceleration, submessage_arena);
    }
    set_has_yacceleration();
  } else {
    clear_has_yacceleration();
  }
  yacceleration_ = yacceleration;
  // @@protoc_insertion_point(field_set_allocated:AccelerationCartesian.yAcceleration)
}

// optional .AccelerationComponent zAcceleration = 3;
inline bool AccelerationCartesian::has_zacceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccelerationCartesian::set_has_zacceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccelerationCartesian::clear_has_zacceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccelerationCartesian::clear_zacceleration() {
  if (zacceleration_ != NULL) zacceleration_->Clear();
  clear_has_zacceleration();
}
inline const ::AccelerationComponent& AccelerationCartesian::_internal_zacceleration() const {
  return *zacceleration_;
}
inline const ::AccelerationComponent& AccelerationCartesian::zacceleration() const {
  const ::AccelerationComponent* p = zacceleration_;
  // @@protoc_insertion_point(field_get:AccelerationCartesian.zAcceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::AccelerationComponent*>(
      &::_AccelerationComponent_default_instance_);
}
inline ::AccelerationComponent* AccelerationCartesian::release_zacceleration() {
  // @@protoc_insertion_point(field_release:AccelerationCartesian.zAcceleration)
  clear_has_zacceleration();
  ::AccelerationComponent* temp = zacceleration_;
  zacceleration_ = NULL;
  return temp;
}
inline ::AccelerationComponent* AccelerationCartesian::mutable_zacceleration() {
  set_has_zacceleration();
  if (zacceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::AccelerationComponent>(GetArenaNoVirtual());
    zacceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AccelerationCartesian.zAcceleration)
  return zacceleration_;
}
inline void AccelerationCartesian::set_allocated_zacceleration(::AccelerationComponent* zacceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zacceleration_;
  }
  if (zacceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zacceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zacceleration, submessage_arena);
    }
    set_has_zacceleration();
  } else {
    clear_has_zacceleration();
  }
  zacceleration_ = zacceleration;
  // @@protoc_insertion_point(field_set_allocated:AccelerationCartesian.zAcceleration)
}

// -------------------------------------------------------------------

// AccelerationComponent

// required int32 value = 1;
inline bool AccelerationComponent::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerationComponent::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerationComponent::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerationComponent::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 AccelerationComponent::value() const {
  // @@protoc_insertion_point(field_get:AccelerationComponent.value)
  return value_;
}
inline void AccelerationComponent::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:AccelerationComponent.value)
}

// required uint32 confidence = 2;
inline bool AccelerationComponent::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccelerationComponent::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccelerationComponent::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccelerationComponent::clear_confidence() {
  confidence_ = 0u;
  clear_has_confidence();
}
inline ::google::protobuf::uint32 AccelerationComponent::confidence() const {
  // @@protoc_insertion_point(field_get:AccelerationComponent.confidence)
  return confidence_;
}
inline void AccelerationComponent::set_confidence(::google::protobuf::uint32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:AccelerationComponent.confidence)
}

// -------------------------------------------------------------------

// AccelerationMagnitude

// required uint32 accelerationMagnitudeValue = 1;
inline bool AccelerationMagnitude::has_accelerationmagnitudevalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerationMagnitude::set_has_accelerationmagnitudevalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerationMagnitude::clear_has_accelerationmagnitudevalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerationMagnitude::clear_accelerationmagnitudevalue() {
  accelerationmagnitudevalue_ = 0u;
  clear_has_accelerationmagnitudevalue();
}
inline ::google::protobuf::uint32 AccelerationMagnitude::accelerationmagnitudevalue() const {
  // @@protoc_insertion_point(field_get:AccelerationMagnitude.accelerationMagnitudeValue)
  return accelerationmagnitudevalue_;
}
inline void AccelerationMagnitude::set_accelerationmagnitudevalue(::google::protobuf::uint32 value) {
  set_has_accelerationmagnitudevalue();
  accelerationmagnitudevalue_ = value;
  // @@protoc_insertion_point(field_set:AccelerationMagnitude.accelerationMagnitudeValue)
}

// required uint32 accelerationConfidence = 2;
inline bool AccelerationMagnitude::has_accelerationconfidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccelerationMagnitude::set_has_accelerationconfidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccelerationMagnitude::clear_has_accelerationconfidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccelerationMagnitude::clear_accelerationconfidence() {
  accelerationconfidence_ = 0u;
  clear_has_accelerationconfidence();
}
inline ::google::protobuf::uint32 AccelerationMagnitude::accelerationconfidence() const {
  // @@protoc_insertion_point(field_get:AccelerationMagnitude.accelerationConfidence)
  return accelerationconfidence_;
}
inline void AccelerationMagnitude::set_accelerationconfidence(::google::protobuf::uint32 value) {
  set_has_accelerationconfidence();
  accelerationconfidence_ = value;
  // @@protoc_insertion_point(field_set:AccelerationMagnitude.accelerationConfidence)
}

// -------------------------------------------------------------------

// AccelerationPolarWithZ

// required .AccelerationMagnitude accelerationMagnitude = 1;
inline bool AccelerationPolarWithZ::has_accelerationmagnitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerationPolarWithZ::set_has_accelerationmagnitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerationPolarWithZ::clear_has_accelerationmagnitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerationPolarWithZ::clear_accelerationmagnitude() {
  if (accelerationmagnitude_ != NULL) accelerationmagnitude_->Clear();
  clear_has_accelerationmagnitude();
}
inline const ::AccelerationMagnitude& AccelerationPolarWithZ::_internal_accelerationmagnitude() const {
  return *accelerationmagnitude_;
}
inline const ::AccelerationMagnitude& AccelerationPolarWithZ::accelerationmagnitude() const {
  const ::AccelerationMagnitude* p = accelerationmagnitude_;
  // @@protoc_insertion_point(field_get:AccelerationPolarWithZ.accelerationMagnitude)
  return p != NULL ? *p : *reinterpret_cast<const ::AccelerationMagnitude*>(
      &::_AccelerationMagnitude_default_instance_);
}
inline ::AccelerationMagnitude* AccelerationPolarWithZ::release_accelerationmagnitude() {
  // @@protoc_insertion_point(field_release:AccelerationPolarWithZ.accelerationMagnitude)
  clear_has_accelerationmagnitude();
  ::AccelerationMagnitude* temp = accelerationmagnitude_;
  accelerationmagnitude_ = NULL;
  return temp;
}
inline ::AccelerationMagnitude* AccelerationPolarWithZ::mutable_accelerationmagnitude() {
  set_has_accelerationmagnitude();
  if (accelerationmagnitude_ == NULL) {
    auto* p = CreateMaybeMessage<::AccelerationMagnitude>(GetArenaNoVirtual());
    accelerationmagnitude_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AccelerationPolarWithZ.accelerationMagnitude)
  return accelerationmagnitude_;
}
inline void AccelerationPolarWithZ::set_allocated_accelerationmagnitude(::AccelerationMagnitude* accelerationmagnitude) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete accelerationmagnitude_;
  }
  if (accelerationmagnitude) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      accelerationmagnitude = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, accelerationmagnitude, submessage_arena);
    }
    set_has_accelerationmagnitude();
  } else {
    clear_has_accelerationmagnitude();
  }
  accelerationmagnitude_ = accelerationmagnitude;
  // @@protoc_insertion_point(field_set_allocated:AccelerationPolarWithZ.accelerationMagnitude)
}

// required .CartesianAngle accelerationDirection = 2;
inline bool AccelerationPolarWithZ::has_accelerationdirection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccelerationPolarWithZ::set_has_accelerationdirection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccelerationPolarWithZ::clear_has_accelerationdirection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccelerationPolarWithZ::clear_accelerationdirection() {
  if (accelerationdirection_ != NULL) accelerationdirection_->Clear();
  clear_has_accelerationdirection();
}
inline const ::CartesianAngle& AccelerationPolarWithZ::_internal_accelerationdirection() const {
  return *accelerationdirection_;
}
inline const ::CartesianAngle& AccelerationPolarWithZ::accelerationdirection() const {
  const ::CartesianAngle* p = accelerationdirection_;
  // @@protoc_insertion_point(field_get:AccelerationPolarWithZ.accelerationDirection)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianAngle*>(
      &::_CartesianAngle_default_instance_);
}
inline ::CartesianAngle* AccelerationPolarWithZ::release_accelerationdirection() {
  // @@protoc_insertion_point(field_release:AccelerationPolarWithZ.accelerationDirection)
  clear_has_accelerationdirection();
  ::CartesianAngle* temp = accelerationdirection_;
  accelerationdirection_ = NULL;
  return temp;
}
inline ::CartesianAngle* AccelerationPolarWithZ::mutable_accelerationdirection() {
  set_has_accelerationdirection();
  if (accelerationdirection_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianAngle>(GetArenaNoVirtual());
    accelerationdirection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AccelerationPolarWithZ.accelerationDirection)
  return accelerationdirection_;
}
inline void AccelerationPolarWithZ::set_allocated_accelerationdirection(::CartesianAngle* accelerationdirection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete accelerationdirection_;
  }
  if (accelerationdirection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      accelerationdirection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, accelerationdirection, submessage_arena);
    }
    set_has_accelerationdirection();
  } else {
    clear_has_accelerationdirection();
  }
  accelerationdirection_ = accelerationdirection;
  // @@protoc_insertion_point(field_set_allocated:AccelerationPolarWithZ.accelerationDirection)
}

// optional .AccelerationComponent zAcceleration = 3;
inline bool AccelerationPolarWithZ::has_zacceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccelerationPolarWithZ::set_has_zacceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccelerationPolarWithZ::clear_has_zacceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccelerationPolarWithZ::clear_zacceleration() {
  if (zacceleration_ != NULL) zacceleration_->Clear();
  clear_has_zacceleration();
}
inline const ::AccelerationComponent& AccelerationPolarWithZ::_internal_zacceleration() const {
  return *zacceleration_;
}
inline const ::AccelerationComponent& AccelerationPolarWithZ::zacceleration() const {
  const ::AccelerationComponent* p = zacceleration_;
  // @@protoc_insertion_point(field_get:AccelerationPolarWithZ.zAcceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::AccelerationComponent*>(
      &::_AccelerationComponent_default_instance_);
}
inline ::AccelerationComponent* AccelerationPolarWithZ::release_zacceleration() {
  // @@protoc_insertion_point(field_release:AccelerationPolarWithZ.zAcceleration)
  clear_has_zacceleration();
  ::AccelerationComponent* temp = zacceleration_;
  zacceleration_ = NULL;
  return temp;
}
inline ::AccelerationComponent* AccelerationPolarWithZ::mutable_zacceleration() {
  set_has_zacceleration();
  if (zacceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::AccelerationComponent>(GetArenaNoVirtual());
    zacceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AccelerationPolarWithZ.zAcceleration)
  return zacceleration_;
}
inline void AccelerationPolarWithZ::set_allocated_zacceleration(::AccelerationComponent* zacceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zacceleration_;
  }
  if (zacceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zacceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zacceleration, submessage_arena);
    }
    set_has_zacceleration();
  } else {
    clear_has_zacceleration();
  }
  zacceleration_ = zacceleration;
  // @@protoc_insertion_point(field_set_allocated:AccelerationPolarWithZ.zAcceleration)
}

// -------------------------------------------------------------------

// ActionID

// required uint64 originatingStationId = 1;
inline bool ActionID::has_originatingstationid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionID::set_has_originatingstationid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionID::clear_has_originatingstationid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionID::clear_originatingstationid() {
  originatingstationid_ = GOOGLE_ULONGLONG(0);
  clear_has_originatingstationid();
}
inline ::google::protobuf::uint64 ActionID::originatingstationid() const {
  // @@protoc_insertion_point(field_get:ActionID.originatingStationId)
  return originatingstationid_;
}
inline void ActionID::set_originatingstationid(::google::protobuf::uint64 value) {
  set_has_originatingstationid();
  originatingstationid_ = value;
  // @@protoc_insertion_point(field_set:ActionID.originatingStationId)
}

// required uint32 sequenceNumber = 2;
inline bool ActionID::has_sequencenumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionID::set_has_sequencenumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionID::clear_has_sequencenumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionID::clear_sequencenumber() {
  sequencenumber_ = 0u;
  clear_has_sequencenumber();
}
inline ::google::protobuf::uint32 ActionID::sequencenumber() const {
  // @@protoc_insertion_point(field_get:ActionID.sequenceNumber)
  return sequencenumber_;
}
inline void ActionID::set_sequencenumber(::google::protobuf::uint32 value) {
  set_has_sequencenumber();
  sequencenumber_ = value;
  // @@protoc_insertion_point(field_set:ActionID.sequenceNumber)
}

// -------------------------------------------------------------------

// Altitude

// required int32 value = 1;
inline bool Altitude::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Altitude::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Altitude::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Altitude::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Altitude::value() const {
  // @@protoc_insertion_point(field_get:Altitude.value)
  return value_;
}
inline void Altitude::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:Altitude.value)
}

// required uint32 confidence = 2;
inline bool Altitude::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Altitude::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Altitude::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Altitude::clear_confidence() {
  confidence_ = 0u;
  clear_has_confidence();
}
inline ::google::protobuf::uint32 Altitude::confidence() const {
  // @@protoc_insertion_point(field_get:Altitude.confidence)
  return confidence_;
}
inline void Altitude::set_confidence(::google::protobuf::uint32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:Altitude.confidence)
}

// -------------------------------------------------------------------

// CartesianAngle

// required int64 cartesian_value = 1;
inline bool CartesianAngle::has_cartesian_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianAngle::set_has_cartesian_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianAngle::clear_has_cartesian_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianAngle::clear_cartesian_value() {
  cartesian_value_ = GOOGLE_LONGLONG(0);
  clear_has_cartesian_value();
}
inline ::google::protobuf::int64 CartesianAngle::cartesian_value() const {
  // @@protoc_insertion_point(field_get:CartesianAngle.cartesian_value)
  return cartesian_value_;
}
inline void CartesianAngle::set_cartesian_value(::google::protobuf::int64 value) {
  set_has_cartesian_value();
  cartesian_value_ = value;
  // @@protoc_insertion_point(field_set:CartesianAngle.cartesian_value)
}

// required int64 cartesian_angle_confidence = 2;
inline bool CartesianAngle::has_cartesian_angle_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianAngle::set_has_cartesian_angle_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianAngle::clear_has_cartesian_angle_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianAngle::clear_cartesian_angle_confidence() {
  cartesian_angle_confidence_ = GOOGLE_LONGLONG(0);
  clear_has_cartesian_angle_confidence();
}
inline ::google::protobuf::int64 CartesianAngle::cartesian_angle_confidence() const {
  // @@protoc_insertion_point(field_get:CartesianAngle.cartesian_angle_confidence)
  return cartesian_angle_confidence_;
}
inline void CartesianAngle::set_cartesian_angle_confidence(::google::protobuf::int64 value) {
  set_has_cartesian_angle_confidence();
  cartesian_angle_confidence_ = value;
  // @@protoc_insertion_point(field_set:CartesianAngle.cartesian_angle_confidence)
}

// -------------------------------------------------------------------

// CartesianAngularVelocityComponent

// required int32 value = 1;
inline bool CartesianAngularVelocityComponent::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianAngularVelocityComponent::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianAngularVelocityComponent::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianAngularVelocityComponent::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 CartesianAngularVelocityComponent::value() const {
  // @@protoc_insertion_point(field_get:CartesianAngularVelocityComponent.value)
  return value_;
}
inline void CartesianAngularVelocityComponent::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:CartesianAngularVelocityComponent.value)
}

// required .AngularSpeedConfidence confidence = 2;
inline bool CartesianAngularVelocityComponent::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianAngularVelocityComponent::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianAngularVelocityComponent::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianAngularVelocityComponent::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline ::AngularSpeedConfidence CartesianAngularVelocityComponent::confidence() const {
  // @@protoc_insertion_point(field_get:CartesianAngularVelocityComponent.confidence)
  return static_cast< ::AngularSpeedConfidence >(confidence_);
}
inline void CartesianAngularVelocityComponent::set_confidence(::AngularSpeedConfidence value) {
  assert(::AngularSpeedConfidence_IsValid(value));
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:CartesianAngularVelocityComponent.confidence)
}

// -------------------------------------------------------------------

// CartesianPosition3d

// required int32 x_cord = 1;
inline bool CartesianPosition3d::has_x_cord() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianPosition3d::set_has_x_cord() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianPosition3d::clear_has_x_cord() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianPosition3d::clear_x_cord() {
  x_cord_ = 0;
  clear_has_x_cord();
}
inline ::google::protobuf::int32 CartesianPosition3d::x_cord() const {
  // @@protoc_insertion_point(field_get:CartesianPosition3d.x_cord)
  return x_cord_;
}
inline void CartesianPosition3d::set_x_cord(::google::protobuf::int32 value) {
  set_has_x_cord();
  x_cord_ = value;
  // @@protoc_insertion_point(field_set:CartesianPosition3d.x_cord)
}

// required int32 y_cord = 2;
inline bool CartesianPosition3d::has_y_cord() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianPosition3d::set_has_y_cord() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianPosition3d::clear_has_y_cord() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianPosition3d::clear_y_cord() {
  y_cord_ = 0;
  clear_has_y_cord();
}
inline ::google::protobuf::int32 CartesianPosition3d::y_cord() const {
  // @@protoc_insertion_point(field_get:CartesianPosition3d.y_cord)
  return y_cord_;
}
inline void CartesianPosition3d::set_y_cord(::google::protobuf::int32 value) {
  set_has_y_cord();
  y_cord_ = value;
  // @@protoc_insertion_point(field_set:CartesianPosition3d.y_cord)
}

// required int32 z_cord = 3;
inline bool CartesianPosition3d::has_z_cord() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CartesianPosition3d::set_has_z_cord() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CartesianPosition3d::clear_has_z_cord() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CartesianPosition3d::clear_z_cord() {
  z_cord_ = 0;
  clear_has_z_cord();
}
inline ::google::protobuf::int32 CartesianPosition3d::z_cord() const {
  // @@protoc_insertion_point(field_get:CartesianPosition3d.z_cord)
  return z_cord_;
}
inline void CartesianPosition3d::set_z_cord(::google::protobuf::int32 value) {
  set_has_z_cord();
  z_cord_ = value;
  // @@protoc_insertion_point(field_set:CartesianPosition3d.z_cord)
}

// -------------------------------------------------------------------

// CartesianCoordinateWithConfidence

// required int32 value = 1;
inline bool CartesianCoordinateWithConfidence::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianCoordinateWithConfidence::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianCoordinateWithConfidence::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianCoordinateWithConfidence::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 CartesianCoordinateWithConfidence::value() const {
  // @@protoc_insertion_point(field_get:CartesianCoordinateWithConfidence.value)
  return value_;
}
inline void CartesianCoordinateWithConfidence::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:CartesianCoordinateWithConfidence.value)
}

// required uint32 confidence = 2;
inline bool CartesianCoordinateWithConfidence::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianCoordinateWithConfidence::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianCoordinateWithConfidence::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianCoordinateWithConfidence::clear_confidence() {
  confidence_ = 0u;
  clear_has_confidence();
}
inline ::google::protobuf::uint32 CartesianCoordinateWithConfidence::confidence() const {
  // @@protoc_insertion_point(field_get:CartesianCoordinateWithConfidence.confidence)
  return confidence_;
}
inline void CartesianCoordinateWithConfidence::set_confidence(::google::protobuf::uint32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:CartesianCoordinateWithConfidence.confidence)
}

// -------------------------------------------------------------------

// CartesianPosition3dWithConfidence

// required .CartesianCoordinateWithConfidence x_cord = 1;
inline bool CartesianPosition3dWithConfidence::has_x_cord() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianPosition3dWithConfidence::set_has_x_cord() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianPosition3dWithConfidence::clear_has_x_cord() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianPosition3dWithConfidence::clear_x_cord() {
  if (x_cord_ != NULL) x_cord_->Clear();
  clear_has_x_cord();
}
inline const ::CartesianCoordinateWithConfidence& CartesianPosition3dWithConfidence::_internal_x_cord() const {
  return *x_cord_;
}
inline const ::CartesianCoordinateWithConfidence& CartesianPosition3dWithConfidence::x_cord() const {
  const ::CartesianCoordinateWithConfidence* p = x_cord_;
  // @@protoc_insertion_point(field_get:CartesianPosition3dWithConfidence.x_cord)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianCoordinateWithConfidence*>(
      &::_CartesianCoordinateWithConfidence_default_instance_);
}
inline ::CartesianCoordinateWithConfidence* CartesianPosition3dWithConfidence::release_x_cord() {
  // @@protoc_insertion_point(field_release:CartesianPosition3dWithConfidence.x_cord)
  clear_has_x_cord();
  ::CartesianCoordinateWithConfidence* temp = x_cord_;
  x_cord_ = NULL;
  return temp;
}
inline ::CartesianCoordinateWithConfidence* CartesianPosition3dWithConfidence::mutable_x_cord() {
  set_has_x_cord();
  if (x_cord_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianCoordinateWithConfidence>(GetArenaNoVirtual());
    x_cord_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CartesianPosition3dWithConfidence.x_cord)
  return x_cord_;
}
inline void CartesianPosition3dWithConfidence::set_allocated_x_cord(::CartesianCoordinateWithConfidence* x_cord) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete x_cord_;
  }
  if (x_cord) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      x_cord = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, x_cord, submessage_arena);
    }
    set_has_x_cord();
  } else {
    clear_has_x_cord();
  }
  x_cord_ = x_cord;
  // @@protoc_insertion_point(field_set_allocated:CartesianPosition3dWithConfidence.x_cord)
}

// required .CartesianCoordinateWithConfidence y_cord = 2;
inline bool CartesianPosition3dWithConfidence::has_y_cord() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianPosition3dWithConfidence::set_has_y_cord() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianPosition3dWithConfidence::clear_has_y_cord() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianPosition3dWithConfidence::clear_y_cord() {
  if (y_cord_ != NULL) y_cord_->Clear();
  clear_has_y_cord();
}
inline const ::CartesianCoordinateWithConfidence& CartesianPosition3dWithConfidence::_internal_y_cord() const {
  return *y_cord_;
}
inline const ::CartesianCoordinateWithConfidence& CartesianPosition3dWithConfidence::y_cord() const {
  const ::CartesianCoordinateWithConfidence* p = y_cord_;
  // @@protoc_insertion_point(field_get:CartesianPosition3dWithConfidence.y_cord)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianCoordinateWithConfidence*>(
      &::_CartesianCoordinateWithConfidence_default_instance_);
}
inline ::CartesianCoordinateWithConfidence* CartesianPosition3dWithConfidence::release_y_cord() {
  // @@protoc_insertion_point(field_release:CartesianPosition3dWithConfidence.y_cord)
  clear_has_y_cord();
  ::CartesianCoordinateWithConfidence* temp = y_cord_;
  y_cord_ = NULL;
  return temp;
}
inline ::CartesianCoordinateWithConfidence* CartesianPosition3dWithConfidence::mutable_y_cord() {
  set_has_y_cord();
  if (y_cord_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianCoordinateWithConfidence>(GetArenaNoVirtual());
    y_cord_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CartesianPosition3dWithConfidence.y_cord)
  return y_cord_;
}
inline void CartesianPosition3dWithConfidence::set_allocated_y_cord(::CartesianCoordinateWithConfidence* y_cord) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete y_cord_;
  }
  if (y_cord) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      y_cord = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, y_cord, submessage_arena);
    }
    set_has_y_cord();
  } else {
    clear_has_y_cord();
  }
  y_cord_ = y_cord;
  // @@protoc_insertion_point(field_set_allocated:CartesianPosition3dWithConfidence.y_cord)
}

// optional .CartesianCoordinateWithConfidence z_cord = 3;
inline bool CartesianPosition3dWithConfidence::has_z_cord() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CartesianPosition3dWithConfidence::set_has_z_cord() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CartesianPosition3dWithConfidence::clear_has_z_cord() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CartesianPosition3dWithConfidence::clear_z_cord() {
  if (z_cord_ != NULL) z_cord_->Clear();
  clear_has_z_cord();
}
inline const ::CartesianCoordinateWithConfidence& CartesianPosition3dWithConfidence::_internal_z_cord() const {
  return *z_cord_;
}
inline const ::CartesianCoordinateWithConfidence& CartesianPosition3dWithConfidence::z_cord() const {
  const ::CartesianCoordinateWithConfidence* p = z_cord_;
  // @@protoc_insertion_point(field_get:CartesianPosition3dWithConfidence.z_cord)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianCoordinateWithConfidence*>(
      &::_CartesianCoordinateWithConfidence_default_instance_);
}
inline ::CartesianCoordinateWithConfidence* CartesianPosition3dWithConfidence::release_z_cord() {
  // @@protoc_insertion_point(field_release:CartesianPosition3dWithConfidence.z_cord)
  clear_has_z_cord();
  ::CartesianCoordinateWithConfidence* temp = z_cord_;
  z_cord_ = NULL;
  return temp;
}
inline ::CartesianCoordinateWithConfidence* CartesianPosition3dWithConfidence::mutable_z_cord() {
  set_has_z_cord();
  if (z_cord_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianCoordinateWithConfidence>(GetArenaNoVirtual());
    z_cord_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CartesianPosition3dWithConfidence.z_cord)
  return z_cord_;
}
inline void CartesianPosition3dWithConfidence::set_allocated_z_cord(::CartesianCoordinateWithConfidence* z_cord) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete z_cord_;
  }
  if (z_cord) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      z_cord = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, z_cord, submessage_arena);
    }
    set_has_z_cord();
  } else {
    clear_has_z_cord();
  }
  z_cord_ = z_cord;
  // @@protoc_insertion_point(field_set_allocated:CartesianPosition3dWithConfidence.z_cord)
}

// -------------------------------------------------------------------

// CircularShape

// optional .CartesianPosition3d shapeRefPoint = 1;
inline bool CircularShape::has_shaperefpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CircularShape::set_has_shaperefpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CircularShape::clear_has_shaperefpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CircularShape::clear_shaperefpoint() {
  if (shaperefpoint_ != NULL) shaperefpoint_->Clear();
  clear_has_shaperefpoint();
}
inline const ::CartesianPosition3d& CircularShape::_internal_shaperefpoint() const {
  return *shaperefpoint_;
}
inline const ::CartesianPosition3d& CircularShape::shaperefpoint() const {
  const ::CartesianPosition3d* p = shaperefpoint_;
  // @@protoc_insertion_point(field_get:CircularShape.shapeRefPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianPosition3d*>(
      &::_CartesianPosition3d_default_instance_);
}
inline ::CartesianPosition3d* CircularShape::release_shaperefpoint() {
  // @@protoc_insertion_point(field_release:CircularShape.shapeRefPoint)
  clear_has_shaperefpoint();
  ::CartesianPosition3d* temp = shaperefpoint_;
  shaperefpoint_ = NULL;
  return temp;
}
inline ::CartesianPosition3d* CircularShape::mutable_shaperefpoint() {
  set_has_shaperefpoint();
  if (shaperefpoint_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianPosition3d>(GetArenaNoVirtual());
    shaperefpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CircularShape.shapeRefPoint)
  return shaperefpoint_;
}
inline void CircularShape::set_allocated_shaperefpoint(::CartesianPosition3d* shaperefpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shaperefpoint_;
  }
  if (shaperefpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shaperefpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shaperefpoint, submessage_arena);
    }
    set_has_shaperefpoint();
  } else {
    clear_has_shaperefpoint();
  }
  shaperefpoint_ = shaperefpoint;
  // @@protoc_insertion_point(field_set_allocated:CircularShape.shapeRefPoint)
}

// required int32 radius = 2;
inline bool CircularShape::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CircularShape::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CircularShape::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CircularShape::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline ::google::protobuf::int32 CircularShape::radius() const {
  // @@protoc_insertion_point(field_get:CircularShape.radius)
  return radius_;
}
inline void CircularShape::set_radius(::google::protobuf::int32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:CircularShape.radius)
}

// optional uint32 height = 3;
inline bool CircularShape::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CircularShape::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CircularShape::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CircularShape::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 CircularShape::height() const {
  // @@protoc_insertion_point(field_get:CircularShape.height)
  return height_;
}
inline void CircularShape::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CircularShape.height)
}

// -------------------------------------------------------------------

// ClosedLanes

// optional .HardShoulderStatus innerhardShoulderStatus = 1;
inline bool ClosedLanes::has_innerhardshoulderstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClosedLanes::set_has_innerhardshoulderstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClosedLanes::clear_has_innerhardshoulderstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClosedLanes::clear_innerhardshoulderstatus() {
  innerhardshoulderstatus_ = 0;
  clear_has_innerhardshoulderstatus();
}
inline ::HardShoulderStatus ClosedLanes::innerhardshoulderstatus() const {
  // @@protoc_insertion_point(field_get:ClosedLanes.innerhardShoulderStatus)
  return static_cast< ::HardShoulderStatus >(innerhardshoulderstatus_);
}
inline void ClosedLanes::set_innerhardshoulderstatus(::HardShoulderStatus value) {
  assert(::HardShoulderStatus_IsValid(value));
  set_has_innerhardshoulderstatus();
  innerhardshoulderstatus_ = value;
  // @@protoc_insertion_point(field_set:ClosedLanes.innerhardShoulderStatus)
}

// optional .HardShoulderStatus outerhardShoulderStatus = 2;
inline bool ClosedLanes::has_outerhardshoulderstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClosedLanes::set_has_outerhardshoulderstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClosedLanes::clear_has_outerhardshoulderstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClosedLanes::clear_outerhardshoulderstatus() {
  outerhardshoulderstatus_ = 0;
  clear_has_outerhardshoulderstatus();
}
inline ::HardShoulderStatus ClosedLanes::outerhardshoulderstatus() const {
  // @@protoc_insertion_point(field_get:ClosedLanes.outerhardShoulderStatus)
  return static_cast< ::HardShoulderStatus >(outerhardshoulderstatus_);
}
inline void ClosedLanes::set_outerhardshoulderstatus(::HardShoulderStatus value) {
  assert(::HardShoulderStatus_IsValid(value));
  set_has_outerhardshoulderstatus();
  outerhardshoulderstatus_ = value;
  // @@protoc_insertion_point(field_set:ClosedLanes.outerhardShoulderStatus)
}

// optional uint32 drivingLaneStatus = 3;
inline bool ClosedLanes::has_drivinglanestatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClosedLanes::set_has_drivinglanestatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClosedLanes::clear_has_drivinglanestatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClosedLanes::clear_drivinglanestatus() {
  drivinglanestatus_ = 0u;
  clear_has_drivinglanestatus();
}
inline ::google::protobuf::uint32 ClosedLanes::drivinglanestatus() const {
  // @@protoc_insertion_point(field_get:ClosedLanes.drivingLaneStatus)
  return drivinglanestatus_;
}
inline void ClosedLanes::set_drivinglanestatus(::google::protobuf::uint32 value) {
  set_has_drivinglanestatus();
  drivinglanestatus_ = value;
  // @@protoc_insertion_point(field_set:ClosedLanes.drivingLaneStatus)
}

// -------------------------------------------------------------------

// CorrelationColumn

// repeated int32 value = 1;
inline int CorrelationColumn::value_size() const {
  return value_.size();
}
inline void CorrelationColumn::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int32 CorrelationColumn::value(int index) const {
  // @@protoc_insertion_point(field_get:CorrelationColumn.value)
  return value_.Get(index);
}
inline void CorrelationColumn::set_value(int index, ::google::protobuf::int32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:CorrelationColumn.value)
}
inline void CorrelationColumn::add_value(::google::protobuf::int32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:CorrelationColumn.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CorrelationColumn::value() const {
  // @@protoc_insertion_point(field_list:CorrelationColumn.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CorrelationColumn::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:CorrelationColumn.value)
  return &value_;
}

// -------------------------------------------------------------------

// Curvature

// required int32 value = 1;
inline bool Curvature::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Curvature::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Curvature::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Curvature::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Curvature::value() const {
  // @@protoc_insertion_point(field_get:Curvature.value)
  return value_;
}
inline void Curvature::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:Curvature.value)
}

// optional int32 confidence = 2;
inline bool Curvature::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Curvature::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Curvature::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Curvature::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline ::google::protobuf::int32 Curvature::confidence() const {
  // @@protoc_insertion_point(field_get:Curvature.confidence)
  return confidence_;
}
inline void Curvature::set_confidence(::google::protobuf::int32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:Curvature.confidence)
}

// -------------------------------------------------------------------

// CauseCode

// required .CauseCodeType causeCode = 1;
inline bool CauseCode::has_causecode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CauseCode::set_has_causecode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CauseCode::clear_has_causecode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CauseCode::clear_causecode() {
  causecode_ = 1;
  clear_has_causecode();
}
inline ::CauseCodeType CauseCode::causecode() const {
  // @@protoc_insertion_point(field_get:CauseCode.causeCode)
  return static_cast< ::CauseCodeType >(causecode_);
}
inline void CauseCode::set_causecode(::CauseCodeType value) {
  assert(::CauseCodeType_IsValid(value));
  set_has_causecode();
  causecode_ = value;
  // @@protoc_insertion_point(field_set:CauseCode.causeCode)
}

// required uint32 subCauseCode = 2;
inline bool CauseCode::has_subcausecode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CauseCode::set_has_subcausecode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CauseCode::clear_has_subcausecode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CauseCode::clear_subcausecode() {
  subcausecode_ = 0u;
  clear_has_subcausecode();
}
inline ::google::protobuf::uint32 CauseCode::subcausecode() const {
  // @@protoc_insertion_point(field_get:CauseCode.subCauseCode)
  return subcausecode_;
}
inline void CauseCode::set_subcausecode(::google::protobuf::uint32 value) {
  set_has_subcausecode();
  subcausecode_ = value;
  // @@protoc_insertion_point(field_set:CauseCode.subCauseCode)
}

// -------------------------------------------------------------------

// DangerousGoodsExtended

// required .DangerousGoodsBasic dangerousGoodsType = 1;
inline bool DangerousGoodsExtended::has_dangerousgoodstype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DangerousGoodsExtended::set_has_dangerousgoodstype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DangerousGoodsExtended::clear_has_dangerousgoodstype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DangerousGoodsExtended::clear_dangerousgoodstype() {
  dangerousgoodstype_ = 0;
  clear_has_dangerousgoodstype();
}
inline ::DangerousGoodsBasic DangerousGoodsExtended::dangerousgoodstype() const {
  // @@protoc_insertion_point(field_get:DangerousGoodsExtended.dangerousGoodsType)
  return static_cast< ::DangerousGoodsBasic >(dangerousgoodstype_);
}
inline void DangerousGoodsExtended::set_dangerousgoodstype(::DangerousGoodsBasic value) {
  assert(::DangerousGoodsBasic_IsValid(value));
  set_has_dangerousgoodstype();
  dangerousgoodstype_ = value;
  // @@protoc_insertion_point(field_set:DangerousGoodsExtended.dangerousGoodsType)
}

// required uint32 unNumber = 2;
inline bool DangerousGoodsExtended::has_unnumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DangerousGoodsExtended::set_has_unnumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DangerousGoodsExtended::clear_has_unnumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DangerousGoodsExtended::clear_unnumber() {
  unnumber_ = 0u;
  clear_has_unnumber();
}
inline ::google::protobuf::uint32 DangerousGoodsExtended::unnumber() const {
  // @@protoc_insertion_point(field_get:DangerousGoodsExtended.unNumber)
  return unnumber_;
}
inline void DangerousGoodsExtended::set_unnumber(::google::protobuf::uint32 value) {
  set_has_unnumber();
  unnumber_ = value;
  // @@protoc_insertion_point(field_set:DangerousGoodsExtended.unNumber)
}

// required bool elevatedTemperature = 3;
inline bool DangerousGoodsExtended::has_elevatedtemperature() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DangerousGoodsExtended::set_has_elevatedtemperature() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DangerousGoodsExtended::clear_has_elevatedtemperature() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DangerousGoodsExtended::clear_elevatedtemperature() {
  elevatedtemperature_ = false;
  clear_has_elevatedtemperature();
}
inline bool DangerousGoodsExtended::elevatedtemperature() const {
  // @@protoc_insertion_point(field_get:DangerousGoodsExtended.elevatedTemperature)
  return elevatedtemperature_;
}
inline void DangerousGoodsExtended::set_elevatedtemperature(bool value) {
  set_has_elevatedtemperature();
  elevatedtemperature_ = value;
  // @@protoc_insertion_point(field_set:DangerousGoodsExtended.elevatedTemperature)
}

// required bool tunnelsRestricted = 4;
inline bool DangerousGoodsExtended::has_tunnelsrestricted() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DangerousGoodsExtended::set_has_tunnelsrestricted() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DangerousGoodsExtended::clear_has_tunnelsrestricted() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DangerousGoodsExtended::clear_tunnelsrestricted() {
  tunnelsrestricted_ = false;
  clear_has_tunnelsrestricted();
}
inline bool DangerousGoodsExtended::tunnelsrestricted() const {
  // @@protoc_insertion_point(field_get:DangerousGoodsExtended.tunnelsRestricted)
  return tunnelsrestricted_;
}
inline void DangerousGoodsExtended::set_tunnelsrestricted(bool value) {
  set_has_tunnelsrestricted();
  tunnelsrestricted_ = value;
  // @@protoc_insertion_point(field_set:DangerousGoodsExtended.tunnelsRestricted)
}

// required bool limitedQuantity = 5;
inline bool DangerousGoodsExtended::has_limitedquantity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DangerousGoodsExtended::set_has_limitedquantity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DangerousGoodsExtended::clear_has_limitedquantity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DangerousGoodsExtended::clear_limitedquantity() {
  limitedquantity_ = false;
  clear_has_limitedquantity();
}
inline bool DangerousGoodsExtended::limitedquantity() const {
  // @@protoc_insertion_point(field_get:DangerousGoodsExtended.limitedQuantity)
  return limitedquantity_;
}
inline void DangerousGoodsExtended::set_limitedquantity(bool value) {
  set_has_limitedquantity();
  limitedquantity_ = value;
  // @@protoc_insertion_point(field_set:DangerousGoodsExtended.limitedQuantity)
}

// optional string emergencyActionCode = 6;
inline bool DangerousGoodsExtended::has_emergencyactioncode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DangerousGoodsExtended::set_has_emergencyactioncode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DangerousGoodsExtended::clear_has_emergencyactioncode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DangerousGoodsExtended::clear_emergencyactioncode() {
  emergencyactioncode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_emergencyactioncode();
}
inline const ::std::string& DangerousGoodsExtended::emergencyactioncode() const {
  // @@protoc_insertion_point(field_get:DangerousGoodsExtended.emergencyActionCode)
  return emergencyactioncode_.GetNoArena();
}
inline void DangerousGoodsExtended::set_emergencyactioncode(const ::std::string& value) {
  set_has_emergencyactioncode();
  emergencyactioncode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DangerousGoodsExtended.emergencyActionCode)
}
#if LANG_CXX11
inline void DangerousGoodsExtended::set_emergencyactioncode(::std::string&& value) {
  set_has_emergencyactioncode();
  emergencyactioncode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DangerousGoodsExtended.emergencyActionCode)
}
#endif
inline void DangerousGoodsExtended::set_emergencyactioncode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_emergencyactioncode();
  emergencyactioncode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DangerousGoodsExtended.emergencyActionCode)
}
inline void DangerousGoodsExtended::set_emergencyactioncode(const char* value, size_t size) {
  set_has_emergencyactioncode();
  emergencyactioncode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DangerousGoodsExtended.emergencyActionCode)
}
inline ::std::string* DangerousGoodsExtended::mutable_emergencyactioncode() {
  set_has_emergencyactioncode();
  // @@protoc_insertion_point(field_mutable:DangerousGoodsExtended.emergencyActionCode)
  return emergencyactioncode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DangerousGoodsExtended::release_emergencyactioncode() {
  // @@protoc_insertion_point(field_release:DangerousGoodsExtended.emergencyActionCode)
  if (!has_emergencyactioncode()) {
    return NULL;
  }
  clear_has_emergencyactioncode();
  return emergencyactioncode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DangerousGoodsExtended::set_allocated_emergencyactioncode(::std::string* emergencyactioncode) {
  if (emergencyactioncode != NULL) {
    set_has_emergencyactioncode();
  } else {
    clear_has_emergencyactioncode();
  }
  emergencyactioncode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), emergencyactioncode);
  // @@protoc_insertion_point(field_set_allocated:DangerousGoodsExtended.emergencyActionCode)
}

// optional string phoneNumber = 7;
inline bool DangerousGoodsExtended::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DangerousGoodsExtended::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DangerousGoodsExtended::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DangerousGoodsExtended::clear_phonenumber() {
  phonenumber_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_phonenumber();
}
inline const ::std::string& DangerousGoodsExtended::phonenumber() const {
  // @@protoc_insertion_point(field_get:DangerousGoodsExtended.phoneNumber)
  return phonenumber_.GetNoArena();
}
inline void DangerousGoodsExtended::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  phonenumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DangerousGoodsExtended.phoneNumber)
}
#if LANG_CXX11
inline void DangerousGoodsExtended::set_phonenumber(::std::string&& value) {
  set_has_phonenumber();
  phonenumber_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DangerousGoodsExtended.phoneNumber)
}
#endif
inline void DangerousGoodsExtended::set_phonenumber(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_phonenumber();
  phonenumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DangerousGoodsExtended.phoneNumber)
}
inline void DangerousGoodsExtended::set_phonenumber(const char* value, size_t size) {
  set_has_phonenumber();
  phonenumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DangerousGoodsExtended.phoneNumber)
}
inline ::std::string* DangerousGoodsExtended::mutable_phonenumber() {
  set_has_phonenumber();
  // @@protoc_insertion_point(field_mutable:DangerousGoodsExtended.phoneNumber)
  return phonenumber_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DangerousGoodsExtended::release_phonenumber() {
  // @@protoc_insertion_point(field_release:DangerousGoodsExtended.phoneNumber)
  if (!has_phonenumber()) {
    return NULL;
  }
  clear_has_phonenumber();
  return phonenumber_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DangerousGoodsExtended::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber != NULL) {
    set_has_phonenumber();
  } else {
    clear_has_phonenumber();
  }
  phonenumber_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phonenumber);
  // @@protoc_insertion_point(field_set_allocated:DangerousGoodsExtended.phoneNumber)
}

// optional string companyName = 8;
inline bool DangerousGoodsExtended::has_companyname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DangerousGoodsExtended::set_has_companyname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DangerousGoodsExtended::clear_has_companyname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DangerousGoodsExtended::clear_companyname() {
  companyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_companyname();
}
inline const ::std::string& DangerousGoodsExtended::companyname() const {
  // @@protoc_insertion_point(field_get:DangerousGoodsExtended.companyName)
  return companyname_.GetNoArena();
}
inline void DangerousGoodsExtended::set_companyname(const ::std::string& value) {
  set_has_companyname();
  companyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DangerousGoodsExtended.companyName)
}
#if LANG_CXX11
inline void DangerousGoodsExtended::set_companyname(::std::string&& value) {
  set_has_companyname();
  companyname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DangerousGoodsExtended.companyName)
}
#endif
inline void DangerousGoodsExtended::set_companyname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_companyname();
  companyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DangerousGoodsExtended.companyName)
}
inline void DangerousGoodsExtended::set_companyname(const char* value, size_t size) {
  set_has_companyname();
  companyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DangerousGoodsExtended.companyName)
}
inline ::std::string* DangerousGoodsExtended::mutable_companyname() {
  set_has_companyname();
  // @@protoc_insertion_point(field_mutable:DangerousGoodsExtended.companyName)
  return companyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DangerousGoodsExtended::release_companyname() {
  // @@protoc_insertion_point(field_release:DangerousGoodsExtended.companyName)
  if (!has_companyname()) {
    return NULL;
  }
  clear_has_companyname();
  return companyname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DangerousGoodsExtended::set_allocated_companyname(::std::string* companyname) {
  if (companyname != NULL) {
    set_has_companyname();
  } else {
    clear_has_companyname();
  }
  companyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), companyname);
  // @@protoc_insertion_point(field_set_allocated:DangerousGoodsExtended.companyName)
}

// -------------------------------------------------------------------

// DeltaReferencePosition

// required int32 deltaLatitude = 1;
inline bool DeltaReferencePosition::has_deltalatitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeltaReferencePosition::set_has_deltalatitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeltaReferencePosition::clear_has_deltalatitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeltaReferencePosition::clear_deltalatitude() {
  deltalatitude_ = 0;
  clear_has_deltalatitude();
}
inline ::google::protobuf::int32 DeltaReferencePosition::deltalatitude() const {
  // @@protoc_insertion_point(field_get:DeltaReferencePosition.deltaLatitude)
  return deltalatitude_;
}
inline void DeltaReferencePosition::set_deltalatitude(::google::protobuf::int32 value) {
  set_has_deltalatitude();
  deltalatitude_ = value;
  // @@protoc_insertion_point(field_set:DeltaReferencePosition.deltaLatitude)
}

// required int32 deltaLongitude = 2;
inline bool DeltaReferencePosition::has_deltalongitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeltaReferencePosition::set_has_deltalongitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeltaReferencePosition::clear_has_deltalongitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeltaReferencePosition::clear_deltalongitude() {
  deltalongitude_ = 0;
  clear_has_deltalongitude();
}
inline ::google::protobuf::int32 DeltaReferencePosition::deltalongitude() const {
  // @@protoc_insertion_point(field_get:DeltaReferencePosition.deltaLongitude)
  return deltalongitude_;
}
inline void DeltaReferencePosition::set_deltalongitude(::google::protobuf::int32 value) {
  set_has_deltalongitude();
  deltalongitude_ = value;
  // @@protoc_insertion_point(field_set:DeltaReferencePosition.deltaLongitude)
}

// required int32 deltaAltitude = 3;
inline bool DeltaReferencePosition::has_deltaaltitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeltaReferencePosition::set_has_deltaaltitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeltaReferencePosition::clear_has_deltaaltitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeltaReferencePosition::clear_deltaaltitude() {
  deltaaltitude_ = 0;
  clear_has_deltaaltitude();
}
inline ::google::protobuf::int32 DeltaReferencePosition::deltaaltitude() const {
  // @@protoc_insertion_point(field_get:DeltaReferencePosition.deltaAltitude)
  return deltaaltitude_;
}
inline void DeltaReferencePosition::set_deltaaltitude(::google::protobuf::int32 value) {
  set_has_deltaaltitude();
  deltaaltitude_ = value;
  // @@protoc_insertion_point(field_set:DeltaReferencePosition.deltaAltitude)
}

// -------------------------------------------------------------------

// EnergyStorageType

// required bool hydrogenStorage = 1;
inline bool EnergyStorageType::has_hydrogenstorage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnergyStorageType::set_has_hydrogenstorage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnergyStorageType::clear_has_hydrogenstorage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnergyStorageType::clear_hydrogenstorage() {
  hydrogenstorage_ = false;
  clear_has_hydrogenstorage();
}
inline bool EnergyStorageType::hydrogenstorage() const {
  // @@protoc_insertion_point(field_get:EnergyStorageType.hydrogenStorage)
  return hydrogenstorage_;
}
inline void EnergyStorageType::set_hydrogenstorage(bool value) {
  set_has_hydrogenstorage();
  hydrogenstorage_ = value;
  // @@protoc_insertion_point(field_set:EnergyStorageType.hydrogenStorage)
}

// required bool electricEnergyStorage = 2;
inline bool EnergyStorageType::has_electricenergystorage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnergyStorageType::set_has_electricenergystorage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnergyStorageType::clear_has_electricenergystorage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnergyStorageType::clear_electricenergystorage() {
  electricenergystorage_ = false;
  clear_has_electricenergystorage();
}
inline bool EnergyStorageType::electricenergystorage() const {
  // @@protoc_insertion_point(field_get:EnergyStorageType.electricEnergyStorage)
  return electricenergystorage_;
}
inline void EnergyStorageType::set_electricenergystorage(bool value) {
  set_has_electricenergystorage();
  electricenergystorage_ = value;
  // @@protoc_insertion_point(field_set:EnergyStorageType.electricEnergyStorage)
}

// required bool liquidPropaneGas = 3;
inline bool EnergyStorageType::has_liquidpropanegas() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnergyStorageType::set_has_liquidpropanegas() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnergyStorageType::clear_has_liquidpropanegas() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnergyStorageType::clear_liquidpropanegas() {
  liquidpropanegas_ = false;
  clear_has_liquidpropanegas();
}
inline bool EnergyStorageType::liquidpropanegas() const {
  // @@protoc_insertion_point(field_get:EnergyStorageType.liquidPropaneGas)
  return liquidpropanegas_;
}
inline void EnergyStorageType::set_liquidpropanegas(bool value) {
  set_has_liquidpropanegas();
  liquidpropanegas_ = value;
  // @@protoc_insertion_point(field_set:EnergyStorageType.liquidPropaneGas)
}

// required bool compressedNaturalGas = 4;
inline bool EnergyStorageType::has_compressednaturalgas() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnergyStorageType::set_has_compressednaturalgas() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnergyStorageType::clear_has_compressednaturalgas() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnergyStorageType::clear_compressednaturalgas() {
  compressednaturalgas_ = false;
  clear_has_compressednaturalgas();
}
inline bool EnergyStorageType::compressednaturalgas() const {
  // @@protoc_insertion_point(field_get:EnergyStorageType.compressedNaturalGas)
  return compressednaturalgas_;
}
inline void EnergyStorageType::set_compressednaturalgas(bool value) {
  set_has_compressednaturalgas();
  compressednaturalgas_ = value;
  // @@protoc_insertion_point(field_set:EnergyStorageType.compressedNaturalGas)
}

// required bool diesel = 5;
inline bool EnergyStorageType::has_diesel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnergyStorageType::set_has_diesel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnergyStorageType::clear_has_diesel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnergyStorageType::clear_diesel() {
  diesel_ = false;
  clear_has_diesel();
}
inline bool EnergyStorageType::diesel() const {
  // @@protoc_insertion_point(field_get:EnergyStorageType.diesel)
  return diesel_;
}
inline void EnergyStorageType::set_diesel(bool value) {
  set_has_diesel();
  diesel_ = value;
  // @@protoc_insertion_point(field_set:EnergyStorageType.diesel)
}

// required bool gasoline = 6;
inline bool EnergyStorageType::has_gasoline() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EnergyStorageType::set_has_gasoline() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EnergyStorageType::clear_has_gasoline() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EnergyStorageType::clear_gasoline() {
  gasoline_ = false;
  clear_has_gasoline();
}
inline bool EnergyStorageType::gasoline() const {
  // @@protoc_insertion_point(field_get:EnergyStorageType.gasoline)
  return gasoline_;
}
inline void EnergyStorageType::set_gasoline(bool value) {
  set_has_gasoline();
  gasoline_ = value;
  // @@protoc_insertion_point(field_set:EnergyStorageType.gasoline)
}

// required bool ammonia = 7;
inline bool EnergyStorageType::has_ammonia() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EnergyStorageType::set_has_ammonia() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EnergyStorageType::clear_has_ammonia() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EnergyStorageType::clear_ammonia() {
  ammonia_ = false;
  clear_has_ammonia();
}
inline bool EnergyStorageType::ammonia() const {
  // @@protoc_insertion_point(field_get:EnergyStorageType.ammonia)
  return ammonia_;
}
inline void EnergyStorageType::set_ammonia(bool value) {
  set_has_ammonia();
  ammonia_ = value;
  // @@protoc_insertion_point(field_set:EnergyStorageType.ammonia)
}

// -------------------------------------------------------------------

// EllipticalShape

// optional .CartesianPosition3d shapeReferencePoint = 1;
inline bool EllipticalShape::has_shapereferencepoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EllipticalShape::set_has_shapereferencepoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EllipticalShape::clear_has_shapereferencepoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EllipticalShape::clear_shapereferencepoint() {
  if (shapereferencepoint_ != NULL) shapereferencepoint_->Clear();
  clear_has_shapereferencepoint();
}
inline const ::CartesianPosition3d& EllipticalShape::_internal_shapereferencepoint() const {
  return *shapereferencepoint_;
}
inline const ::CartesianPosition3d& EllipticalShape::shapereferencepoint() const {
  const ::CartesianPosition3d* p = shapereferencepoint_;
  // @@protoc_insertion_point(field_get:EllipticalShape.shapeReferencePoint)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianPosition3d*>(
      &::_CartesianPosition3d_default_instance_);
}
inline ::CartesianPosition3d* EllipticalShape::release_shapereferencepoint() {
  // @@protoc_insertion_point(field_release:EllipticalShape.shapeReferencePoint)
  clear_has_shapereferencepoint();
  ::CartesianPosition3d* temp = shapereferencepoint_;
  shapereferencepoint_ = NULL;
  return temp;
}
inline ::CartesianPosition3d* EllipticalShape::mutable_shapereferencepoint() {
  set_has_shapereferencepoint();
  if (shapereferencepoint_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianPosition3d>(GetArenaNoVirtual());
    shapereferencepoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:EllipticalShape.shapeReferencePoint)
  return shapereferencepoint_;
}
inline void EllipticalShape::set_allocated_shapereferencepoint(::CartesianPosition3d* shapereferencepoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shapereferencepoint_;
  }
  if (shapereferencepoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shapereferencepoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shapereferencepoint, submessage_arena);
    }
    set_has_shapereferencepoint();
  } else {
    clear_has_shapereferencepoint();
  }
  shapereferencepoint_ = shapereferencepoint;
  // @@protoc_insertion_point(field_set_allocated:EllipticalShape.shapeReferencePoint)
}

// required uint32 semiMajorAxisLength = 2;
inline bool EllipticalShape::has_semimajoraxislength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EllipticalShape::set_has_semimajoraxislength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EllipticalShape::clear_has_semimajoraxislength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EllipticalShape::clear_semimajoraxislength() {
  semimajoraxislength_ = 0u;
  clear_has_semimajoraxislength();
}
inline ::google::protobuf::uint32 EllipticalShape::semimajoraxislength() const {
  // @@protoc_insertion_point(field_get:EllipticalShape.semiMajorAxisLength)
  return semimajoraxislength_;
}
inline void EllipticalShape::set_semimajoraxislength(::google::protobuf::uint32 value) {
  set_has_semimajoraxislength();
  semimajoraxislength_ = value;
  // @@protoc_insertion_point(field_set:EllipticalShape.semiMajorAxisLength)
}

// required uint32 semiMinorAxisLength = 3;
inline bool EllipticalShape::has_semiminoraxislength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EllipticalShape::set_has_semiminoraxislength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EllipticalShape::clear_has_semiminoraxislength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EllipticalShape::clear_semiminoraxislength() {
  semiminoraxislength_ = 0u;
  clear_has_semiminoraxislength();
}
inline ::google::protobuf::uint32 EllipticalShape::semiminoraxislength() const {
  // @@protoc_insertion_point(field_get:EllipticalShape.semiMinorAxisLength)
  return semiminoraxislength_;
}
inline void EllipticalShape::set_semiminoraxislength(::google::protobuf::uint32 value) {
  set_has_semiminoraxislength();
  semiminoraxislength_ = value;
  // @@protoc_insertion_point(field_set:EllipticalShape.semiMinorAxisLength)
}

// optional uint32 orientation = 4;
inline bool EllipticalShape::has_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EllipticalShape::set_has_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EllipticalShape::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EllipticalShape::clear_orientation() {
  orientation_ = 0u;
  clear_has_orientation();
}
inline ::google::protobuf::uint32 EllipticalShape::orientation() const {
  // @@protoc_insertion_point(field_get:EllipticalShape.orientation)
  return orientation_;
}
inline void EllipticalShape::set_orientation(::google::protobuf::uint32 value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:EllipticalShape.orientation)
}

// optional uint32 height = 5;
inline bool EllipticalShape::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EllipticalShape::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EllipticalShape::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EllipticalShape::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 EllipticalShape::height() const {
  // @@protoc_insertion_point(field_get:EllipticalShape.height)
  return height_;
}
inline void EllipticalShape::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:EllipticalShape.height)
}

// -------------------------------------------------------------------

// EulerAnglesWithConfidence

// required .CartesianAngle zAngle = 1;
inline bool EulerAnglesWithConfidence::has_zangle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EulerAnglesWithConfidence::set_has_zangle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EulerAnglesWithConfidence::clear_has_zangle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EulerAnglesWithConfidence::clear_zangle() {
  if (zangle_ != NULL) zangle_->Clear();
  clear_has_zangle();
}
inline const ::CartesianAngle& EulerAnglesWithConfidence::_internal_zangle() const {
  return *zangle_;
}
inline const ::CartesianAngle& EulerAnglesWithConfidence::zangle() const {
  const ::CartesianAngle* p = zangle_;
  // @@protoc_insertion_point(field_get:EulerAnglesWithConfidence.zAngle)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianAngle*>(
      &::_CartesianAngle_default_instance_);
}
inline ::CartesianAngle* EulerAnglesWithConfidence::release_zangle() {
  // @@protoc_insertion_point(field_release:EulerAnglesWithConfidence.zAngle)
  clear_has_zangle();
  ::CartesianAngle* temp = zangle_;
  zangle_ = NULL;
  return temp;
}
inline ::CartesianAngle* EulerAnglesWithConfidence::mutable_zangle() {
  set_has_zangle();
  if (zangle_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianAngle>(GetArenaNoVirtual());
    zangle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:EulerAnglesWithConfidence.zAngle)
  return zangle_;
}
inline void EulerAnglesWithConfidence::set_allocated_zangle(::CartesianAngle* zangle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zangle_;
  }
  if (zangle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zangle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zangle, submessage_arena);
    }
    set_has_zangle();
  } else {
    clear_has_zangle();
  }
  zangle_ = zangle;
  // @@protoc_insertion_point(field_set_allocated:EulerAnglesWithConfidence.zAngle)
}

// optional .CartesianAngle yAngle = 2;
inline bool EulerAnglesWithConfidence::has_yangle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EulerAnglesWithConfidence::set_has_yangle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EulerAnglesWithConfidence::clear_has_yangle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EulerAnglesWithConfidence::clear_yangle() {
  if (yangle_ != NULL) yangle_->Clear();
  clear_has_yangle();
}
inline const ::CartesianAngle& EulerAnglesWithConfidence::_internal_yangle() const {
  return *yangle_;
}
inline const ::CartesianAngle& EulerAnglesWithConfidence::yangle() const {
  const ::CartesianAngle* p = yangle_;
  // @@protoc_insertion_point(field_get:EulerAnglesWithConfidence.yAngle)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianAngle*>(
      &::_CartesianAngle_default_instance_);
}
inline ::CartesianAngle* EulerAnglesWithConfidence::release_yangle() {
  // @@protoc_insertion_point(field_release:EulerAnglesWithConfidence.yAngle)
  clear_has_yangle();
  ::CartesianAngle* temp = yangle_;
  yangle_ = NULL;
  return temp;
}
inline ::CartesianAngle* EulerAnglesWithConfidence::mutable_yangle() {
  set_has_yangle();
  if (yangle_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianAngle>(GetArenaNoVirtual());
    yangle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:EulerAnglesWithConfidence.yAngle)
  return yangle_;
}
inline void EulerAnglesWithConfidence::set_allocated_yangle(::CartesianAngle* yangle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete yangle_;
  }
  if (yangle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yangle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yangle, submessage_arena);
    }
    set_has_yangle();
  } else {
    clear_has_yangle();
  }
  yangle_ = yangle;
  // @@protoc_insertion_point(field_set_allocated:EulerAnglesWithConfidence.yAngle)
}

// optional .CartesianAngle xAngle = 3;
inline bool EulerAnglesWithConfidence::has_xangle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EulerAnglesWithConfidence::set_has_xangle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EulerAnglesWithConfidence::clear_has_xangle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EulerAnglesWithConfidence::clear_xangle() {
  if (xangle_ != NULL) xangle_->Clear();
  clear_has_xangle();
}
inline const ::CartesianAngle& EulerAnglesWithConfidence::_internal_xangle() const {
  return *xangle_;
}
inline const ::CartesianAngle& EulerAnglesWithConfidence::xangle() const {
  const ::CartesianAngle* p = xangle_;
  // @@protoc_insertion_point(field_get:EulerAnglesWithConfidence.xAngle)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianAngle*>(
      &::_CartesianAngle_default_instance_);
}
inline ::CartesianAngle* EulerAnglesWithConfidence::release_xangle() {
  // @@protoc_insertion_point(field_release:EulerAnglesWithConfidence.xAngle)
  clear_has_xangle();
  ::CartesianAngle* temp = xangle_;
  xangle_ = NULL;
  return temp;
}
inline ::CartesianAngle* EulerAnglesWithConfidence::mutable_xangle() {
  set_has_xangle();
  if (xangle_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianAngle>(GetArenaNoVirtual());
    xangle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:EulerAnglesWithConfidence.xAngle)
  return xangle_;
}
inline void EulerAnglesWithConfidence::set_allocated_xangle(::CartesianAngle* xangle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete xangle_;
  }
  if (xangle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      xangle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xangle, submessage_arena);
    }
    set_has_xangle();
  } else {
    clear_has_xangle();
  }
  xangle_ = xangle;
  // @@protoc_insertion_point(field_set_allocated:EulerAnglesWithConfidence.xAngle)
}

// -------------------------------------------------------------------

// EventHistory

// repeated .EventPoint event_points = 1;
inline int EventHistory::event_points_size() const {
  return event_points_.size();
}
inline void EventHistory::clear_event_points() {
  event_points_.Clear();
}
inline ::EventPoint* EventHistory::mutable_event_points(int index) {
  // @@protoc_insertion_point(field_mutable:EventHistory.event_points)
  return event_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::EventPoint >*
EventHistory::mutable_event_points() {
  // @@protoc_insertion_point(field_mutable_list:EventHistory.event_points)
  return &event_points_;
}
inline const ::EventPoint& EventHistory::event_points(int index) const {
  // @@protoc_insertion_point(field_get:EventHistory.event_points)
  return event_points_.Get(index);
}
inline ::EventPoint* EventHistory::add_event_points() {
  // @@protoc_insertion_point(field_add:EventHistory.event_points)
  return event_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::EventPoint >&
EventHistory::event_points() const {
  // @@protoc_insertion_point(field_list:EventHistory.event_points)
  return event_points_;
}

// -------------------------------------------------------------------

// EventPoint

// required .DeltaReferencePosition eventPosition = 1;
inline bool EventPoint::has_eventposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventPoint::set_has_eventposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventPoint::clear_has_eventposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventPoint::clear_eventposition() {
  if (eventposition_ != NULL) eventposition_->Clear();
  clear_has_eventposition();
}
inline const ::DeltaReferencePosition& EventPoint::_internal_eventposition() const {
  return *eventposition_;
}
inline const ::DeltaReferencePosition& EventPoint::eventposition() const {
  const ::DeltaReferencePosition* p = eventposition_;
  // @@protoc_insertion_point(field_get:EventPoint.eventPosition)
  return p != NULL ? *p : *reinterpret_cast<const ::DeltaReferencePosition*>(
      &::_DeltaReferencePosition_default_instance_);
}
inline ::DeltaReferencePosition* EventPoint::release_eventposition() {
  // @@protoc_insertion_point(field_release:EventPoint.eventPosition)
  clear_has_eventposition();
  ::DeltaReferencePosition* temp = eventposition_;
  eventposition_ = NULL;
  return temp;
}
inline ::DeltaReferencePosition* EventPoint::mutable_eventposition() {
  set_has_eventposition();
  if (eventposition_ == NULL) {
    auto* p = CreateMaybeMessage<::DeltaReferencePosition>(GetArenaNoVirtual());
    eventposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:EventPoint.eventPosition)
  return eventposition_;
}
inline void EventPoint::set_allocated_eventposition(::DeltaReferencePosition* eventposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete eventposition_;
  }
  if (eventposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eventposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eventposition, submessage_arena);
    }
    set_has_eventposition();
  } else {
    clear_has_eventposition();
  }
  eventposition_ = eventposition;
  // @@protoc_insertion_point(field_set_allocated:EventPoint.eventPosition)
}

// optional uint32 eventDeltaTime = 2;
inline bool EventPoint::has_eventdeltatime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventPoint::set_has_eventdeltatime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventPoint::clear_has_eventdeltatime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventPoint::clear_eventdeltatime() {
  eventdeltatime_ = 0u;
  clear_has_eventdeltatime();
}
inline ::google::protobuf::uint32 EventPoint::eventdeltatime() const {
  // @@protoc_insertion_point(field_get:EventPoint.eventDeltaTime)
  return eventdeltatime_;
}
inline void EventPoint::set_eventdeltatime(::google::protobuf::uint32 value) {
  set_has_eventdeltatime();
  eventdeltatime_ = value;
  // @@protoc_insertion_point(field_set:EventPoint.eventDeltaTime)
}

// required uint32 informationQuality = 3;
inline bool EventPoint::has_informationquality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventPoint::set_has_informationquality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventPoint::clear_has_informationquality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventPoint::clear_informationquality() {
  informationquality_ = 0u;
  clear_has_informationquality();
}
inline ::google::protobuf::uint32 EventPoint::informationquality() const {
  // @@protoc_insertion_point(field_get:EventPoint.informationQuality)
  return informationquality_;
}
inline void EventPoint::set_informationquality(::google::protobuf::uint32 value) {
  set_has_informationquality();
  informationquality_ = value;
  // @@protoc_insertion_point(field_set:EventPoint.informationQuality)
}

// -------------------------------------------------------------------

// Heading

// required int32 value = 1;
inline bool Heading::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Heading::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Heading::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Heading::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Heading::value() const {
  // @@protoc_insertion_point(field_get:Heading.value)
  return value_;
}
inline void Heading::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:Heading.value)
}

// required uint32 confidence = 2;
inline bool Heading::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Heading::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Heading::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Heading::clear_confidence() {
  confidence_ = 0u;
  clear_has_confidence();
}
inline ::google::protobuf::uint32 Heading::confidence() const {
  // @@protoc_insertion_point(field_get:Heading.confidence)
  return confidence_;
}
inline void Heading::set_confidence(::google::protobuf::uint32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:Heading.confidence)
}

// -------------------------------------------------------------------

// IntersectionReferenceID

// optional int64 region = 1;
inline bool IntersectionReferenceID::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntersectionReferenceID::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntersectionReferenceID::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntersectionReferenceID::clear_region() {
  region_ = GOOGLE_LONGLONG(0);
  clear_has_region();
}
inline ::google::protobuf::int64 IntersectionReferenceID::region() const {
  // @@protoc_insertion_point(field_get:IntersectionReferenceID.region)
  return region_;
}
inline void IntersectionReferenceID::set_region(::google::protobuf::int64 value) {
  set_has_region();
  region_ = value;
  // @@protoc_insertion_point(field_set:IntersectionReferenceID.region)
}

// optional int64 id = 2;
inline bool IntersectionReferenceID::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntersectionReferenceID::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntersectionReferenceID::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntersectionReferenceID::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 IntersectionReferenceID::id() const {
  // @@protoc_insertion_point(field_get:IntersectionReferenceID.id)
  return id_;
}
inline void IntersectionReferenceID::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:IntersectionReferenceID.id)
}

// -------------------------------------------------------------------

// ItineraryPath

// repeated .ReferencePosition path = 1;
inline int ItineraryPath::path_size() const {
  return path_.size();
}
inline void ItineraryPath::clear_path() {
  path_.Clear();
}
inline ::ReferencePosition* ItineraryPath::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:ItineraryPath.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ReferencePosition >*
ItineraryPath::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:ItineraryPath.path)
  return &path_;
}
inline const ::ReferencePosition& ItineraryPath::path(int index) const {
  // @@protoc_insertion_point(field_get:ItineraryPath.path)
  return path_.Get(index);
}
inline ::ReferencePosition* ItineraryPath::add_path() {
  // @@protoc_insertion_point(field_add:ItineraryPath.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ReferencePosition >&
ItineraryPath::path() const {
  // @@protoc_insertion_point(field_list:ItineraryPath.path)
  return path_;
}

// -------------------------------------------------------------------

// LongitudinalAcceleration

// required int32 value = 1;
inline bool LongitudinalAcceleration::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LongitudinalAcceleration::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LongitudinalAcceleration::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LongitudinalAcceleration::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 LongitudinalAcceleration::value() const {
  // @@protoc_insertion_point(field_get:LongitudinalAcceleration.value)
  return value_;
}
inline void LongitudinalAcceleration::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:LongitudinalAcceleration.value)
}

// optional int32 confidence = 2;
inline bool LongitudinalAcceleration::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LongitudinalAcceleration::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LongitudinalAcceleration::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LongitudinalAcceleration::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline ::google::protobuf::int32 LongitudinalAcceleration::confidence() const {
  // @@protoc_insertion_point(field_get:LongitudinalAcceleration.confidence)
  return confidence_;
}
inline void LongitudinalAcceleration::set_confidence(::google::protobuf::int32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:LongitudinalAcceleration.confidence)
}

// -------------------------------------------------------------------

// LongitudinalLanePosition

// required uint32 longitudinalLanePositionValue = 1;
inline bool LongitudinalLanePosition::has_longitudinallanepositionvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LongitudinalLanePosition::set_has_longitudinallanepositionvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LongitudinalLanePosition::clear_has_longitudinallanepositionvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LongitudinalLanePosition::clear_longitudinallanepositionvalue() {
  longitudinallanepositionvalue_ = 0u;
  clear_has_longitudinallanepositionvalue();
}
inline ::google::protobuf::uint32 LongitudinalLanePosition::longitudinallanepositionvalue() const {
  // @@protoc_insertion_point(field_get:LongitudinalLanePosition.longitudinalLanePositionValue)
  return longitudinallanepositionvalue_;
}
inline void LongitudinalLanePosition::set_longitudinallanepositionvalue(::google::protobuf::uint32 value) {
  set_has_longitudinallanepositionvalue();
  longitudinallanepositionvalue_ = value;
  // @@protoc_insertion_point(field_set:LongitudinalLanePosition.longitudinalLanePositionValue)
}

// required uint32 longitudinalLanePositionConfidence = 2;
inline bool LongitudinalLanePosition::has_longitudinallanepositionconfidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LongitudinalLanePosition::set_has_longitudinallanepositionconfidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LongitudinalLanePosition::clear_has_longitudinallanepositionconfidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LongitudinalLanePosition::clear_longitudinallanepositionconfidence() {
  longitudinallanepositionconfidence_ = 0u;
  clear_has_longitudinallanepositionconfidence();
}
inline ::google::protobuf::uint32 LongitudinalLanePosition::longitudinallanepositionconfidence() const {
  // @@protoc_insertion_point(field_get:LongitudinalLanePosition.longitudinalLanePositionConfidence)
  return longitudinallanepositionconfidence_;
}
inline void LongitudinalLanePosition::set_longitudinallanepositionconfidence(::google::protobuf::uint32 value) {
  set_has_longitudinallanepositionconfidence();
  longitudinallanepositionconfidence_ = value;
  // @@protoc_insertion_point(field_set:LongitudinalLanePosition.longitudinalLanePositionConfidence)
}

// -------------------------------------------------------------------

// LowerTriangularPositiveSemidefiniteMatrix

// required .MatrixIncludedComponents componentsIncludedIntheMatrix = 1;
inline bool LowerTriangularPositiveSemidefiniteMatrix::has_componentsincludedinthematrix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LowerTriangularPositiveSemidefiniteMatrix::set_has_componentsincludedinthematrix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LowerTriangularPositiveSemidefiniteMatrix::clear_has_componentsincludedinthematrix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LowerTriangularPositiveSemidefiniteMatrix::clear_componentsincludedinthematrix() {
  if (componentsincludedinthematrix_ != NULL) componentsincludedinthematrix_->Clear();
  clear_has_componentsincludedinthematrix();
}
inline const ::MatrixIncludedComponents& LowerTriangularPositiveSemidefiniteMatrix::_internal_componentsincludedinthematrix() const {
  return *componentsincludedinthematrix_;
}
inline const ::MatrixIncludedComponents& LowerTriangularPositiveSemidefiniteMatrix::componentsincludedinthematrix() const {
  const ::MatrixIncludedComponents* p = componentsincludedinthematrix_;
  // @@protoc_insertion_point(field_get:LowerTriangularPositiveSemidefiniteMatrix.componentsIncludedIntheMatrix)
  return p != NULL ? *p : *reinterpret_cast<const ::MatrixIncludedComponents*>(
      &::_MatrixIncludedComponents_default_instance_);
}
inline ::MatrixIncludedComponents* LowerTriangularPositiveSemidefiniteMatrix::release_componentsincludedinthematrix() {
  // @@protoc_insertion_point(field_release:LowerTriangularPositiveSemidefiniteMatrix.componentsIncludedIntheMatrix)
  clear_has_componentsincludedinthematrix();
  ::MatrixIncludedComponents* temp = componentsincludedinthematrix_;
  componentsincludedinthematrix_ = NULL;
  return temp;
}
inline ::MatrixIncludedComponents* LowerTriangularPositiveSemidefiniteMatrix::mutable_componentsincludedinthematrix() {
  set_has_componentsincludedinthematrix();
  if (componentsincludedinthematrix_ == NULL) {
    auto* p = CreateMaybeMessage<::MatrixIncludedComponents>(GetArenaNoVirtual());
    componentsincludedinthematrix_ = p;
  }
  // @@protoc_insertion_point(field_mutable:LowerTriangularPositiveSemidefiniteMatrix.componentsIncludedIntheMatrix)
  return componentsincludedinthematrix_;
}
inline void LowerTriangularPositiveSemidefiniteMatrix::set_allocated_componentsincludedinthematrix(::MatrixIncludedComponents* componentsincludedinthematrix) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete componentsincludedinthematrix_;
  }
  if (componentsincludedinthematrix) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      componentsincludedinthematrix = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, componentsincludedinthematrix, submessage_arena);
    }
    set_has_componentsincludedinthematrix();
  } else {
    clear_has_componentsincludedinthematrix();
  }
  componentsincludedinthematrix_ = componentsincludedinthematrix;
  // @@protoc_insertion_point(field_set_allocated:LowerTriangularPositiveSemidefiniteMatrix.componentsIncludedIntheMatrix)
}

// required .LowerTriangularPositiveSemidefiniteMatrixColumns matrix = 2;
inline bool LowerTriangularPositiveSemidefiniteMatrix::has_matrix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LowerTriangularPositiveSemidefiniteMatrix::set_has_matrix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LowerTriangularPositiveSemidefiniteMatrix::clear_has_matrix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LowerTriangularPositiveSemidefiniteMatrix::clear_matrix() {
  if (matrix_ != NULL) matrix_->Clear();
  clear_has_matrix();
}
inline const ::LowerTriangularPositiveSemidefiniteMatrixColumns& LowerTriangularPositiveSemidefiniteMatrix::_internal_matrix() const {
  return *matrix_;
}
inline const ::LowerTriangularPositiveSemidefiniteMatrixColumns& LowerTriangularPositiveSemidefiniteMatrix::matrix() const {
  const ::LowerTriangularPositiveSemidefiniteMatrixColumns* p = matrix_;
  // @@protoc_insertion_point(field_get:LowerTriangularPositiveSemidefiniteMatrix.matrix)
  return p != NULL ? *p : *reinterpret_cast<const ::LowerTriangularPositiveSemidefiniteMatrixColumns*>(
      &::_LowerTriangularPositiveSemidefiniteMatrixColumns_default_instance_);
}
inline ::LowerTriangularPositiveSemidefiniteMatrixColumns* LowerTriangularPositiveSemidefiniteMatrix::release_matrix() {
  // @@protoc_insertion_point(field_release:LowerTriangularPositiveSemidefiniteMatrix.matrix)
  clear_has_matrix();
  ::LowerTriangularPositiveSemidefiniteMatrixColumns* temp = matrix_;
  matrix_ = NULL;
  return temp;
}
inline ::LowerTriangularPositiveSemidefiniteMatrixColumns* LowerTriangularPositiveSemidefiniteMatrix::mutable_matrix() {
  set_has_matrix();
  if (matrix_ == NULL) {
    auto* p = CreateMaybeMessage<::LowerTriangularPositiveSemidefiniteMatrixColumns>(GetArenaNoVirtual());
    matrix_ = p;
  }
  // @@protoc_insertion_point(field_mutable:LowerTriangularPositiveSemidefiniteMatrix.matrix)
  return matrix_;
}
inline void LowerTriangularPositiveSemidefiniteMatrix::set_allocated_matrix(::LowerTriangularPositiveSemidefiniteMatrixColumns* matrix) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete matrix_;
  }
  if (matrix) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      matrix = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, matrix, submessage_arena);
    }
    set_has_matrix();
  } else {
    clear_has_matrix();
  }
  matrix_ = matrix;
  // @@protoc_insertion_point(field_set_allocated:LowerTriangularPositiveSemidefiniteMatrix.matrix)
}

// -------------------------------------------------------------------

// LowerTriangularPositiveSemidefiniteMatrixColumns

// repeated .CorrelationColumn columns = 1;
inline int LowerTriangularPositiveSemidefiniteMatrixColumns::columns_size() const {
  return columns_.size();
}
inline void LowerTriangularPositiveSemidefiniteMatrixColumns::clear_columns() {
  columns_.Clear();
}
inline ::CorrelationColumn* LowerTriangularPositiveSemidefiniteMatrixColumns::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:LowerTriangularPositiveSemidefiniteMatrixColumns.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CorrelationColumn >*
LowerTriangularPositiveSemidefiniteMatrixColumns::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:LowerTriangularPositiveSemidefiniteMatrixColumns.columns)
  return &columns_;
}
inline const ::CorrelationColumn& LowerTriangularPositiveSemidefiniteMatrixColumns::columns(int index) const {
  // @@protoc_insertion_point(field_get:LowerTriangularPositiveSemidefiniteMatrixColumns.columns)
  return columns_.Get(index);
}
inline ::CorrelationColumn* LowerTriangularPositiveSemidefiniteMatrixColumns::add_columns() {
  // @@protoc_insertion_point(field_add:LowerTriangularPositiveSemidefiniteMatrixColumns.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CorrelationColumn >&
LowerTriangularPositiveSemidefiniteMatrixColumns::columns() const {
  // @@protoc_insertion_point(field_list:LowerTriangularPositiveSemidefiniteMatrixColumns.columns)
  return columns_;
}

// -------------------------------------------------------------------

// MapPosition

// optional .MapReference mapReference = 1;
inline bool MapPosition::has_mapreference() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPosition::set_has_mapreference() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPosition::clear_has_mapreference() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPosition::clear_mapreference() {
  if (mapreference_ != NULL) mapreference_->Clear();
  clear_has_mapreference();
}
inline const ::MapReference& MapPosition::_internal_mapreference() const {
  return *mapreference_;
}
inline const ::MapReference& MapPosition::mapreference() const {
  const ::MapReference* p = mapreference_;
  // @@protoc_insertion_point(field_get:MapPosition.mapReference)
  return p != NULL ? *p : *reinterpret_cast<const ::MapReference*>(
      &::_MapReference_default_instance_);
}
inline ::MapReference* MapPosition::release_mapreference() {
  // @@protoc_insertion_point(field_release:MapPosition.mapReference)
  clear_has_mapreference();
  ::MapReference* temp = mapreference_;
  mapreference_ = NULL;
  return temp;
}
inline ::MapReference* MapPosition::mutable_mapreference() {
  set_has_mapreference();
  if (mapreference_ == NULL) {
    auto* p = CreateMaybeMessage<::MapReference>(GetArenaNoVirtual());
    mapreference_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MapPosition.mapReference)
  return mapreference_;
}
inline void MapPosition::set_allocated_mapreference(::MapReference* mapreference) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mapreference_;
  }
  if (mapreference) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mapreference = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mapreference, submessage_arena);
    }
    set_has_mapreference();
  } else {
    clear_has_mapreference();
  }
  mapreference_ = mapreference;
  // @@protoc_insertion_point(field_set_allocated:MapPosition.mapReference)
}

// optional uint32 laneId = 2;
inline bool MapPosition::has_laneid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapPosition::set_has_laneid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapPosition::clear_has_laneid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapPosition::clear_laneid() {
  laneid_ = 0u;
  clear_has_laneid();
}
inline ::google::protobuf::uint32 MapPosition::laneid() const {
  // @@protoc_insertion_point(field_get:MapPosition.laneId)
  return laneid_;
}
inline void MapPosition::set_laneid(::google::protobuf::uint32 value) {
  set_has_laneid();
  laneid_ = value;
  // @@protoc_insertion_point(field_set:MapPosition.laneId)
}

// optional uint32 connectionId = 3;
inline bool MapPosition::has_connectionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapPosition::set_has_connectionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapPosition::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapPosition::clear_connectionid() {
  connectionid_ = 0u;
  clear_has_connectionid();
}
inline ::google::protobuf::uint32 MapPosition::connectionid() const {
  // @@protoc_insertion_point(field_get:MapPosition.connectionId)
  return connectionid_;
}
inline void MapPosition::set_connectionid(::google::protobuf::uint32 value) {
  set_has_connectionid();
  connectionid_ = value;
  // @@protoc_insertion_point(field_set:MapPosition.connectionId)
}

// optional .LongitudinalLanePosition longitudinalLanePosition = 4;
inline bool MapPosition::has_longitudinallaneposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapPosition::set_has_longitudinallaneposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapPosition::clear_has_longitudinallaneposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapPosition::clear_longitudinallaneposition() {
  if (longitudinallaneposition_ != NULL) longitudinallaneposition_->Clear();
  clear_has_longitudinallaneposition();
}
inline const ::LongitudinalLanePosition& MapPosition::_internal_longitudinallaneposition() const {
  return *longitudinallaneposition_;
}
inline const ::LongitudinalLanePosition& MapPosition::longitudinallaneposition() const {
  const ::LongitudinalLanePosition* p = longitudinallaneposition_;
  // @@protoc_insertion_point(field_get:MapPosition.longitudinalLanePosition)
  return p != NULL ? *p : *reinterpret_cast<const ::LongitudinalLanePosition*>(
      &::_LongitudinalLanePosition_default_instance_);
}
inline ::LongitudinalLanePosition* MapPosition::release_longitudinallaneposition() {
  // @@protoc_insertion_point(field_release:MapPosition.longitudinalLanePosition)
  clear_has_longitudinallaneposition();
  ::LongitudinalLanePosition* temp = longitudinallaneposition_;
  longitudinallaneposition_ = NULL;
  return temp;
}
inline ::LongitudinalLanePosition* MapPosition::mutable_longitudinallaneposition() {
  set_has_longitudinallaneposition();
  if (longitudinallaneposition_ == NULL) {
    auto* p = CreateMaybeMessage<::LongitudinalLanePosition>(GetArenaNoVirtual());
    longitudinallaneposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MapPosition.longitudinalLanePosition)
  return longitudinallaneposition_;
}
inline void MapPosition::set_allocated_longitudinallaneposition(::LongitudinalLanePosition* longitudinallaneposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete longitudinallaneposition_;
  }
  if (longitudinallaneposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      longitudinallaneposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, longitudinallaneposition, submessage_arena);
    }
    set_has_longitudinallaneposition();
  } else {
    clear_has_longitudinallaneposition();
  }
  longitudinallaneposition_ = longitudinallaneposition;
  // @@protoc_insertion_point(field_set_allocated:MapPosition.longitudinalLanePosition)
}

// -------------------------------------------------------------------

// MapReference

// optional .RoadSegmentReferenceID roadsegment = 1;
inline bool MapReference::has_roadsegment() const {
  return mapref_case() == kRoadsegment;
}
inline void MapReference::set_has_roadsegment() {
  _oneof_case_[0] = kRoadsegment;
}
inline void MapReference::clear_roadsegment() {
  if (has_roadsegment()) {
    delete mapref_.roadsegment_;
    clear_has_mapref();
  }
}
inline const ::RoadSegmentReferenceID& MapReference::_internal_roadsegment() const {
  return *mapref_.roadsegment_;
}
inline ::RoadSegmentReferenceID* MapReference::release_roadsegment() {
  // @@protoc_insertion_point(field_release:MapReference.roadsegment)
  if (has_roadsegment()) {
    clear_has_mapref();
      ::RoadSegmentReferenceID* temp = mapref_.roadsegment_;
    mapref_.roadsegment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RoadSegmentReferenceID& MapReference::roadsegment() const {
  // @@protoc_insertion_point(field_get:MapReference.roadsegment)
  return has_roadsegment()
      ? *mapref_.roadsegment_
      : *reinterpret_cast< ::RoadSegmentReferenceID*>(&::_RoadSegmentReferenceID_default_instance_);
}
inline ::RoadSegmentReferenceID* MapReference::mutable_roadsegment() {
  if (!has_roadsegment()) {
    clear_mapref();
    set_has_roadsegment();
    mapref_.roadsegment_ = CreateMaybeMessage< ::RoadSegmentReferenceID >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MapReference.roadsegment)
  return mapref_.roadsegment_;
}

// optional .IntersectionReferenceID intersection = 2;
inline bool MapReference::has_intersection() const {
  return mapref_case() == kIntersection;
}
inline void MapReference::set_has_intersection() {
  _oneof_case_[0] = kIntersection;
}
inline void MapReference::clear_intersection() {
  if (has_intersection()) {
    delete mapref_.intersection_;
    clear_has_mapref();
  }
}
inline const ::IntersectionReferenceID& MapReference::_internal_intersection() const {
  return *mapref_.intersection_;
}
inline ::IntersectionReferenceID* MapReference::release_intersection() {
  // @@protoc_insertion_point(field_release:MapReference.intersection)
  if (has_intersection()) {
    clear_has_mapref();
      ::IntersectionReferenceID* temp = mapref_.intersection_;
    mapref_.intersection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::IntersectionReferenceID& MapReference::intersection() const {
  // @@protoc_insertion_point(field_get:MapReference.intersection)
  return has_intersection()
      ? *mapref_.intersection_
      : *reinterpret_cast< ::IntersectionReferenceID*>(&::_IntersectionReferenceID_default_instance_);
}
inline ::IntersectionReferenceID* MapReference::mutable_intersection() {
  if (!has_intersection()) {
    clear_mapref();
    set_has_intersection();
    mapref_.intersection_ = CreateMaybeMessage< ::IntersectionReferenceID >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:MapReference.intersection)
  return mapref_.intersection_;
}

inline bool MapReference::has_mapref() const {
  return mapref_case() != MAPREF_NOT_SET;
}
inline void MapReference::clear_has_mapref() {
  _oneof_case_[0] = MAPREF_NOT_SET;
}
inline MapReference::MaprefCase MapReference::mapref_case() const {
  return MapReference::MaprefCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatrixIncludedComponents

// required bool xPosition = 1;
inline bool MatrixIncludedComponents::has_xposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatrixIncludedComponents::set_has_xposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatrixIncludedComponents::clear_has_xposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatrixIncludedComponents::clear_xposition() {
  xposition_ = false;
  clear_has_xposition();
}
inline bool MatrixIncludedComponents::xposition() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.xPosition)
  return xposition_;
}
inline void MatrixIncludedComponents::set_xposition(bool value) {
  set_has_xposition();
  xposition_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.xPosition)
}

// required bool yPosition = 2;
inline bool MatrixIncludedComponents::has_yposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatrixIncludedComponents::set_has_yposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatrixIncludedComponents::clear_has_yposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatrixIncludedComponents::clear_yposition() {
  yposition_ = false;
  clear_has_yposition();
}
inline bool MatrixIncludedComponents::yposition() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.yPosition)
  return yposition_;
}
inline void MatrixIncludedComponents::set_yposition(bool value) {
  set_has_yposition();
  yposition_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.yPosition)
}

// required bool zPosition = 3;
inline bool MatrixIncludedComponents::has_zposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatrixIncludedComponents::set_has_zposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatrixIncludedComponents::clear_has_zposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatrixIncludedComponents::clear_zposition() {
  zposition_ = false;
  clear_has_zposition();
}
inline bool MatrixIncludedComponents::zposition() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.zPosition)
  return zposition_;
}
inline void MatrixIncludedComponents::set_zposition(bool value) {
  set_has_zposition();
  zposition_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.zPosition)
}

// required bool xVelocityOrVelocityMagnitude = 4;
inline bool MatrixIncludedComponents::has_xvelocityorvelocitymagnitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatrixIncludedComponents::set_has_xvelocityorvelocitymagnitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatrixIncludedComponents::clear_has_xvelocityorvelocitymagnitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatrixIncludedComponents::clear_xvelocityorvelocitymagnitude() {
  xvelocityorvelocitymagnitude_ = false;
  clear_has_xvelocityorvelocitymagnitude();
}
inline bool MatrixIncludedComponents::xvelocityorvelocitymagnitude() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.xVelocityOrVelocityMagnitude)
  return xvelocityorvelocitymagnitude_;
}
inline void MatrixIncludedComponents::set_xvelocityorvelocitymagnitude(bool value) {
  set_has_xvelocityorvelocitymagnitude();
  xvelocityorvelocitymagnitude_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.xVelocityOrVelocityMagnitude)
}

// required bool yVelocityOrVelocityDirection = 5;
inline bool MatrixIncludedComponents::has_yvelocityorvelocitydirection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MatrixIncludedComponents::set_has_yvelocityorvelocitydirection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MatrixIncludedComponents::clear_has_yvelocityorvelocitydirection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MatrixIncludedComponents::clear_yvelocityorvelocitydirection() {
  yvelocityorvelocitydirection_ = false;
  clear_has_yvelocityorvelocitydirection();
}
inline bool MatrixIncludedComponents::yvelocityorvelocitydirection() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.yVelocityOrVelocityDirection)
  return yvelocityorvelocitydirection_;
}
inline void MatrixIncludedComponents::set_yvelocityorvelocitydirection(bool value) {
  set_has_yvelocityorvelocitydirection();
  yvelocityorvelocitydirection_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.yVelocityOrVelocityDirection)
}

// required bool zSpeed = 6;
inline bool MatrixIncludedComponents::has_zspeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MatrixIncludedComponents::set_has_zspeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MatrixIncludedComponents::clear_has_zspeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MatrixIncludedComponents::clear_zspeed() {
  zspeed_ = false;
  clear_has_zspeed();
}
inline bool MatrixIncludedComponents::zspeed() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.zSpeed)
  return zspeed_;
}
inline void MatrixIncludedComponents::set_zspeed(bool value) {
  set_has_zspeed();
  zspeed_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.zSpeed)
}

// required bool xAccelOrAccelMagnitude = 7;
inline bool MatrixIncludedComponents::has_xacceloraccelmagnitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MatrixIncludedComponents::set_has_xacceloraccelmagnitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MatrixIncludedComponents::clear_has_xacceloraccelmagnitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MatrixIncludedComponents::clear_xacceloraccelmagnitude() {
  xacceloraccelmagnitude_ = false;
  clear_has_xacceloraccelmagnitude();
}
inline bool MatrixIncludedComponents::xacceloraccelmagnitude() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.xAccelOrAccelMagnitude)
  return xacceloraccelmagnitude_;
}
inline void MatrixIncludedComponents::set_xacceloraccelmagnitude(bool value) {
  set_has_xacceloraccelmagnitude();
  xacceloraccelmagnitude_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.xAccelOrAccelMagnitude)
}

// required bool yAccelOrAccelDirection = 8;
inline bool MatrixIncludedComponents::has_yacceloracceldirection() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MatrixIncludedComponents::set_has_yacceloracceldirection() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MatrixIncludedComponents::clear_has_yacceloracceldirection() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MatrixIncludedComponents::clear_yacceloracceldirection() {
  yacceloracceldirection_ = false;
  clear_has_yacceloracceldirection();
}
inline bool MatrixIncludedComponents::yacceloracceldirection() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.yAccelOrAccelDirection)
  return yacceloracceldirection_;
}
inline void MatrixIncludedComponents::set_yacceloracceldirection(bool value) {
  set_has_yacceloracceldirection();
  yacceloracceldirection_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.yAccelOrAccelDirection)
}

// required bool zAcceleration = 9;
inline bool MatrixIncludedComponents::has_zacceleration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MatrixIncludedComponents::set_has_zacceleration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MatrixIncludedComponents::clear_has_zacceleration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MatrixIncludedComponents::clear_zacceleration() {
  zacceleration_ = false;
  clear_has_zacceleration();
}
inline bool MatrixIncludedComponents::zacceleration() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.zAcceleration)
  return zacceleration_;
}
inline void MatrixIncludedComponents::set_zacceleration(bool value) {
  set_has_zacceleration();
  zacceleration_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.zAcceleration)
}

// required bool zAngle = 10;
inline bool MatrixIncludedComponents::has_zangle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MatrixIncludedComponents::set_has_zangle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MatrixIncludedComponents::clear_has_zangle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MatrixIncludedComponents::clear_zangle() {
  zangle_ = false;
  clear_has_zangle();
}
inline bool MatrixIncludedComponents::zangle() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.zAngle)
  return zangle_;
}
inline void MatrixIncludedComponents::set_zangle(bool value) {
  set_has_zangle();
  zangle_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.zAngle)
}

// required bool yAngle = 11;
inline bool MatrixIncludedComponents::has_yangle() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MatrixIncludedComponents::set_has_yangle() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MatrixIncludedComponents::clear_has_yangle() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MatrixIncludedComponents::clear_yangle() {
  yangle_ = false;
  clear_has_yangle();
}
inline bool MatrixIncludedComponents::yangle() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.yAngle)
  return yangle_;
}
inline void MatrixIncludedComponents::set_yangle(bool value) {
  set_has_yangle();
  yangle_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.yAngle)
}

// required bool xAngle = 12;
inline bool MatrixIncludedComponents::has_xangle() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MatrixIncludedComponents::set_has_xangle() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MatrixIncludedComponents::clear_has_xangle() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MatrixIncludedComponents::clear_xangle() {
  xangle_ = false;
  clear_has_xangle();
}
inline bool MatrixIncludedComponents::xangle() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.xAngle)
  return xangle_;
}
inline void MatrixIncludedComponents::set_xangle(bool value) {
  set_has_xangle();
  xangle_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.xAngle)
}

// required bool zAngularVelocity = 13;
inline bool MatrixIncludedComponents::has_zangularvelocity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MatrixIncludedComponents::set_has_zangularvelocity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MatrixIncludedComponents::clear_has_zangularvelocity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MatrixIncludedComponents::clear_zangularvelocity() {
  zangularvelocity_ = false;
  clear_has_zangularvelocity();
}
inline bool MatrixIncludedComponents::zangularvelocity() const {
  // @@protoc_insertion_point(field_get:MatrixIncludedComponents.zAngularVelocity)
  return zangularvelocity_;
}
inline void MatrixIncludedComponents::set_zangularvelocity(bool value) {
  set_has_zangularvelocity();
  zangularvelocity_ = value;
  // @@protoc_insertion_point(field_set:MatrixIncludedComponents.zAngularVelocity)
}

// -------------------------------------------------------------------

// MessageRateHz

// required uint32 mantissa = 1;
inline bool MessageRateHz::has_mantissa() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageRateHz::set_has_mantissa() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageRateHz::clear_has_mantissa() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageRateHz::clear_mantissa() {
  mantissa_ = 0u;
  clear_has_mantissa();
}
inline ::google::protobuf::uint32 MessageRateHz::mantissa() const {
  // @@protoc_insertion_point(field_get:MessageRateHz.mantissa)
  return mantissa_;
}
inline void MessageRateHz::set_mantissa(::google::protobuf::uint32 value) {
  set_has_mantissa();
  mantissa_ = value;
  // @@protoc_insertion_point(field_set:MessageRateHz.mantissa)
}

// required int32 exponent = 2;
inline bool MessageRateHz::has_exponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageRateHz::set_has_exponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageRateHz::clear_has_exponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageRateHz::clear_exponent() {
  exponent_ = 0;
  clear_has_exponent();
}
inline ::google::protobuf::int32 MessageRateHz::exponent() const {
  // @@protoc_insertion_point(field_get:MessageRateHz.exponent)
  return exponent_;
}
inline void MessageRateHz::set_exponent(::google::protobuf::int32 value) {
  set_has_exponent();
  exponent_ = value;
  // @@protoc_insertion_point(field_set:MessageRateHz.exponent)
}

// -------------------------------------------------------------------

// MessageSegmentationInfo

// required uint32 totalMsgNo = 1;
inline bool MessageSegmentationInfo::has_totalmsgno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageSegmentationInfo::set_has_totalmsgno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageSegmentationInfo::clear_has_totalmsgno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageSegmentationInfo::clear_totalmsgno() {
  totalmsgno_ = 0u;
  clear_has_totalmsgno();
}
inline ::google::protobuf::uint32 MessageSegmentationInfo::totalmsgno() const {
  // @@protoc_insertion_point(field_get:MessageSegmentationInfo.totalMsgNo)
  return totalmsgno_;
}
inline void MessageSegmentationInfo::set_totalmsgno(::google::protobuf::uint32 value) {
  set_has_totalmsgno();
  totalmsgno_ = value;
  // @@protoc_insertion_point(field_set:MessageSegmentationInfo.totalMsgNo)
}

// required uint32 thisMsgNo = 2;
inline bool MessageSegmentationInfo::has_thismsgno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageSegmentationInfo::set_has_thismsgno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageSegmentationInfo::clear_has_thismsgno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageSegmentationInfo::clear_thismsgno() {
  thismsgno_ = 0u;
  clear_has_thismsgno();
}
inline ::google::protobuf::uint32 MessageSegmentationInfo::thismsgno() const {
  // @@protoc_insertion_point(field_get:MessageSegmentationInfo.thisMsgNo)
  return thismsgno_;
}
inline void MessageSegmentationInfo::set_thismsgno(::google::protobuf::uint32 value) {
  set_has_thismsgno();
  thismsgno_ = value;
  // @@protoc_insertion_point(field_set:MessageSegmentationInfo.thisMsgNo)
}

// -------------------------------------------------------------------

// ObjectClass

// optional .TrafficParticipantType vehicleSubClass = 1;
inline bool ObjectClass::has_vehiclesubclass() const {
  return class_case() == kVehicleSubClass;
}
inline void ObjectClass::set_has_vehiclesubclass() {
  _oneof_case_[0] = kVehicleSubClass;
}
inline void ObjectClass::clear_vehiclesubclass() {
  if (has_vehiclesubclass()) {
    class_.vehiclesubclass_ = 0;
    clear_has_class();
  }
}
inline ::TrafficParticipantType ObjectClass::vehiclesubclass() const {
  // @@protoc_insertion_point(field_get:ObjectClass.vehicleSubClass)
  if (has_vehiclesubclass()) {
    return static_cast< ::TrafficParticipantType >(class_.vehiclesubclass_);
  }
  return static_cast< ::TrafficParticipantType >(0);
}
inline void ObjectClass::set_vehiclesubclass(::TrafficParticipantType value) {
  assert(::TrafficParticipantType_IsValid(value));
  if (!has_vehiclesubclass()) {
    clear_class();
    set_has_vehiclesubclass();
  }
  class_.vehiclesubclass_ = value;
  // @@protoc_insertion_point(field_set:ObjectClass.vehicleSubClass)
}

// optional .VruProfileAndSubprofile vruSubClass = 2;
inline bool ObjectClass::has_vrusubclass() const {
  return class_case() == kVruSubClass;
}
inline void ObjectClass::set_has_vrusubclass() {
  _oneof_case_[0] = kVruSubClass;
}
inline void ObjectClass::clear_vrusubclass() {
  if (has_vrusubclass()) {
    delete class_.vrusubclass_;
    clear_has_class();
  }
}
inline const ::VruProfileAndSubprofile& ObjectClass::_internal_vrusubclass() const {
  return *class_.vrusubclass_;
}
inline ::VruProfileAndSubprofile* ObjectClass::release_vrusubclass() {
  // @@protoc_insertion_point(field_release:ObjectClass.vruSubClass)
  if (has_vrusubclass()) {
    clear_has_class();
      ::VruProfileAndSubprofile* temp = class_.vrusubclass_;
    class_.vrusubclass_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::VruProfileAndSubprofile& ObjectClass::vrusubclass() const {
  // @@protoc_insertion_point(field_get:ObjectClass.vruSubClass)
  return has_vrusubclass()
      ? *class_.vrusubclass_
      : *reinterpret_cast< ::VruProfileAndSubprofile*>(&::_VruProfileAndSubprofile_default_instance_);
}
inline ::VruProfileAndSubprofile* ObjectClass::mutable_vrusubclass() {
  if (!has_vrusubclass()) {
    clear_class();
    set_has_vrusubclass();
    class_.vrusubclass_ = CreateMaybeMessage< ::VruProfileAndSubprofile >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ObjectClass.vruSubClass)
  return class_.vrusubclass_;
}

// optional .VruClusterInformation groupSubClass = 3;
inline bool ObjectClass::has_groupsubclass() const {
  return class_case() == kGroupSubClass;
}
inline void ObjectClass::set_has_groupsubclass() {
  _oneof_case_[0] = kGroupSubClass;
}
inline void ObjectClass::clear_groupsubclass() {
  if (has_groupsubclass()) {
    delete class_.groupsubclass_;
    clear_has_class();
  }
}
inline const ::VruClusterInformation& ObjectClass::_internal_groupsubclass() const {
  return *class_.groupsubclass_;
}
inline ::VruClusterInformation* ObjectClass::release_groupsubclass() {
  // @@protoc_insertion_point(field_release:ObjectClass.groupSubClass)
  if (has_groupsubclass()) {
    clear_has_class();
      ::VruClusterInformation* temp = class_.groupsubclass_;
    class_.groupsubclass_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::VruClusterInformation& ObjectClass::groupsubclass() const {
  // @@protoc_insertion_point(field_get:ObjectClass.groupSubClass)
  return has_groupsubclass()
      ? *class_.groupsubclass_
      : *reinterpret_cast< ::VruClusterInformation*>(&::_VruClusterInformation_default_instance_);
}
inline ::VruClusterInformation* ObjectClass::mutable_groupsubclass() {
  if (!has_groupsubclass()) {
    clear_class();
    set_has_groupsubclass();
    class_.groupsubclass_ = CreateMaybeMessage< ::VruClusterInformation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ObjectClass.groupSubClass)
  return class_.groupsubclass_;
}

// optional .OtherSubClass otherSubClass = 4;
inline bool ObjectClass::has_othersubclass() const {
  return class_case() == kOtherSubClass;
}
inline void ObjectClass::set_has_othersubclass() {
  _oneof_case_[0] = kOtherSubClass;
}
inline void ObjectClass::clear_othersubclass() {
  if (has_othersubclass()) {
    delete class_.othersubclass_;
    clear_has_class();
  }
}
inline const ::OtherSubClass& ObjectClass::_internal_othersubclass() const {
  return *class_.othersubclass_;
}
inline ::OtherSubClass* ObjectClass::release_othersubclass() {
  // @@protoc_insertion_point(field_release:ObjectClass.otherSubClass)
  if (has_othersubclass()) {
    clear_has_class();
      ::OtherSubClass* temp = class_.othersubclass_;
    class_.othersubclass_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::OtherSubClass& ObjectClass::othersubclass() const {
  // @@protoc_insertion_point(field_get:ObjectClass.otherSubClass)
  return has_othersubclass()
      ? *class_.othersubclass_
      : *reinterpret_cast< ::OtherSubClass*>(&::_OtherSubClass_default_instance_);
}
inline ::OtherSubClass* ObjectClass::mutable_othersubclass() {
  if (!has_othersubclass()) {
    clear_class();
    set_has_othersubclass();
    class_.othersubclass_ = CreateMaybeMessage< ::OtherSubClass >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ObjectClass.otherSubClass)
  return class_.othersubclass_;
}

inline bool ObjectClass::has_class() const {
  return class_case() != CLASS_NOT_SET;
}
inline void ObjectClass::clear_has_class() {
  _oneof_case_[0] = CLASS_NOT_SET;
}
inline ObjectClass::ClassCase ObjectClass::class_case() const {
  return ObjectClass::ClassCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectClassWithConfidence

// required .ObjectClass objectClass = 1;
inline bool ObjectClassWithConfidence::has_objectclass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectClassWithConfidence::set_has_objectclass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectClassWithConfidence::clear_has_objectclass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectClassWithConfidence::clear_objectclass() {
  if (objectclass_ != NULL) objectclass_->Clear();
  clear_has_objectclass();
}
inline const ::ObjectClass& ObjectClassWithConfidence::_internal_objectclass() const {
  return *objectclass_;
}
inline const ::ObjectClass& ObjectClassWithConfidence::objectclass() const {
  const ::ObjectClass* p = objectclass_;
  // @@protoc_insertion_point(field_get:ObjectClassWithConfidence.objectClass)
  return p != NULL ? *p : *reinterpret_cast<const ::ObjectClass*>(
      &::_ObjectClass_default_instance_);
}
inline ::ObjectClass* ObjectClassWithConfidence::release_objectclass() {
  // @@protoc_insertion_point(field_release:ObjectClassWithConfidence.objectClass)
  clear_has_objectclass();
  ::ObjectClass* temp = objectclass_;
  objectclass_ = NULL;
  return temp;
}
inline ::ObjectClass* ObjectClassWithConfidence::mutable_objectclass() {
  set_has_objectclass();
  if (objectclass_ == NULL) {
    auto* p = CreateMaybeMessage<::ObjectClass>(GetArenaNoVirtual());
    objectclass_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ObjectClassWithConfidence.objectClass)
  return objectclass_;
}
inline void ObjectClassWithConfidence::set_allocated_objectclass(::ObjectClass* objectclass) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete objectclass_;
  }
  if (objectclass) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      objectclass = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, objectclass, submessage_arena);
    }
    set_has_objectclass();
  } else {
    clear_has_objectclass();
  }
  objectclass_ = objectclass;
  // @@protoc_insertion_point(field_set_allocated:ObjectClassWithConfidence.objectClass)
}

// required uint32 confidence = 2;
inline bool ObjectClassWithConfidence::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectClassWithConfidence::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectClassWithConfidence::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectClassWithConfidence::clear_confidence() {
  confidence_ = 0u;
  clear_has_confidence();
}
inline ::google::protobuf::uint32 ObjectClassWithConfidence::confidence() const {
  // @@protoc_insertion_point(field_get:ObjectClassWithConfidence.confidence)
  return confidence_;
}
inline void ObjectClassWithConfidence::set_confidence(::google::protobuf::uint32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:ObjectClassWithConfidence.confidence)
}

// -------------------------------------------------------------------

// ObjectDimension

// required uint32 value = 1;
inline bool ObjectDimension::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectDimension::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectDimension::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectDimension::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ObjectDimension::value() const {
  // @@protoc_insertion_point(field_get:ObjectDimension.value)
  return value_;
}
inline void ObjectDimension::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ObjectDimension.value)
}

// required uint32 confidence = 2;
inline bool ObjectDimension::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectDimension::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectDimension::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectDimension::clear_confidence() {
  confidence_ = 0u;
  clear_has_confidence();
}
inline ::google::protobuf::uint32 ObjectDimension::confidence() const {
  // @@protoc_insertion_point(field_get:ObjectDimension.confidence)
  return confidence_;
}
inline void ObjectDimension::set_confidence(::google::protobuf::uint32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:ObjectDimension.confidence)
}

// -------------------------------------------------------------------

// OtherSubClass

// required bool unknown = 1;
inline bool OtherSubClass::has_unknown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtherSubClass::set_has_unknown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtherSubClass::clear_has_unknown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtherSubClass::clear_unknown() {
  unknown_ = false;
  clear_has_unknown();
}
inline bool OtherSubClass::unknown() const {
  // @@protoc_insertion_point(field_get:OtherSubClass.unknown)
  return unknown_;
}
inline void OtherSubClass::set_unknown(bool value) {
  set_has_unknown();
  unknown_ = value;
  // @@protoc_insertion_point(field_set:OtherSubClass.unknown)
}

// required bool singleObject = 2;
inline bool OtherSubClass::has_singleobject() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtherSubClass::set_has_singleobject() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtherSubClass::clear_has_singleobject() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtherSubClass::clear_singleobject() {
  singleobject_ = false;
  clear_has_singleobject();
}
inline bool OtherSubClass::singleobject() const {
  // @@protoc_insertion_point(field_get:OtherSubClass.singleObject)
  return singleobject_;
}
inline void OtherSubClass::set_singleobject(bool value) {
  set_has_singleobject();
  singleobject_ = value;
  // @@protoc_insertion_point(field_set:OtherSubClass.singleObject)
}

// required bool multipleObjects = 3;
inline bool OtherSubClass::has_multipleobjects() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OtherSubClass::set_has_multipleobjects() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OtherSubClass::clear_has_multipleobjects() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OtherSubClass::clear_multipleobjects() {
  multipleobjects_ = false;
  clear_has_multipleobjects();
}
inline bool OtherSubClass::multipleobjects() const {
  // @@protoc_insertion_point(field_get:OtherSubClass.multipleObjects)
  return multipleobjects_;
}
inline void OtherSubClass::set_multipleobjects(bool value) {
  set_has_multipleobjects();
  multipleobjects_ = value;
  // @@protoc_insertion_point(field_set:OtherSubClass.multipleObjects)
}

// required bool bulkMaterial = 4;
inline bool OtherSubClass::has_bulkmaterial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OtherSubClass::set_has_bulkmaterial() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OtherSubClass::clear_has_bulkmaterial() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OtherSubClass::clear_bulkmaterial() {
  bulkmaterial_ = false;
  clear_has_bulkmaterial();
}
inline bool OtherSubClass::bulkmaterial() const {
  // @@protoc_insertion_point(field_get:OtherSubClass.bulkMaterial)
  return bulkmaterial_;
}
inline void OtherSubClass::set_bulkmaterial(bool value) {
  set_has_bulkmaterial();
  bulkmaterial_ = value;
  // @@protoc_insertion_point(field_set:OtherSubClass.bulkMaterial)
}

// -------------------------------------------------------------------

// PolygonalShape

// optional .CartesianPosition3d shapeReferencePoint = 1;
inline bool PolygonalShape::has_shapereferencepoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolygonalShape::set_has_shapereferencepoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PolygonalShape::clear_has_shapereferencepoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PolygonalShape::clear_shapereferencepoint() {
  if (shapereferencepoint_ != NULL) shapereferencepoint_->Clear();
  clear_has_shapereferencepoint();
}
inline const ::CartesianPosition3d& PolygonalShape::_internal_shapereferencepoint() const {
  return *shapereferencepoint_;
}
inline const ::CartesianPosition3d& PolygonalShape::shapereferencepoint() const {
  const ::CartesianPosition3d* p = shapereferencepoint_;
  // @@protoc_insertion_point(field_get:PolygonalShape.shapeReferencePoint)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianPosition3d*>(
      &::_CartesianPosition3d_default_instance_);
}
inline ::CartesianPosition3d* PolygonalShape::release_shapereferencepoint() {
  // @@protoc_insertion_point(field_release:PolygonalShape.shapeReferencePoint)
  clear_has_shapereferencepoint();
  ::CartesianPosition3d* temp = shapereferencepoint_;
  shapereferencepoint_ = NULL;
  return temp;
}
inline ::CartesianPosition3d* PolygonalShape::mutable_shapereferencepoint() {
  set_has_shapereferencepoint();
  if (shapereferencepoint_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianPosition3d>(GetArenaNoVirtual());
    shapereferencepoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PolygonalShape.shapeReferencePoint)
  return shapereferencepoint_;
}
inline void PolygonalShape::set_allocated_shapereferencepoint(::CartesianPosition3d* shapereferencepoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shapereferencepoint_;
  }
  if (shapereferencepoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shapereferencepoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shapereferencepoint, submessage_arena);
    }
    set_has_shapereferencepoint();
  } else {
    clear_has_shapereferencepoint();
  }
  shapereferencepoint_ = shapereferencepoint;
  // @@protoc_insertion_point(field_set_allocated:PolygonalShape.shapeReferencePoint)
}

// repeated .CartesianPosition3d polygon = 2;
inline int PolygonalShape::polygon_size() const {
  return polygon_.size();
}
inline void PolygonalShape::clear_polygon() {
  polygon_.Clear();
}
inline ::CartesianPosition3d* PolygonalShape::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:PolygonalShape.polygon)
  return polygon_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CartesianPosition3d >*
PolygonalShape::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:PolygonalShape.polygon)
  return &polygon_;
}
inline const ::CartesianPosition3d& PolygonalShape::polygon(int index) const {
  // @@protoc_insertion_point(field_get:PolygonalShape.polygon)
  return polygon_.Get(index);
}
inline ::CartesianPosition3d* PolygonalShape::add_polygon() {
  // @@protoc_insertion_point(field_add:PolygonalShape.polygon)
  return polygon_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CartesianPosition3d >&
PolygonalShape::polygon() const {
  // @@protoc_insertion_point(field_list:PolygonalShape.polygon)
  return polygon_;
}

// optional uint32 height = 3;
inline bool PolygonalShape::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolygonalShape::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PolygonalShape::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PolygonalShape::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 PolygonalShape::height() const {
  // @@protoc_insertion_point(field_get:PolygonalShape.height)
  return height_;
}
inline void PolygonalShape::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:PolygonalShape.height)
}

// -------------------------------------------------------------------

// PositionConfidenceEllipse

// required uint32 semi_major_confidence = 1;
inline bool PositionConfidenceEllipse::has_semi_major_confidence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionConfidenceEllipse::set_has_semi_major_confidence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionConfidenceEllipse::clear_has_semi_major_confidence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionConfidenceEllipse::clear_semi_major_confidence() {
  semi_major_confidence_ = 0u;
  clear_has_semi_major_confidence();
}
inline ::google::protobuf::uint32 PositionConfidenceEllipse::semi_major_confidence() const {
  // @@protoc_insertion_point(field_get:PositionConfidenceEllipse.semi_major_confidence)
  return semi_major_confidence_;
}
inline void PositionConfidenceEllipse::set_semi_major_confidence(::google::protobuf::uint32 value) {
  set_has_semi_major_confidence();
  semi_major_confidence_ = value;
  // @@protoc_insertion_point(field_set:PositionConfidenceEllipse.semi_major_confidence)
}

// required uint32 semi_minor_confidence = 2;
inline bool PositionConfidenceEllipse::has_semi_minor_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionConfidenceEllipse::set_has_semi_minor_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionConfidenceEllipse::clear_has_semi_minor_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionConfidenceEllipse::clear_semi_minor_confidence() {
  semi_minor_confidence_ = 0u;
  clear_has_semi_minor_confidence();
}
inline ::google::protobuf::uint32 PositionConfidenceEllipse::semi_minor_confidence() const {
  // @@protoc_insertion_point(field_get:PositionConfidenceEllipse.semi_minor_confidence)
  return semi_minor_confidence_;
}
inline void PositionConfidenceEllipse::set_semi_minor_confidence(::google::protobuf::uint32 value) {
  set_has_semi_minor_confidence();
  semi_minor_confidence_ = value;
  // @@protoc_insertion_point(field_set:PositionConfidenceEllipse.semi_minor_confidence)
}

// required uint32 semi_major_orientation = 3;
inline bool PositionConfidenceEllipse::has_semi_major_orientation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionConfidenceEllipse::set_has_semi_major_orientation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionConfidenceEllipse::clear_has_semi_major_orientation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionConfidenceEllipse::clear_semi_major_orientation() {
  semi_major_orientation_ = 0u;
  clear_has_semi_major_orientation();
}
inline ::google::protobuf::uint32 PositionConfidenceEllipse::semi_major_orientation() const {
  // @@protoc_insertion_point(field_get:PositionConfidenceEllipse.semi_major_orientation)
  return semi_major_orientation_;
}
inline void PositionConfidenceEllipse::set_semi_major_orientation(::google::protobuf::uint32 value) {
  set_has_semi_major_orientation();
  semi_major_orientation_ = value;
  // @@protoc_insertion_point(field_set:PositionConfidenceEllipse.semi_major_orientation)
}

// -------------------------------------------------------------------

// RadialShape

// optional .CartesianPosition3d sharedRefPoint = 1;
inline bool RadialShape::has_sharedrefpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadialShape::set_has_sharedrefpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadialShape::clear_has_sharedrefpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadialShape::clear_sharedrefpoint() {
  if (sharedrefpoint_ != NULL) sharedrefpoint_->Clear();
  clear_has_sharedrefpoint();
}
inline const ::CartesianPosition3d& RadialShape::_internal_sharedrefpoint() const {
  return *sharedrefpoint_;
}
inline const ::CartesianPosition3d& RadialShape::sharedrefpoint() const {
  const ::CartesianPosition3d* p = sharedrefpoint_;
  // @@protoc_insertion_point(field_get:RadialShape.sharedRefPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianPosition3d*>(
      &::_CartesianPosition3d_default_instance_);
}
inline ::CartesianPosition3d* RadialShape::release_sharedrefpoint() {
  // @@protoc_insertion_point(field_release:RadialShape.sharedRefPoint)
  clear_has_sharedrefpoint();
  ::CartesianPosition3d* temp = sharedrefpoint_;
  sharedrefpoint_ = NULL;
  return temp;
}
inline ::CartesianPosition3d* RadialShape::mutable_sharedrefpoint() {
  set_has_sharedrefpoint();
  if (sharedrefpoint_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianPosition3d>(GetArenaNoVirtual());
    sharedrefpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RadialShape.sharedRefPoint)
  return sharedrefpoint_;
}
inline void RadialShape::set_allocated_sharedrefpoint(::CartesianPosition3d* sharedrefpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sharedrefpoint_;
  }
  if (sharedrefpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sharedrefpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sharedrefpoint, submessage_arena);
    }
    set_has_sharedrefpoint();
  } else {
    clear_has_sharedrefpoint();
  }
  sharedrefpoint_ = sharedrefpoint;
  // @@protoc_insertion_point(field_set_allocated:RadialShape.sharedRefPoint)
}

// required uint32 range = 2;
inline bool RadialShape::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadialShape::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadialShape::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadialShape::clear_range() {
  range_ = 0u;
  clear_has_range();
}
inline ::google::protobuf::uint32 RadialShape::range() const {
  // @@protoc_insertion_point(field_get:RadialShape.range)
  return range_;
}
inline void RadialShape::set_range(::google::protobuf::uint32 value) {
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:RadialShape.range)
}

// required uint32 stationaryHorizontalOpeningAngleStart = 3;
inline bool RadialShape::has_stationaryhorizontalopeninganglestart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadialShape::set_has_stationaryhorizontalopeninganglestart() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadialShape::clear_has_stationaryhorizontalopeninganglestart() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadialShape::clear_stationaryhorizontalopeninganglestart() {
  stationaryhorizontalopeninganglestart_ = 0u;
  clear_has_stationaryhorizontalopeninganglestart();
}
inline ::google::protobuf::uint32 RadialShape::stationaryhorizontalopeninganglestart() const {
  // @@protoc_insertion_point(field_get:RadialShape.stationaryHorizontalOpeningAngleStart)
  return stationaryhorizontalopeninganglestart_;
}
inline void RadialShape::set_stationaryhorizontalopeninganglestart(::google::protobuf::uint32 value) {
  set_has_stationaryhorizontalopeninganglestart();
  stationaryhorizontalopeninganglestart_ = value;
  // @@protoc_insertion_point(field_set:RadialShape.stationaryHorizontalOpeningAngleStart)
}

// required uint32 stationaryHorizontalOpeningAngleEnd = 4;
inline bool RadialShape::has_stationaryhorizontalopeningangleend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadialShape::set_has_stationaryhorizontalopeningangleend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadialShape::clear_has_stationaryhorizontalopeningangleend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadialShape::clear_stationaryhorizontalopeningangleend() {
  stationaryhorizontalopeningangleend_ = 0u;
  clear_has_stationaryhorizontalopeningangleend();
}
inline ::google::protobuf::uint32 RadialShape::stationaryhorizontalopeningangleend() const {
  // @@protoc_insertion_point(field_get:RadialShape.stationaryHorizontalOpeningAngleEnd)
  return stationaryhorizontalopeningangleend_;
}
inline void RadialShape::set_stationaryhorizontalopeningangleend(::google::protobuf::uint32 value) {
  set_has_stationaryhorizontalopeningangleend();
  stationaryhorizontalopeningangleend_ = value;
  // @@protoc_insertion_point(field_set:RadialShape.stationaryHorizontalOpeningAngleEnd)
}

// optional uint32 verticalOpeningAngleStart = 5;
inline bool RadialShape::has_verticalopeninganglestart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RadialShape::set_has_verticalopeninganglestart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RadialShape::clear_has_verticalopeninganglestart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RadialShape::clear_verticalopeninganglestart() {
  verticalopeninganglestart_ = 0u;
  clear_has_verticalopeninganglestart();
}
inline ::google::protobuf::uint32 RadialShape::verticalopeninganglestart() const {
  // @@protoc_insertion_point(field_get:RadialShape.verticalOpeningAngleStart)
  return verticalopeninganglestart_;
}
inline void RadialShape::set_verticalopeninganglestart(::google::protobuf::uint32 value) {
  set_has_verticalopeninganglestart();
  verticalopeninganglestart_ = value;
  // @@protoc_insertion_point(field_set:RadialShape.verticalOpeningAngleStart)
}

// optional uint32 verticalOpeningAngleEnd = 6;
inline bool RadialShape::has_verticalopeningangleend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RadialShape::set_has_verticalopeningangleend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RadialShape::clear_has_verticalopeningangleend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RadialShape::clear_verticalopeningangleend() {
  verticalopeningangleend_ = 0u;
  clear_has_verticalopeningangleend();
}
inline ::google::protobuf::uint32 RadialShape::verticalopeningangleend() const {
  // @@protoc_insertion_point(field_get:RadialShape.verticalOpeningAngleEnd)
  return verticalopeningangleend_;
}
inline void RadialShape::set_verticalopeningangleend(::google::protobuf::uint32 value) {
  set_has_verticalopeningangleend();
  verticalopeningangleend_ = value;
  // @@protoc_insertion_point(field_set:RadialShape.verticalOpeningAngleEnd)
}

// -------------------------------------------------------------------

// RadialShapes

// required uint32 refPointID = 1;
inline bool RadialShapes::has_refpointid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadialShapes::set_has_refpointid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadialShapes::clear_has_refpointid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadialShapes::clear_refpointid() {
  refpointid_ = 0u;
  clear_has_refpointid();
}
inline ::google::protobuf::uint32 RadialShapes::refpointid() const {
  // @@protoc_insertion_point(field_get:RadialShapes.refPointID)
  return refpointid_;
}
inline void RadialShapes::set_refpointid(::google::protobuf::uint32 value) {
  set_has_refpointid();
  refpointid_ = value;
  // @@protoc_insertion_point(field_set:RadialShapes.refPointID)
}

// required int32 x_cord = 2;
inline bool RadialShapes::has_x_cord() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadialShapes::set_has_x_cord() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadialShapes::clear_has_x_cord() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadialShapes::clear_x_cord() {
  x_cord_ = 0;
  clear_has_x_cord();
}
inline ::google::protobuf::int32 RadialShapes::x_cord() const {
  // @@protoc_insertion_point(field_get:RadialShapes.x_cord)
  return x_cord_;
}
inline void RadialShapes::set_x_cord(::google::protobuf::int32 value) {
  set_has_x_cord();
  x_cord_ = value;
  // @@protoc_insertion_point(field_set:RadialShapes.x_cord)
}

// required int32 y_cord = 3;
inline bool RadialShapes::has_y_cord() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadialShapes::set_has_y_cord() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadialShapes::clear_has_y_cord() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadialShapes::clear_y_cord() {
  y_cord_ = 0;
  clear_has_y_cord();
}
inline ::google::protobuf::int32 RadialShapes::y_cord() const {
  // @@protoc_insertion_point(field_get:RadialShapes.y_cord)
  return y_cord_;
}
inline void RadialShapes::set_y_cord(::google::protobuf::int32 value) {
  set_has_y_cord();
  y_cord_ = value;
  // @@protoc_insertion_point(field_set:RadialShapes.y_cord)
}

// optional int32 z_cord = 4;
inline bool RadialShapes::has_z_cord() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadialShapes::set_has_z_cord() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadialShapes::clear_has_z_cord() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadialShapes::clear_z_cord() {
  z_cord_ = 0;
  clear_has_z_cord();
}
inline ::google::protobuf::int32 RadialShapes::z_cord() const {
  // @@protoc_insertion_point(field_get:RadialShapes.z_cord)
  return z_cord_;
}
inline void RadialShapes::set_z_cord(::google::protobuf::int32 value) {
  set_has_z_cord();
  z_cord_ = value;
  // @@protoc_insertion_point(field_set:RadialShapes.z_cord)
}

// repeated .RadialShapeDetails radialShapesList = 6;
inline int RadialShapes::radialshapeslist_size() const {
  return radialshapeslist_.size();
}
inline void RadialShapes::clear_radialshapeslist() {
  radialshapeslist_.Clear();
}
inline ::RadialShapeDetails* RadialShapes::mutable_radialshapeslist(int index) {
  // @@protoc_insertion_point(field_mutable:RadialShapes.radialShapesList)
  return radialshapeslist_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::RadialShapeDetails >*
RadialShapes::mutable_radialshapeslist() {
  // @@protoc_insertion_point(field_mutable_list:RadialShapes.radialShapesList)
  return &radialshapeslist_;
}
inline const ::RadialShapeDetails& RadialShapes::radialshapeslist(int index) const {
  // @@protoc_insertion_point(field_get:RadialShapes.radialShapesList)
  return radialshapeslist_.Get(index);
}
inline ::RadialShapeDetails* RadialShapes::add_radialshapeslist() {
  // @@protoc_insertion_point(field_add:RadialShapes.radialShapesList)
  return radialshapeslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RadialShapeDetails >&
RadialShapes::radialshapeslist() const {
  // @@protoc_insertion_point(field_list:RadialShapes.radialShapesList)
  return radialshapeslist_;
}

// -------------------------------------------------------------------

// RadialShapeDetails

// required int32 range = 1;
inline bool RadialShapeDetails::has_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadialShapeDetails::set_has_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadialShapeDetails::clear_has_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadialShapeDetails::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline ::google::protobuf::int32 RadialShapeDetails::range() const {
  // @@protoc_insertion_point(field_get:RadialShapeDetails.range)
  return range_;
}
inline void RadialShapeDetails::set_range(::google::protobuf::int32 value) {
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:RadialShapeDetails.range)
}

// required uint32 horizontalOpeningAngleStart = 2;
inline bool RadialShapeDetails::has_horizontalopeninganglestart() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadialShapeDetails::set_has_horizontalopeninganglestart() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadialShapeDetails::clear_has_horizontalopeninganglestart() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadialShapeDetails::clear_horizontalopeninganglestart() {
  horizontalopeninganglestart_ = 0u;
  clear_has_horizontalopeninganglestart();
}
inline ::google::protobuf::uint32 RadialShapeDetails::horizontalopeninganglestart() const {
  // @@protoc_insertion_point(field_get:RadialShapeDetails.horizontalOpeningAngleStart)
  return horizontalopeninganglestart_;
}
inline void RadialShapeDetails::set_horizontalopeninganglestart(::google::protobuf::uint32 value) {
  set_has_horizontalopeninganglestart();
  horizontalopeninganglestart_ = value;
  // @@protoc_insertion_point(field_set:RadialShapeDetails.horizontalOpeningAngleStart)
}

// required uint32 horizontalOpeningAngleEnd = 3;
inline bool RadialShapeDetails::has_horizontalopeningangleend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadialShapeDetails::set_has_horizontalopeningangleend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadialShapeDetails::clear_has_horizontalopeningangleend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadialShapeDetails::clear_horizontalopeningangleend() {
  horizontalopeningangleend_ = 0u;
  clear_has_horizontalopeningangleend();
}
inline ::google::protobuf::uint32 RadialShapeDetails::horizontalopeningangleend() const {
  // @@protoc_insertion_point(field_get:RadialShapeDetails.horizontalOpeningAngleEnd)
  return horizontalopeningangleend_;
}
inline void RadialShapeDetails::set_horizontalopeningangleend(::google::protobuf::uint32 value) {
  set_has_horizontalopeningangleend();
  horizontalopeningangleend_ = value;
  // @@protoc_insertion_point(field_set:RadialShapeDetails.horizontalOpeningAngleEnd)
}

// optional uint32 verticalOpeningAngleStart = 4;
inline bool RadialShapeDetails::has_verticalopeninganglestart() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadialShapeDetails::set_has_verticalopeninganglestart() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadialShapeDetails::clear_has_verticalopeninganglestart() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadialShapeDetails::clear_verticalopeninganglestart() {
  verticalopeninganglestart_ = 0u;
  clear_has_verticalopeninganglestart();
}
inline ::google::protobuf::uint32 RadialShapeDetails::verticalopeninganglestart() const {
  // @@protoc_insertion_point(field_get:RadialShapeDetails.verticalOpeningAngleStart)
  return verticalopeninganglestart_;
}
inline void RadialShapeDetails::set_verticalopeninganglestart(::google::protobuf::uint32 value) {
  set_has_verticalopeninganglestart();
  verticalopeninganglestart_ = value;
  // @@protoc_insertion_point(field_set:RadialShapeDetails.verticalOpeningAngleStart)
}

// optional uint32 verticalOpeningAngleEnd = 5;
inline bool RadialShapeDetails::has_verticalopeningangleend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RadialShapeDetails::set_has_verticalopeningangleend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RadialShapeDetails::clear_has_verticalopeningangleend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RadialShapeDetails::clear_verticalopeningangleend() {
  verticalopeningangleend_ = 0u;
  clear_has_verticalopeningangleend();
}
inline ::google::protobuf::uint32 RadialShapeDetails::verticalopeningangleend() const {
  // @@protoc_insertion_point(field_get:RadialShapeDetails.verticalOpeningAngleEnd)
  return verticalopeningangleend_;
}
inline void RadialShapeDetails::set_verticalopeningangleend(::google::protobuf::uint32 value) {
  set_has_verticalopeningangleend();
  verticalopeningangleend_ = value;
  // @@protoc_insertion_point(field_set:RadialShapeDetails.verticalOpeningAngleEnd)
}

// -------------------------------------------------------------------

// RectangularShape

// optional .CartesianPosition3d center_point = 1;
inline bool RectangularShape::has_center_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RectangularShape::set_has_center_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RectangularShape::clear_has_center_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RectangularShape::clear_center_point() {
  if (center_point_ != NULL) center_point_->Clear();
  clear_has_center_point();
}
inline const ::CartesianPosition3d& RectangularShape::_internal_center_point() const {
  return *center_point_;
}
inline const ::CartesianPosition3d& RectangularShape::center_point() const {
  const ::CartesianPosition3d* p = center_point_;
  // @@protoc_insertion_point(field_get:RectangularShape.center_point)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianPosition3d*>(
      &::_CartesianPosition3d_default_instance_);
}
inline ::CartesianPosition3d* RectangularShape::release_center_point() {
  // @@protoc_insertion_point(field_release:RectangularShape.center_point)
  clear_has_center_point();
  ::CartesianPosition3d* temp = center_point_;
  center_point_ = NULL;
  return temp;
}
inline ::CartesianPosition3d* RectangularShape::mutable_center_point() {
  set_has_center_point();
  if (center_point_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianPosition3d>(GetArenaNoVirtual());
    center_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RectangularShape.center_point)
  return center_point_;
}
inline void RectangularShape::set_allocated_center_point(::CartesianPosition3d* center_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_point_;
  }
  if (center_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center_point, submessage_arena);
    }
    set_has_center_point();
  } else {
    clear_has_center_point();
  }
  center_point_ = center_point;
  // @@protoc_insertion_point(field_set_allocated:RectangularShape.center_point)
}

// required uint32 semiLength = 2;
inline bool RectangularShape::has_semilength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RectangularShape::set_has_semilength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RectangularShape::clear_has_semilength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RectangularShape::clear_semilength() {
  semilength_ = 0u;
  clear_has_semilength();
}
inline ::google::protobuf::uint32 RectangularShape::semilength() const {
  // @@protoc_insertion_point(field_get:RectangularShape.semiLength)
  return semilength_;
}
inline void RectangularShape::set_semilength(::google::protobuf::uint32 value) {
  set_has_semilength();
  semilength_ = value;
  // @@protoc_insertion_point(field_set:RectangularShape.semiLength)
}

// required uint32 semiBreadth = 3;
inline bool RectangularShape::has_semibreadth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RectangularShape::set_has_semibreadth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RectangularShape::clear_has_semibreadth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RectangularShape::clear_semibreadth() {
  semibreadth_ = 0u;
  clear_has_semibreadth();
}
inline ::google::protobuf::uint32 RectangularShape::semibreadth() const {
  // @@protoc_insertion_point(field_get:RectangularShape.semiBreadth)
  return semibreadth_;
}
inline void RectangularShape::set_semibreadth(::google::protobuf::uint32 value) {
  set_has_semibreadth();
  semibreadth_ = value;
  // @@protoc_insertion_point(field_set:RectangularShape.semiBreadth)
}

// optional uint32 orientation = 4;
inline bool RectangularShape::has_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RectangularShape::set_has_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RectangularShape::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RectangularShape::clear_orientation() {
  orientation_ = 0u;
  clear_has_orientation();
}
inline ::google::protobuf::uint32 RectangularShape::orientation() const {
  // @@protoc_insertion_point(field_get:RectangularShape.orientation)
  return orientation_;
}
inline void RectangularShape::set_orientation(::google::protobuf::uint32 value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:RectangularShape.orientation)
}

// optional uint32 height = 5;
inline bool RectangularShape::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RectangularShape::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RectangularShape::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RectangularShape::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 RectangularShape::height() const {
  // @@protoc_insertion_point(field_get:RectangularShape.height)
  return height_;
}
inline void RectangularShape::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:RectangularShape.height)
}

// -------------------------------------------------------------------

// ReferenceDenms

// repeated .ActionID action_IDs = 1;
inline int ReferenceDenms::action_ids_size() const {
  return action_ids_.size();
}
inline void ReferenceDenms::clear_action_ids() {
  action_ids_.Clear();
}
inline ::ActionID* ReferenceDenms::mutable_action_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ReferenceDenms.action_IDs)
  return action_ids_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ActionID >*
ReferenceDenms::mutable_action_ids() {
  // @@protoc_insertion_point(field_mutable_list:ReferenceDenms.action_IDs)
  return &action_ids_;
}
inline const ::ActionID& ReferenceDenms::action_ids(int index) const {
  // @@protoc_insertion_point(field_get:ReferenceDenms.action_IDs)
  return action_ids_.Get(index);
}
inline ::ActionID* ReferenceDenms::add_action_ids() {
  // @@protoc_insertion_point(field_add:ReferenceDenms.action_IDs)
  return action_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ActionID >&
ReferenceDenms::action_ids() const {
  // @@protoc_insertion_point(field_list:ReferenceDenms.action_IDs)
  return action_ids_;
}

// -------------------------------------------------------------------

// ReferencePosition

// required int64 latitude = 1;
inline bool ReferencePosition::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReferencePosition::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReferencePosition::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReferencePosition::clear_latitude() {
  latitude_ = GOOGLE_LONGLONG(0);
  clear_has_latitude();
}
inline ::google::protobuf::int64 ReferencePosition::latitude() const {
  // @@protoc_insertion_point(field_get:ReferencePosition.latitude)
  return latitude_;
}
inline void ReferencePosition::set_latitude(::google::protobuf::int64 value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:ReferencePosition.latitude)
}

// required int64 longitude = 2;
inline bool ReferencePosition::has_longitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReferencePosition::set_has_longitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReferencePosition::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReferencePosition::clear_longitude() {
  longitude_ = GOOGLE_LONGLONG(0);
  clear_has_longitude();
}
inline ::google::protobuf::int64 ReferencePosition::longitude() const {
  // @@protoc_insertion_point(field_get:ReferencePosition.longitude)
  return longitude_;
}
inline void ReferencePosition::set_longitude(::google::protobuf::int64 value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:ReferencePosition.longitude)
}

// required .PositionConfidenceEllipse position_confidence = 3;
inline bool ReferencePosition::has_position_confidence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferencePosition::set_has_position_confidence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferencePosition::clear_has_position_confidence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferencePosition::clear_position_confidence() {
  if (position_confidence_ != NULL) position_confidence_->Clear();
  clear_has_position_confidence();
}
inline const ::PositionConfidenceEllipse& ReferencePosition::_internal_position_confidence() const {
  return *position_confidence_;
}
inline const ::PositionConfidenceEllipse& ReferencePosition::position_confidence() const {
  const ::PositionConfidenceEllipse* p = position_confidence_;
  // @@protoc_insertion_point(field_get:ReferencePosition.position_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::PositionConfidenceEllipse*>(
      &::_PositionConfidenceEllipse_default_instance_);
}
inline ::PositionConfidenceEllipse* ReferencePosition::release_position_confidence() {
  // @@protoc_insertion_point(field_release:ReferencePosition.position_confidence)
  clear_has_position_confidence();
  ::PositionConfidenceEllipse* temp = position_confidence_;
  position_confidence_ = NULL;
  return temp;
}
inline ::PositionConfidenceEllipse* ReferencePosition::mutable_position_confidence() {
  set_has_position_confidence();
  if (position_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::PositionConfidenceEllipse>(GetArenaNoVirtual());
    position_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ReferencePosition.position_confidence)
  return position_confidence_;
}
inline void ReferencePosition::set_allocated_position_confidence(::PositionConfidenceEllipse* position_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_confidence_;
  }
  if (position_confidence) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_confidence, submessage_arena);
    }
    set_has_position_confidence();
  } else {
    clear_has_position_confidence();
  }
  position_confidence_ = position_confidence;
  // @@protoc_insertion_point(field_set_allocated:ReferencePosition.position_confidence)
}

// required .Altitude altitude = 4;
inline bool ReferencePosition::has_altitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferencePosition::set_has_altitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferencePosition::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferencePosition::clear_altitude() {
  if (altitude_ != NULL) altitude_->Clear();
  clear_has_altitude();
}
inline const ::Altitude& ReferencePosition::_internal_altitude() const {
  return *altitude_;
}
inline const ::Altitude& ReferencePosition::altitude() const {
  const ::Altitude* p = altitude_;
  // @@protoc_insertion_point(field_get:ReferencePosition.altitude)
  return p != NULL ? *p : *reinterpret_cast<const ::Altitude*>(
      &::_Altitude_default_instance_);
}
inline ::Altitude* ReferencePosition::release_altitude() {
  // @@protoc_insertion_point(field_release:ReferencePosition.altitude)
  clear_has_altitude();
  ::Altitude* temp = altitude_;
  altitude_ = NULL;
  return temp;
}
inline ::Altitude* ReferencePosition::mutable_altitude() {
  set_has_altitude();
  if (altitude_ == NULL) {
    auto* p = CreateMaybeMessage<::Altitude>(GetArenaNoVirtual());
    altitude_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ReferencePosition.altitude)
  return altitude_;
}
inline void ReferencePosition::set_allocated_altitude(::Altitude* altitude) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete altitude_;
  }
  if (altitude) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      altitude = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, altitude, submessage_arena);
    }
    set_has_altitude();
  } else {
    clear_has_altitude();
  }
  altitude_ = altitude;
  // @@protoc_insertion_point(field_set_allocated:ReferencePosition.altitude)
}

// -------------------------------------------------------------------

// RestrictedTypes

// repeated .StationType restricted_vehicles = 1;
inline int RestrictedTypes::restricted_vehicles_size() const {
  return restricted_vehicles_.size();
}
inline void RestrictedTypes::clear_restricted_vehicles() {
  restricted_vehicles_.Clear();
}
inline ::StationType RestrictedTypes::restricted_vehicles(int index) const {
  // @@protoc_insertion_point(field_get:RestrictedTypes.restricted_vehicles)
  return static_cast< ::StationType >(restricted_vehicles_.Get(index));
}
inline void RestrictedTypes::set_restricted_vehicles(int index, ::StationType value) {
  assert(::StationType_IsValid(value));
  restricted_vehicles_.Set(index, value);
  // @@protoc_insertion_point(field_set:RestrictedTypes.restricted_vehicles)
}
inline void RestrictedTypes::add_restricted_vehicles(::StationType value) {
  assert(::StationType_IsValid(value));
  restricted_vehicles_.Add(value);
  // @@protoc_insertion_point(field_add:RestrictedTypes.restricted_vehicles)
}
inline const ::google::protobuf::RepeatedField<int>&
RestrictedTypes::restricted_vehicles() const {
  // @@protoc_insertion_point(field_list:RestrictedTypes.restricted_vehicles)
  return restricted_vehicles_;
}
inline ::google::protobuf::RepeatedField<int>*
RestrictedTypes::mutable_restricted_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:RestrictedTypes.restricted_vehicles)
  return &restricted_vehicles_;
}

// -------------------------------------------------------------------

// RoadSegmentReferenceID

// optional int64 region = 1;
inline bool RoadSegmentReferenceID::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadSegmentReferenceID::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadSegmentReferenceID::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadSegmentReferenceID::clear_region() {
  region_ = GOOGLE_LONGLONG(0);
  clear_has_region();
}
inline ::google::protobuf::int64 RoadSegmentReferenceID::region() const {
  // @@protoc_insertion_point(field_get:RoadSegmentReferenceID.region)
  return region_;
}
inline void RoadSegmentReferenceID::set_region(::google::protobuf::int64 value) {
  set_has_region();
  region_ = value;
  // @@protoc_insertion_point(field_set:RoadSegmentReferenceID.region)
}

// required int64 id = 2;
inline bool RoadSegmentReferenceID::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadSegmentReferenceID::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadSegmentReferenceID::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadSegmentReferenceID::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 RoadSegmentReferenceID::id() const {
  // @@protoc_insertion_point(field_get:RoadSegmentReferenceID.id)
  return id_;
}
inline void RoadSegmentReferenceID::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:RoadSegmentReferenceID.id)
}

// -------------------------------------------------------------------

// Shape

// optional .RectangularShape rectangular = 1;
inline bool Shape::has_rectangular() const {
  return shape_case() == kRectangular;
}
inline void Shape::set_has_rectangular() {
  _oneof_case_[0] = kRectangular;
}
inline void Shape::clear_rectangular() {
  if (has_rectangular()) {
    delete shape_.rectangular_;
    clear_has_shape();
  }
}
inline const ::RectangularShape& Shape::_internal_rectangular() const {
  return *shape_.rectangular_;
}
inline ::RectangularShape* Shape::release_rectangular() {
  // @@protoc_insertion_point(field_release:Shape.rectangular)
  if (has_rectangular()) {
    clear_has_shape();
      ::RectangularShape* temp = shape_.rectangular_;
    shape_.rectangular_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RectangularShape& Shape::rectangular() const {
  // @@protoc_insertion_point(field_get:Shape.rectangular)
  return has_rectangular()
      ? *shape_.rectangular_
      : *reinterpret_cast< ::RectangularShape*>(&::_RectangularShape_default_instance_);
}
inline ::RectangularShape* Shape::mutable_rectangular() {
  if (!has_rectangular()) {
    clear_shape();
    set_has_rectangular();
    shape_.rectangular_ = CreateMaybeMessage< ::RectangularShape >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Shape.rectangular)
  return shape_.rectangular_;
}

// optional .CircularShape circular = 2;
inline bool Shape::has_circular() const {
  return shape_case() == kCircular;
}
inline void Shape::set_has_circular() {
  _oneof_case_[0] = kCircular;
}
inline void Shape::clear_circular() {
  if (has_circular()) {
    delete shape_.circular_;
    clear_has_shape();
  }
}
inline const ::CircularShape& Shape::_internal_circular() const {
  return *shape_.circular_;
}
inline ::CircularShape* Shape::release_circular() {
  // @@protoc_insertion_point(field_release:Shape.circular)
  if (has_circular()) {
    clear_has_shape();
      ::CircularShape* temp = shape_.circular_;
    shape_.circular_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::CircularShape& Shape::circular() const {
  // @@protoc_insertion_point(field_get:Shape.circular)
  return has_circular()
      ? *shape_.circular_
      : *reinterpret_cast< ::CircularShape*>(&::_CircularShape_default_instance_);
}
inline ::CircularShape* Shape::mutable_circular() {
  if (!has_circular()) {
    clear_shape();
    set_has_circular();
    shape_.circular_ = CreateMaybeMessage< ::CircularShape >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Shape.circular)
  return shape_.circular_;
}

// optional .PolygonalShape polygonal = 3;
inline bool Shape::has_polygonal() const {
  return shape_case() == kPolygonal;
}
inline void Shape::set_has_polygonal() {
  _oneof_case_[0] = kPolygonal;
}
inline void Shape::clear_polygonal() {
  if (has_polygonal()) {
    delete shape_.polygonal_;
    clear_has_shape();
  }
}
inline const ::PolygonalShape& Shape::_internal_polygonal() const {
  return *shape_.polygonal_;
}
inline ::PolygonalShape* Shape::release_polygonal() {
  // @@protoc_insertion_point(field_release:Shape.polygonal)
  if (has_polygonal()) {
    clear_has_shape();
      ::PolygonalShape* temp = shape_.polygonal_;
    shape_.polygonal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::PolygonalShape& Shape::polygonal() const {
  // @@protoc_insertion_point(field_get:Shape.polygonal)
  return has_polygonal()
      ? *shape_.polygonal_
      : *reinterpret_cast< ::PolygonalShape*>(&::_PolygonalShape_default_instance_);
}
inline ::PolygonalShape* Shape::mutable_polygonal() {
  if (!has_polygonal()) {
    clear_shape();
    set_has_polygonal();
    shape_.polygonal_ = CreateMaybeMessage< ::PolygonalShape >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Shape.polygonal)
  return shape_.polygonal_;
}

// optional .EllipticalShape elliptical = 4;
inline bool Shape::has_elliptical() const {
  return shape_case() == kElliptical;
}
inline void Shape::set_has_elliptical() {
  _oneof_case_[0] = kElliptical;
}
inline void Shape::clear_elliptical() {
  if (has_elliptical()) {
    delete shape_.elliptical_;
    clear_has_shape();
  }
}
inline const ::EllipticalShape& Shape::_internal_elliptical() const {
  return *shape_.elliptical_;
}
inline ::EllipticalShape* Shape::release_elliptical() {
  // @@protoc_insertion_point(field_release:Shape.elliptical)
  if (has_elliptical()) {
    clear_has_shape();
      ::EllipticalShape* temp = shape_.elliptical_;
    shape_.elliptical_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::EllipticalShape& Shape::elliptical() const {
  // @@protoc_insertion_point(field_get:Shape.elliptical)
  return has_elliptical()
      ? *shape_.elliptical_
      : *reinterpret_cast< ::EllipticalShape*>(&::_EllipticalShape_default_instance_);
}
inline ::EllipticalShape* Shape::mutable_elliptical() {
  if (!has_elliptical()) {
    clear_shape();
    set_has_elliptical();
    shape_.elliptical_ = CreateMaybeMessage< ::EllipticalShape >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Shape.elliptical)
  return shape_.elliptical_;
}

// optional .RadialShape radial = 5;
inline bool Shape::has_radial() const {
  return shape_case() == kRadial;
}
inline void Shape::set_has_radial() {
  _oneof_case_[0] = kRadial;
}
inline void Shape::clear_radial() {
  if (has_radial()) {
    delete shape_.radial_;
    clear_has_shape();
  }
}
inline const ::RadialShape& Shape::_internal_radial() const {
  return *shape_.radial_;
}
inline ::RadialShape* Shape::release_radial() {
  // @@protoc_insertion_point(field_release:Shape.radial)
  if (has_radial()) {
    clear_has_shape();
      ::RadialShape* temp = shape_.radial_;
    shape_.radial_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RadialShape& Shape::radial() const {
  // @@protoc_insertion_point(field_get:Shape.radial)
  return has_radial()
      ? *shape_.radial_
      : *reinterpret_cast< ::RadialShape*>(&::_RadialShape_default_instance_);
}
inline ::RadialShape* Shape::mutable_radial() {
  if (!has_radial()) {
    clear_shape();
    set_has_radial();
    shape_.radial_ = CreateMaybeMessage< ::RadialShape >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Shape.radial)
  return shape_.radial_;
}

// optional .RadialShapes radialShapes = 6;
inline bool Shape::has_radialshapes() const {
  return shape_case() == kRadialShapes;
}
inline void Shape::set_has_radialshapes() {
  _oneof_case_[0] = kRadialShapes;
}
inline void Shape::clear_radialshapes() {
  if (has_radialshapes()) {
    delete shape_.radialshapes_;
    clear_has_shape();
  }
}
inline const ::RadialShapes& Shape::_internal_radialshapes() const {
  return *shape_.radialshapes_;
}
inline ::RadialShapes* Shape::release_radialshapes() {
  // @@protoc_insertion_point(field_release:Shape.radialShapes)
  if (has_radialshapes()) {
    clear_has_shape();
      ::RadialShapes* temp = shape_.radialshapes_;
    shape_.radialshapes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RadialShapes& Shape::radialshapes() const {
  // @@protoc_insertion_point(field_get:Shape.radialShapes)
  return has_radialshapes()
      ? *shape_.radialshapes_
      : *reinterpret_cast< ::RadialShapes*>(&::_RadialShapes_default_instance_);
}
inline ::RadialShapes* Shape::mutable_radialshapes() {
  if (!has_radialshapes()) {
    clear_shape();
    set_has_radialshapes();
    shape_.radialshapes_ = CreateMaybeMessage< ::RadialShapes >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Shape.radialShapes)
  return shape_.radialshapes_;
}

inline bool Shape::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void Shape::clear_has_shape() {
  _oneof_case_[0] = SHAPE_NOT_SET;
}
inline Shape::ShapeCase Shape::shape_case() const {
  return Shape::ShapeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Speed

// required int32 value = 1;
inline bool Speed::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Speed::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Speed::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Speed::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Speed::value() const {
  // @@protoc_insertion_point(field_get:Speed.value)
  return value_;
}
inline void Speed::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:Speed.value)
}

// required uint32 confidence = 2;
inline bool Speed::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Speed::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Speed::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Speed::clear_confidence() {
  confidence_ = 0u;
  clear_has_confidence();
}
inline ::google::protobuf::uint32 Speed::confidence() const {
  // @@protoc_insertion_point(field_get:Speed.confidence)
  return confidence_;
}
inline void Speed::set_confidence(::google::protobuf::uint32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:Speed.confidence)
}

// -------------------------------------------------------------------

// VehicleIdentification

// optional string WMInumber = 1;
inline bool VehicleIdentification::has_wminumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleIdentification::set_has_wminumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleIdentification::clear_has_wminumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleIdentification::clear_wminumber() {
  wminumber_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wminumber();
}
inline const ::std::string& VehicleIdentification::wminumber() const {
  // @@protoc_insertion_point(field_get:VehicleIdentification.WMInumber)
  return wminumber_.GetNoArena();
}
inline void VehicleIdentification::set_wminumber(const ::std::string& value) {
  set_has_wminumber();
  wminumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:VehicleIdentification.WMInumber)
}
#if LANG_CXX11
inline void VehicleIdentification::set_wminumber(::std::string&& value) {
  set_has_wminumber();
  wminumber_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:VehicleIdentification.WMInumber)
}
#endif
inline void VehicleIdentification::set_wminumber(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_wminumber();
  wminumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:VehicleIdentification.WMInumber)
}
inline void VehicleIdentification::set_wminumber(const char* value, size_t size) {
  set_has_wminumber();
  wminumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:VehicleIdentification.WMInumber)
}
inline ::std::string* VehicleIdentification::mutable_wminumber() {
  set_has_wminumber();
  // @@protoc_insertion_point(field_mutable:VehicleIdentification.WMInumber)
  return wminumber_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleIdentification::release_wminumber() {
  // @@protoc_insertion_point(field_release:VehicleIdentification.WMInumber)
  if (!has_wminumber()) {
    return NULL;
  }
  clear_has_wminumber();
  return wminumber_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleIdentification::set_allocated_wminumber(::std::string* wminumber) {
  if (wminumber != NULL) {
    set_has_wminumber();
  } else {
    clear_has_wminumber();
  }
  wminumber_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wminumber);
  // @@protoc_insertion_point(field_set_allocated:VehicleIdentification.WMInumber)
}

// optional string VDS = 2;
inline bool VehicleIdentification::has_vds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleIdentification::set_has_vds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleIdentification::clear_has_vds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleIdentification::clear_vds() {
  vds_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vds();
}
inline const ::std::string& VehicleIdentification::vds() const {
  // @@protoc_insertion_point(field_get:VehicleIdentification.VDS)
  return vds_.GetNoArena();
}
inline void VehicleIdentification::set_vds(const ::std::string& value) {
  set_has_vds();
  vds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:VehicleIdentification.VDS)
}
#if LANG_CXX11
inline void VehicleIdentification::set_vds(::std::string&& value) {
  set_has_vds();
  vds_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:VehicleIdentification.VDS)
}
#endif
inline void VehicleIdentification::set_vds(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vds();
  vds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:VehicleIdentification.VDS)
}
inline void VehicleIdentification::set_vds(const char* value, size_t size) {
  set_has_vds();
  vds_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:VehicleIdentification.VDS)
}
inline ::std::string* VehicleIdentification::mutable_vds() {
  set_has_vds();
  // @@protoc_insertion_point(field_mutable:VehicleIdentification.VDS)
  return vds_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleIdentification::release_vds() {
  // @@protoc_insertion_point(field_release:VehicleIdentification.VDS)
  if (!has_vds()) {
    return NULL;
  }
  clear_has_vds();
  return vds_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleIdentification::set_allocated_vds(::std::string* vds) {
  if (vds != NULL) {
    set_has_vds();
  } else {
    clear_has_vds();
  }
  vds_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vds);
  // @@protoc_insertion_point(field_set_allocated:VehicleIdentification.VDS)
}

// -------------------------------------------------------------------

// VehicleLength

// required int32 value = 1;
inline bool VehicleLength::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleLength::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleLength::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleLength::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 VehicleLength::value() const {
  // @@protoc_insertion_point(field_get:VehicleLength.value)
  return value_;
}
inline void VehicleLength::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:VehicleLength.value)
}

// optional .VehicleLengthConfidenceIndication veh_len_conf_ind = 2;
inline bool VehicleLength::has_veh_len_conf_ind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleLength::set_has_veh_len_conf_ind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleLength::clear_has_veh_len_conf_ind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleLength::clear_veh_len_conf_ind() {
  veh_len_conf_ind_ = 0;
  clear_has_veh_len_conf_ind();
}
inline ::VehicleLengthConfidenceIndication VehicleLength::veh_len_conf_ind() const {
  // @@protoc_insertion_point(field_get:VehicleLength.veh_len_conf_ind)
  return static_cast< ::VehicleLengthConfidenceIndication >(veh_len_conf_ind_);
}
inline void VehicleLength::set_veh_len_conf_ind(::VehicleLengthConfidenceIndication value) {
  assert(::VehicleLengthConfidenceIndication_IsValid(value));
  set_has_veh_len_conf_ind();
  veh_len_conf_ind_ = value;
  // @@protoc_insertion_point(field_set:VehicleLength.veh_len_conf_ind)
}

// -------------------------------------------------------------------

// VehicleWidth

// required int32 value = 1;
inline bool VehicleWidth::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleWidth::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleWidth::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleWidth::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 VehicleWidth::value() const {
  // @@protoc_insertion_point(field_get:VehicleWidth.value)
  return value_;
}
inline void VehicleWidth::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:VehicleWidth.value)
}

// -------------------------------------------------------------------

// VelocityCartesian

// required .VelocityComponent xVelocity = 1;
inline bool VelocityCartesian::has_xvelocity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VelocityCartesian::set_has_xvelocity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VelocityCartesian::clear_has_xvelocity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VelocityCartesian::clear_xvelocity() {
  if (xvelocity_ != NULL) xvelocity_->Clear();
  clear_has_xvelocity();
}
inline const ::VelocityComponent& VelocityCartesian::_internal_xvelocity() const {
  return *xvelocity_;
}
inline const ::VelocityComponent& VelocityCartesian::xvelocity() const {
  const ::VelocityComponent* p = xvelocity_;
  // @@protoc_insertion_point(field_get:VelocityCartesian.xVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::VelocityComponent*>(
      &::_VelocityComponent_default_instance_);
}
inline ::VelocityComponent* VelocityCartesian::release_xvelocity() {
  // @@protoc_insertion_point(field_release:VelocityCartesian.xVelocity)
  clear_has_xvelocity();
  ::VelocityComponent* temp = xvelocity_;
  xvelocity_ = NULL;
  return temp;
}
inline ::VelocityComponent* VelocityCartesian::mutable_xvelocity() {
  set_has_xvelocity();
  if (xvelocity_ == NULL) {
    auto* p = CreateMaybeMessage<::VelocityComponent>(GetArenaNoVirtual());
    xvelocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:VelocityCartesian.xVelocity)
  return xvelocity_;
}
inline void VelocityCartesian::set_allocated_xvelocity(::VelocityComponent* xvelocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete xvelocity_;
  }
  if (xvelocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      xvelocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xvelocity, submessage_arena);
    }
    set_has_xvelocity();
  } else {
    clear_has_xvelocity();
  }
  xvelocity_ = xvelocity;
  // @@protoc_insertion_point(field_set_allocated:VelocityCartesian.xVelocity)
}

// required .VelocityComponent yVelocity = 2;
inline bool VelocityCartesian::has_yvelocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VelocityCartesian::set_has_yvelocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VelocityCartesian::clear_has_yvelocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VelocityCartesian::clear_yvelocity() {
  if (yvelocity_ != NULL) yvelocity_->Clear();
  clear_has_yvelocity();
}
inline const ::VelocityComponent& VelocityCartesian::_internal_yvelocity() const {
  return *yvelocity_;
}
inline const ::VelocityComponent& VelocityCartesian::yvelocity() const {
  const ::VelocityComponent* p = yvelocity_;
  // @@protoc_insertion_point(field_get:VelocityCartesian.yVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::VelocityComponent*>(
      &::_VelocityComponent_default_instance_);
}
inline ::VelocityComponent* VelocityCartesian::release_yvelocity() {
  // @@protoc_insertion_point(field_release:VelocityCartesian.yVelocity)
  clear_has_yvelocity();
  ::VelocityComponent* temp = yvelocity_;
  yvelocity_ = NULL;
  return temp;
}
inline ::VelocityComponent* VelocityCartesian::mutable_yvelocity() {
  set_has_yvelocity();
  if (yvelocity_ == NULL) {
    auto* p = CreateMaybeMessage<::VelocityComponent>(GetArenaNoVirtual());
    yvelocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:VelocityCartesian.yVelocity)
  return yvelocity_;
}
inline void VelocityCartesian::set_allocated_yvelocity(::VelocityComponent* yvelocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete yvelocity_;
  }
  if (yvelocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yvelocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yvelocity, submessage_arena);
    }
    set_has_yvelocity();
  } else {
    clear_has_yvelocity();
  }
  yvelocity_ = yvelocity;
  // @@protoc_insertion_point(field_set_allocated:VelocityCartesian.yVelocity)
}

// optional .VelocityComponent zVelocity = 3;
inline bool VelocityCartesian::has_zvelocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VelocityCartesian::set_has_zvelocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VelocityCartesian::clear_has_zvelocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VelocityCartesian::clear_zvelocity() {
  if (zvelocity_ != NULL) zvelocity_->Clear();
  clear_has_zvelocity();
}
inline const ::VelocityComponent& VelocityCartesian::_internal_zvelocity() const {
  return *zvelocity_;
}
inline const ::VelocityComponent& VelocityCartesian::zvelocity() const {
  const ::VelocityComponent* p = zvelocity_;
  // @@protoc_insertion_point(field_get:VelocityCartesian.zVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::VelocityComponent*>(
      &::_VelocityComponent_default_instance_);
}
inline ::VelocityComponent* VelocityCartesian::release_zvelocity() {
  // @@protoc_insertion_point(field_release:VelocityCartesian.zVelocity)
  clear_has_zvelocity();
  ::VelocityComponent* temp = zvelocity_;
  zvelocity_ = NULL;
  return temp;
}
inline ::VelocityComponent* VelocityCartesian::mutable_zvelocity() {
  set_has_zvelocity();
  if (zvelocity_ == NULL) {
    auto* p = CreateMaybeMessage<::VelocityComponent>(GetArenaNoVirtual());
    zvelocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:VelocityCartesian.zVelocity)
  return zvelocity_;
}
inline void VelocityCartesian::set_allocated_zvelocity(::VelocityComponent* zvelocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zvelocity_;
  }
  if (zvelocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zvelocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zvelocity, submessage_arena);
    }
    set_has_zvelocity();
  } else {
    clear_has_zvelocity();
  }
  zvelocity_ = zvelocity;
  // @@protoc_insertion_point(field_set_allocated:VelocityCartesian.zVelocity)
}

// -------------------------------------------------------------------

// VelocityComponent

// required int32 vel_comp_value = 1;
inline bool VelocityComponent::has_vel_comp_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VelocityComponent::set_has_vel_comp_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VelocityComponent::clear_has_vel_comp_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VelocityComponent::clear_vel_comp_value() {
  vel_comp_value_ = 0;
  clear_has_vel_comp_value();
}
inline ::google::protobuf::int32 VelocityComponent::vel_comp_value() const {
  // @@protoc_insertion_point(field_get:VelocityComponent.vel_comp_value)
  return vel_comp_value_;
}
inline void VelocityComponent::set_vel_comp_value(::google::protobuf::int32 value) {
  set_has_vel_comp_value();
  vel_comp_value_ = value;
  // @@protoc_insertion_point(field_set:VelocityComponent.vel_comp_value)
}

// required uint32 speed_confidence = 2;
inline bool VelocityComponent::has_speed_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VelocityComponent::set_has_speed_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VelocityComponent::clear_has_speed_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VelocityComponent::clear_speed_confidence() {
  speed_confidence_ = 0u;
  clear_has_speed_confidence();
}
inline ::google::protobuf::uint32 VelocityComponent::speed_confidence() const {
  // @@protoc_insertion_point(field_get:VelocityComponent.speed_confidence)
  return speed_confidence_;
}
inline void VelocityComponent::set_speed_confidence(::google::protobuf::uint32 value) {
  set_has_speed_confidence();
  speed_confidence_ = value;
  // @@protoc_insertion_point(field_set:VelocityComponent.speed_confidence)
}

// -------------------------------------------------------------------

// VelocityPolarWithZ

// required .Speed velocityMagnitude = 1;
inline bool VelocityPolarWithZ::has_velocitymagnitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VelocityPolarWithZ::set_has_velocitymagnitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VelocityPolarWithZ::clear_has_velocitymagnitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VelocityPolarWithZ::clear_velocitymagnitude() {
  if (velocitymagnitude_ != NULL) velocitymagnitude_->Clear();
  clear_has_velocitymagnitude();
}
inline const ::Speed& VelocityPolarWithZ::_internal_velocitymagnitude() const {
  return *velocitymagnitude_;
}
inline const ::Speed& VelocityPolarWithZ::velocitymagnitude() const {
  const ::Speed* p = velocitymagnitude_;
  // @@protoc_insertion_point(field_get:VelocityPolarWithZ.velocityMagnitude)
  return p != NULL ? *p : *reinterpret_cast<const ::Speed*>(
      &::_Speed_default_instance_);
}
inline ::Speed* VelocityPolarWithZ::release_velocitymagnitude() {
  // @@protoc_insertion_point(field_release:VelocityPolarWithZ.velocityMagnitude)
  clear_has_velocitymagnitude();
  ::Speed* temp = velocitymagnitude_;
  velocitymagnitude_ = NULL;
  return temp;
}
inline ::Speed* VelocityPolarWithZ::mutable_velocitymagnitude() {
  set_has_velocitymagnitude();
  if (velocitymagnitude_ == NULL) {
    auto* p = CreateMaybeMessage<::Speed>(GetArenaNoVirtual());
    velocitymagnitude_ = p;
  }
  // @@protoc_insertion_point(field_mutable:VelocityPolarWithZ.velocityMagnitude)
  return velocitymagnitude_;
}
inline void VelocityPolarWithZ::set_allocated_velocitymagnitude(::Speed* velocitymagnitude) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocitymagnitude_;
  }
  if (velocitymagnitude) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocitymagnitude = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocitymagnitude, submessage_arena);
    }
    set_has_velocitymagnitude();
  } else {
    clear_has_velocitymagnitude();
  }
  velocitymagnitude_ = velocitymagnitude;
  // @@protoc_insertion_point(field_set_allocated:VelocityPolarWithZ.velocityMagnitude)
}

// required .CartesianAngle velocityDirection = 2;
inline bool VelocityPolarWithZ::has_velocitydirection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VelocityPolarWithZ::set_has_velocitydirection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VelocityPolarWithZ::clear_has_velocitydirection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VelocityPolarWithZ::clear_velocitydirection() {
  if (velocitydirection_ != NULL) velocitydirection_->Clear();
  clear_has_velocitydirection();
}
inline const ::CartesianAngle& VelocityPolarWithZ::_internal_velocitydirection() const {
  return *velocitydirection_;
}
inline const ::CartesianAngle& VelocityPolarWithZ::velocitydirection() const {
  const ::CartesianAngle* p = velocitydirection_;
  // @@protoc_insertion_point(field_get:VelocityPolarWithZ.velocityDirection)
  return p != NULL ? *p : *reinterpret_cast<const ::CartesianAngle*>(
      &::_CartesianAngle_default_instance_);
}
inline ::CartesianAngle* VelocityPolarWithZ::release_velocitydirection() {
  // @@protoc_insertion_point(field_release:VelocityPolarWithZ.velocityDirection)
  clear_has_velocitydirection();
  ::CartesianAngle* temp = velocitydirection_;
  velocitydirection_ = NULL;
  return temp;
}
inline ::CartesianAngle* VelocityPolarWithZ::mutable_velocitydirection() {
  set_has_velocitydirection();
  if (velocitydirection_ == NULL) {
    auto* p = CreateMaybeMessage<::CartesianAngle>(GetArenaNoVirtual());
    velocitydirection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:VelocityPolarWithZ.velocityDirection)
  return velocitydirection_;
}
inline void VelocityPolarWithZ::set_allocated_velocitydirection(::CartesianAngle* velocitydirection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocitydirection_;
  }
  if (velocitydirection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocitydirection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocitydirection, submessage_arena);
    }
    set_has_velocitydirection();
  } else {
    clear_has_velocitydirection();
  }
  velocitydirection_ = velocitydirection;
  // @@protoc_insertion_point(field_set_allocated:VelocityPolarWithZ.velocityDirection)
}

// optional .VelocityComponent zVelocity = 3;
inline bool VelocityPolarWithZ::has_zvelocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VelocityPolarWithZ::set_has_zvelocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VelocityPolarWithZ::clear_has_zvelocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VelocityPolarWithZ::clear_zvelocity() {
  if (zvelocity_ != NULL) zvelocity_->Clear();
  clear_has_zvelocity();
}
inline const ::VelocityComponent& VelocityPolarWithZ::_internal_zvelocity() const {
  return *zvelocity_;
}
inline const ::VelocityComponent& VelocityPolarWithZ::zvelocity() const {
  const ::VelocityComponent* p = zvelocity_;
  // @@protoc_insertion_point(field_get:VelocityPolarWithZ.zVelocity)
  return p != NULL ? *p : *reinterpret_cast<const ::VelocityComponent*>(
      &::_VelocityComponent_default_instance_);
}
inline ::VelocityComponent* VelocityPolarWithZ::release_zvelocity() {
  // @@protoc_insertion_point(field_release:VelocityPolarWithZ.zVelocity)
  clear_has_zvelocity();
  ::VelocityComponent* temp = zvelocity_;
  zvelocity_ = NULL;
  return temp;
}
inline ::VelocityComponent* VelocityPolarWithZ::mutable_zvelocity() {
  set_has_zvelocity();
  if (zvelocity_ == NULL) {
    auto* p = CreateMaybeMessage<::VelocityComponent>(GetArenaNoVirtual());
    zvelocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:VelocityPolarWithZ.zVelocity)
  return zvelocity_;
}
inline void VelocityPolarWithZ::set_allocated_zvelocity(::VelocityComponent* zvelocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete zvelocity_;
  }
  if (zvelocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zvelocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zvelocity, submessage_arena);
    }
    set_has_zvelocity();
  } else {
    clear_has_zvelocity();
  }
  zvelocity_ = zvelocity;
  // @@protoc_insertion_point(field_set_allocated:VelocityPolarWithZ.zVelocity)
}

// -------------------------------------------------------------------

// Velocity3dWithConfidence

// optional .VelocityPolarWithZ polarVelocity = 1;
inline bool Velocity3dWithConfidence::has_polarvelocity() const {
  return velocity_case() == kPolarVelocity;
}
inline void Velocity3dWithConfidence::set_has_polarvelocity() {
  _oneof_case_[0] = kPolarVelocity;
}
inline void Velocity3dWithConfidence::clear_polarvelocity() {
  if (has_polarvelocity()) {
    delete velocity_.polarvelocity_;
    clear_has_velocity();
  }
}
inline const ::VelocityPolarWithZ& Velocity3dWithConfidence::_internal_polarvelocity() const {
  return *velocity_.polarvelocity_;
}
inline ::VelocityPolarWithZ* Velocity3dWithConfidence::release_polarvelocity() {
  // @@protoc_insertion_point(field_release:Velocity3dWithConfidence.polarVelocity)
  if (has_polarvelocity()) {
    clear_has_velocity();
      ::VelocityPolarWithZ* temp = velocity_.polarvelocity_;
    velocity_.polarvelocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::VelocityPolarWithZ& Velocity3dWithConfidence::polarvelocity() const {
  // @@protoc_insertion_point(field_get:Velocity3dWithConfidence.polarVelocity)
  return has_polarvelocity()
      ? *velocity_.polarvelocity_
      : *reinterpret_cast< ::VelocityPolarWithZ*>(&::_VelocityPolarWithZ_default_instance_);
}
inline ::VelocityPolarWithZ* Velocity3dWithConfidence::mutable_polarvelocity() {
  if (!has_polarvelocity()) {
    clear_velocity();
    set_has_polarvelocity();
    velocity_.polarvelocity_ = CreateMaybeMessage< ::VelocityPolarWithZ >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Velocity3dWithConfidence.polarVelocity)
  return velocity_.polarvelocity_;
}

// optional .VelocityCartesian cartesianVelocity = 2;
inline bool Velocity3dWithConfidence::has_cartesianvelocity() const {
  return velocity_case() == kCartesianVelocity;
}
inline void Velocity3dWithConfidence::set_has_cartesianvelocity() {
  _oneof_case_[0] = kCartesianVelocity;
}
inline void Velocity3dWithConfidence::clear_cartesianvelocity() {
  if (has_cartesianvelocity()) {
    delete velocity_.cartesianvelocity_;
    clear_has_velocity();
  }
}
inline const ::VelocityCartesian& Velocity3dWithConfidence::_internal_cartesianvelocity() const {
  return *velocity_.cartesianvelocity_;
}
inline ::VelocityCartesian* Velocity3dWithConfidence::release_cartesianvelocity() {
  // @@protoc_insertion_point(field_release:Velocity3dWithConfidence.cartesianVelocity)
  if (has_cartesianvelocity()) {
    clear_has_velocity();
      ::VelocityCartesian* temp = velocity_.cartesianvelocity_;
    velocity_.cartesianvelocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::VelocityCartesian& Velocity3dWithConfidence::cartesianvelocity() const {
  // @@protoc_insertion_point(field_get:Velocity3dWithConfidence.cartesianVelocity)
  return has_cartesianvelocity()
      ? *velocity_.cartesianvelocity_
      : *reinterpret_cast< ::VelocityCartesian*>(&::_VelocityCartesian_default_instance_);
}
inline ::VelocityCartesian* Velocity3dWithConfidence::mutable_cartesianvelocity() {
  if (!has_cartesianvelocity()) {
    clear_velocity();
    set_has_cartesianvelocity();
    velocity_.cartesianvelocity_ = CreateMaybeMessage< ::VelocityCartesian >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Velocity3dWithConfidence.cartesianVelocity)
  return velocity_.cartesianvelocity_;
}

inline bool Velocity3dWithConfidence::has_velocity() const {
  return velocity_case() != VELOCITY_NOT_SET;
}
inline void Velocity3dWithConfidence::clear_has_velocity() {
  _oneof_case_[0] = VELOCITY_NOT_SET;
}
inline Velocity3dWithConfidence::VelocityCase Velocity3dWithConfidence::velocity_case() const {
  return Velocity3dWithConfidence::VelocityCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VruClusterInformation

// optional uint32 clusterId = 1;
inline bool VruClusterInformation::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VruClusterInformation::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VruClusterInformation::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VruClusterInformation::clear_clusterid() {
  clusterid_ = 0u;
  clear_has_clusterid();
}
inline ::google::protobuf::uint32 VruClusterInformation::clusterid() const {
  // @@protoc_insertion_point(field_get:VruClusterInformation.clusterId)
  return clusterid_;
}
inline void VruClusterInformation::set_clusterid(::google::protobuf::uint32 value) {
  set_has_clusterid();
  clusterid_ = value;
  // @@protoc_insertion_point(field_set:VruClusterInformation.clusterId)
}

// optional .Shape clusterBoundingBoxShape = 2;
inline bool VruClusterInformation::has_clusterboundingboxshape() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VruClusterInformation::set_has_clusterboundingboxshape() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VruClusterInformation::clear_has_clusterboundingboxshape() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VruClusterInformation::clear_clusterboundingboxshape() {
  if (clusterboundingboxshape_ != NULL) clusterboundingboxshape_->Clear();
  clear_has_clusterboundingboxshape();
}
inline const ::Shape& VruClusterInformation::_internal_clusterboundingboxshape() const {
  return *clusterboundingboxshape_;
}
inline const ::Shape& VruClusterInformation::clusterboundingboxshape() const {
  const ::Shape* p = clusterboundingboxshape_;
  // @@protoc_insertion_point(field_get:VruClusterInformation.clusterBoundingBoxShape)
  return p != NULL ? *p : *reinterpret_cast<const ::Shape*>(
      &::_Shape_default_instance_);
}
inline ::Shape* VruClusterInformation::release_clusterboundingboxshape() {
  // @@protoc_insertion_point(field_release:VruClusterInformation.clusterBoundingBoxShape)
  clear_has_clusterboundingboxshape();
  ::Shape* temp = clusterboundingboxshape_;
  clusterboundingboxshape_ = NULL;
  return temp;
}
inline ::Shape* VruClusterInformation::mutable_clusterboundingboxshape() {
  set_has_clusterboundingboxshape();
  if (clusterboundingboxshape_ == NULL) {
    auto* p = CreateMaybeMessage<::Shape>(GetArenaNoVirtual());
    clusterboundingboxshape_ = p;
  }
  // @@protoc_insertion_point(field_mutable:VruClusterInformation.clusterBoundingBoxShape)
  return clusterboundingboxshape_;
}
inline void VruClusterInformation::set_allocated_clusterboundingboxshape(::Shape* clusterboundingboxshape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete clusterboundingboxshape_;
  }
  if (clusterboundingboxshape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      clusterboundingboxshape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, clusterboundingboxshape, submessage_arena);
    }
    set_has_clusterboundingboxshape();
  } else {
    clear_has_clusterboundingboxshape();
  }
  clusterboundingboxshape_ = clusterboundingboxshape;
  // @@protoc_insertion_point(field_set_allocated:VruClusterInformation.clusterBoundingBoxShape)
}

// required uint32 clusterCardinalitySize = 3;
inline bool VruClusterInformation::has_clustercardinalitysize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VruClusterInformation::set_has_clustercardinalitysize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VruClusterInformation::clear_has_clustercardinalitysize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VruClusterInformation::clear_clustercardinalitysize() {
  clustercardinalitysize_ = 0u;
  clear_has_clustercardinalitysize();
}
inline ::google::protobuf::uint32 VruClusterInformation::clustercardinalitysize() const {
  // @@protoc_insertion_point(field_get:VruClusterInformation.clusterCardinalitySize)
  return clustercardinalitysize_;
}
inline void VruClusterInformation::set_clustercardinalitysize(::google::protobuf::uint32 value) {
  set_has_clustercardinalitysize();
  clustercardinalitysize_ = value;
  // @@protoc_insertion_point(field_set:VruClusterInformation.clusterCardinalitySize)
}

// optional .VruClusterProfiles clusterProfiles = 4;
inline bool VruClusterInformation::has_clusterprofiles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VruClusterInformation::set_has_clusterprofiles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VruClusterInformation::clear_has_clusterprofiles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VruClusterInformation::clear_clusterprofiles() {
  if (clusterprofiles_ != NULL) clusterprofiles_->Clear();
  clear_has_clusterprofiles();
}
inline const ::VruClusterProfiles& VruClusterInformation::_internal_clusterprofiles() const {
  return *clusterprofiles_;
}
inline const ::VruClusterProfiles& VruClusterInformation::clusterprofiles() const {
  const ::VruClusterProfiles* p = clusterprofiles_;
  // @@protoc_insertion_point(field_get:VruClusterInformation.clusterProfiles)
  return p != NULL ? *p : *reinterpret_cast<const ::VruClusterProfiles*>(
      &::_VruClusterProfiles_default_instance_);
}
inline ::VruClusterProfiles* VruClusterInformation::release_clusterprofiles() {
  // @@protoc_insertion_point(field_release:VruClusterInformation.clusterProfiles)
  clear_has_clusterprofiles();
  ::VruClusterProfiles* temp = clusterprofiles_;
  clusterprofiles_ = NULL;
  return temp;
}
inline ::VruClusterProfiles* VruClusterInformation::mutable_clusterprofiles() {
  set_has_clusterprofiles();
  if (clusterprofiles_ == NULL) {
    auto* p = CreateMaybeMessage<::VruClusterProfiles>(GetArenaNoVirtual());
    clusterprofiles_ = p;
  }
  // @@protoc_insertion_point(field_mutable:VruClusterInformation.clusterProfiles)
  return clusterprofiles_;
}
inline void VruClusterInformation::set_allocated_clusterprofiles(::VruClusterProfiles* clusterprofiles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete clusterprofiles_;
  }
  if (clusterprofiles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      clusterprofiles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, clusterprofiles, submessage_arena);
    }
    set_has_clusterprofiles();
  } else {
    clear_has_clusterprofiles();
  }
  clusterprofiles_ = clusterprofiles;
  // @@protoc_insertion_point(field_set_allocated:VruClusterInformation.clusterProfiles)
}

// -------------------------------------------------------------------

// VruClusterProfiles

// required bool pedestrian = 1;
inline bool VruClusterProfiles::has_pedestrian() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VruClusterProfiles::set_has_pedestrian() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VruClusterProfiles::clear_has_pedestrian() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VruClusterProfiles::clear_pedestrian() {
  pedestrian_ = false;
  clear_has_pedestrian();
}
inline bool VruClusterProfiles::pedestrian() const {
  // @@protoc_insertion_point(field_get:VruClusterProfiles.pedestrian)
  return pedestrian_;
}
inline void VruClusterProfiles::set_pedestrian(bool value) {
  set_has_pedestrian();
  pedestrian_ = value;
  // @@protoc_insertion_point(field_set:VruClusterProfiles.pedestrian)
}

// required bool bicyclist = 2;
inline bool VruClusterProfiles::has_bicyclist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VruClusterProfiles::set_has_bicyclist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VruClusterProfiles::clear_has_bicyclist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VruClusterProfiles::clear_bicyclist() {
  bicyclist_ = false;
  clear_has_bicyclist();
}
inline bool VruClusterProfiles::bicyclist() const {
  // @@protoc_insertion_point(field_get:VruClusterProfiles.bicyclist)
  return bicyclist_;
}
inline void VruClusterProfiles::set_bicyclist(bool value) {
  set_has_bicyclist();
  bicyclist_ = value;
  // @@protoc_insertion_point(field_set:VruClusterProfiles.bicyclist)
}

// required bool motorcyclist = 3;
inline bool VruClusterProfiles::has_motorcyclist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VruClusterProfiles::set_has_motorcyclist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VruClusterProfiles::clear_has_motorcyclist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VruClusterProfiles::clear_motorcyclist() {
  motorcyclist_ = false;
  clear_has_motorcyclist();
}
inline bool VruClusterProfiles::motorcyclist() const {
  // @@protoc_insertion_point(field_get:VruClusterProfiles.motorcyclist)
  return motorcyclist_;
}
inline void VruClusterProfiles::set_motorcyclist(bool value) {
  set_has_motorcyclist();
  motorcyclist_ = value;
  // @@protoc_insertion_point(field_set:VruClusterProfiles.motorcyclist)
}

// required bool animal = 4;
inline bool VruClusterProfiles::has_animal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VruClusterProfiles::set_has_animal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VruClusterProfiles::clear_has_animal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VruClusterProfiles::clear_animal() {
  animal_ = false;
  clear_has_animal();
}
inline bool VruClusterProfiles::animal() const {
  // @@protoc_insertion_point(field_get:VruClusterProfiles.animal)
  return animal_;
}
inline void VruClusterProfiles::set_animal(bool value) {
  set_has_animal();
  animal_ = value;
  // @@protoc_insertion_point(field_set:VruClusterProfiles.animal)
}

// -------------------------------------------------------------------

// VruProfileAndSubprofile

// optional .VruSubProfilePedestrian pedestrian = 1;
inline bool VruProfileAndSubprofile::has_pedestrian() const {
  return vru_case() == kPedestrian;
}
inline void VruProfileAndSubprofile::set_has_pedestrian() {
  _oneof_case_[0] = kPedestrian;
}
inline void VruProfileAndSubprofile::clear_pedestrian() {
  if (has_pedestrian()) {
    vru_.pedestrian_ = 0;
    clear_has_vru();
  }
}
inline ::VruSubProfilePedestrian VruProfileAndSubprofile::pedestrian() const {
  // @@protoc_insertion_point(field_get:VruProfileAndSubprofile.pedestrian)
  if (has_pedestrian()) {
    return static_cast< ::VruSubProfilePedestrian >(vru_.pedestrian_);
  }
  return static_cast< ::VruSubProfilePedestrian >(0);
}
inline void VruProfileAndSubprofile::set_pedestrian(::VruSubProfilePedestrian value) {
  assert(::VruSubProfilePedestrian_IsValid(value));
  if (!has_pedestrian()) {
    clear_vru();
    set_has_pedestrian();
  }
  vru_.pedestrian_ = value;
  // @@protoc_insertion_point(field_set:VruProfileAndSubprofile.pedestrian)
}

// optional .VruSubProfileBicyclist bicyclistAndLightVruVehicle = 2;
inline bool VruProfileAndSubprofile::has_bicyclistandlightvruvehicle() const {
  return vru_case() == kBicyclistAndLightVruVehicle;
}
inline void VruProfileAndSubprofile::set_has_bicyclistandlightvruvehicle() {
  _oneof_case_[0] = kBicyclistAndLightVruVehicle;
}
inline void VruProfileAndSubprofile::clear_bicyclistandlightvruvehicle() {
  if (has_bicyclistandlightvruvehicle()) {
    vru_.bicyclistandlightvruvehicle_ = 0;
    clear_has_vru();
  }
}
inline ::VruSubProfileBicyclist VruProfileAndSubprofile::bicyclistandlightvruvehicle() const {
  // @@protoc_insertion_point(field_get:VruProfileAndSubprofile.bicyclistAndLightVruVehicle)
  if (has_bicyclistandlightvruvehicle()) {
    return static_cast< ::VruSubProfileBicyclist >(vru_.bicyclistandlightvruvehicle_);
  }
  return static_cast< ::VruSubProfileBicyclist >(0);
}
inline void VruProfileAndSubprofile::set_bicyclistandlightvruvehicle(::VruSubProfileBicyclist value) {
  assert(::VruSubProfileBicyclist_IsValid(value));
  if (!has_bicyclistandlightvruvehicle()) {
    clear_vru();
    set_has_bicyclistandlightvruvehicle();
  }
  vru_.bicyclistandlightvruvehicle_ = value;
  // @@protoc_insertion_point(field_set:VruProfileAndSubprofile.bicyclistAndLightVruVehicle)
}

// optional .VruSubProfileMotorcyclist motorcyclist = 3;
inline bool VruProfileAndSubprofile::has_motorcyclist() const {
  return vru_case() == kMotorcyclist;
}
inline void VruProfileAndSubprofile::set_has_motorcyclist() {
  _oneof_case_[0] = kMotorcyclist;
}
inline void VruProfileAndSubprofile::clear_motorcyclist() {
  if (has_motorcyclist()) {
    vru_.motorcyclist_ = 0;
    clear_has_vru();
  }
}
inline ::VruSubProfileMotorcyclist VruProfileAndSubprofile::motorcyclist() const {
  // @@protoc_insertion_point(field_get:VruProfileAndSubprofile.motorcyclist)
  if (has_motorcyclist()) {
    return static_cast< ::VruSubProfileMotorcyclist >(vru_.motorcyclist_);
  }
  return static_cast< ::VruSubProfileMotorcyclist >(0);
}
inline void VruProfileAndSubprofile::set_motorcyclist(::VruSubProfileMotorcyclist value) {
  assert(::VruSubProfileMotorcyclist_IsValid(value));
  if (!has_motorcyclist()) {
    clear_vru();
    set_has_motorcyclist();
  }
  vru_.motorcyclist_ = value;
  // @@protoc_insertion_point(field_set:VruProfileAndSubprofile.motorcyclist)
}

// optional .VruSubProfileAnimal animal = 4;
inline bool VruProfileAndSubprofile::has_animal() const {
  return vru_case() == kAnimal;
}
inline void VruProfileAndSubprofile::set_has_animal() {
  _oneof_case_[0] = kAnimal;
}
inline void VruProfileAndSubprofile::clear_animal() {
  if (has_animal()) {
    vru_.animal_ = 0;
    clear_has_vru();
  }
}
inline ::VruSubProfileAnimal VruProfileAndSubprofile::animal() const {
  // @@protoc_insertion_point(field_get:VruProfileAndSubprofile.animal)
  if (has_animal()) {
    return static_cast< ::VruSubProfileAnimal >(vru_.animal_);
  }
  return static_cast< ::VruSubProfileAnimal >(0);
}
inline void VruProfileAndSubprofile::set_animal(::VruSubProfileAnimal value) {
  assert(::VruSubProfileAnimal_IsValid(value));
  if (!has_animal()) {
    clear_vru();
    set_has_animal();
  }
  vru_.animal_ = value;
  // @@protoc_insertion_point(field_set:VruProfileAndSubprofile.animal)
}

inline bool VruProfileAndSubprofile::has_vru() const {
  return vru_case() != VRU_NOT_SET;
}
inline void VruProfileAndSubprofile::clear_has_vru() {
  _oneof_case_[0] = VRU_NOT_SET;
}
inline VruProfileAndSubprofile::VruCase VruProfileAndSubprofile::vru_case() const {
  return VruProfileAndSubprofile::VruCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Wgs84Angle

// required uint32 wgsAngleValue = 1;
inline bool Wgs84Angle::has_wgsanglevalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Wgs84Angle::set_has_wgsanglevalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Wgs84Angle::clear_has_wgsanglevalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Wgs84Angle::clear_wgsanglevalue() {
  wgsanglevalue_ = 0u;
  clear_has_wgsanglevalue();
}
inline ::google::protobuf::uint32 Wgs84Angle::wgsanglevalue() const {
  // @@protoc_insertion_point(field_get:Wgs84Angle.wgsAngleValue)
  return wgsanglevalue_;
}
inline void Wgs84Angle::set_wgsanglevalue(::google::protobuf::uint32 value) {
  set_has_wgsanglevalue();
  wgsanglevalue_ = value;
  // @@protoc_insertion_point(field_set:Wgs84Angle.wgsAngleValue)
}

// required uint32 wgs84AngleConfidence = 2;
inline bool Wgs84Angle::has_wgs84angleconfidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Wgs84Angle::set_has_wgs84angleconfidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Wgs84Angle::clear_has_wgs84angleconfidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Wgs84Angle::clear_wgs84angleconfidence() {
  wgs84angleconfidence_ = 0u;
  clear_has_wgs84angleconfidence();
}
inline ::google::protobuf::uint32 Wgs84Angle::wgs84angleconfidence() const {
  // @@protoc_insertion_point(field_get:Wgs84Angle.wgs84AngleConfidence)
  return wgs84angleconfidence_;
}
inline void Wgs84Angle::set_wgs84angleconfidence(::google::protobuf::uint32 value) {
  set_has_wgs84angleconfidence();
  wgs84angleconfidence_ = value;
  // @@protoc_insertion_point(field_set:Wgs84Angle.wgs84AngleConfidence)
}

// -------------------------------------------------------------------

// YawRate

// required int32 yawratevalue = 1;
inline bool YawRate::has_yawratevalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YawRate::set_has_yawratevalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YawRate::clear_has_yawratevalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YawRate::clear_yawratevalue() {
  yawratevalue_ = 0;
  clear_has_yawratevalue();
}
inline ::google::protobuf::int32 YawRate::yawratevalue() const {
  // @@protoc_insertion_point(field_get:YawRate.yawratevalue)
  return yawratevalue_;
}
inline void YawRate::set_yawratevalue(::google::protobuf::int32 value) {
  set_has_yawratevalue();
  yawratevalue_ = value;
  // @@protoc_insertion_point(field_set:YawRate.yawratevalue)
}

// required .YawRateConfidence yawrateconfidence = 2;
inline bool YawRate::has_yawrateconfidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YawRate::set_has_yawrateconfidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YawRate::clear_has_yawrateconfidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YawRate::clear_yawrateconfidence() {
  yawrateconfidence_ = 0;
  clear_has_yawrateconfidence();
}
inline ::YawRateConfidence YawRate::yawrateconfidence() const {
  // @@protoc_insertion_point(field_get:YawRate.yawrateconfidence)
  return static_cast< ::YawRateConfidence >(yawrateconfidence_);
}
inline void YawRate::set_yawrateconfidence(::YawRateConfidence value) {
  assert(::YawRateConfidence_IsValid(value));
  set_has_yawrateconfidence();
  yawrateconfidence_ = value;
  // @@protoc_insertion_point(field_set:YawRate.yawrateconfidence)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::AngularSpeedConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AngularSpeedConfidence>() {
  return ::AngularSpeedConfidence_descriptor();
}
template <> struct is_proto_enum< ::CurvatureCalculationMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CurvatureCalculationMode>() {
  return ::CurvatureCalculationMode_descriptor();
}
template <> struct is_proto_enum< ::CauseCodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CauseCodeType>() {
  return ::CauseCodeType_descriptor();
}
template <> struct is_proto_enum< ::DangerousGoodsBasic> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DangerousGoodsBasic>() {
  return ::DangerousGoodsBasic_descriptor();
}
template <> struct is_proto_enum< ::DriveDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DriveDirection>() {
  return ::DriveDirection_descriptor();
}
template <> struct is_proto_enum< ::HardShoulderStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HardShoulderStatus>() {
  return ::HardShoulderStatus_descriptor();
}
template <> struct is_proto_enum< ::LightBarSirenInUse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LightBarSirenInUse>() {
  return ::LightBarSirenInUse_descriptor();
}
template <> struct is_proto_enum< ::PositioningSolutionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PositioningSolutionType>() {
  return ::PositioningSolutionType_descriptor();
}
template <> struct is_proto_enum< ::PositionOfOccupants> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PositionOfOccupants>() {
  return ::PositionOfOccupants_descriptor();
}
template <> struct is_proto_enum< ::RelevanceDistance> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RelevanceDistance>() {
  return ::RelevanceDistance_descriptor();
}
template <> struct is_proto_enum< ::RelevanceTrafficDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RelevanceTrafficDirection>() {
  return ::RelevanceTrafficDirection_descriptor();
}
template <> struct is_proto_enum< ::RequestResponseIndication> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RequestResponseIndication>() {
  return ::RequestResponseIndication_descriptor();
}
template <> struct is_proto_enum< ::RoadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoadType>() {
  return ::RoadType_descriptor();
}
template <> struct is_proto_enum< ::SensorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorType>() {
  return ::SensorType_descriptor();
}
template <> struct is_proto_enum< ::StationarySince> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StationarySince>() {
  return ::StationarySince_descriptor();
}
template <> struct is_proto_enum< ::StationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StationType>() {
  return ::StationType_descriptor();
}
template <> struct is_proto_enum< ::TrafficParticipantType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrafficParticipantType>() {
  return ::TrafficParticipantType_descriptor();
}
template <> struct is_proto_enum< ::TrafficRule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrafficRule>() {
  return ::TrafficRule_descriptor();
}
template <> struct is_proto_enum< ::VehicleLengthConfidenceIndication> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VehicleLengthConfidenceIndication>() {
  return ::VehicleLengthConfidenceIndication_descriptor();
}
template <> struct is_proto_enum< ::VruSubProfilePedestrian> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VruSubProfilePedestrian>() {
  return ::VruSubProfilePedestrian_descriptor();
}
template <> struct is_proto_enum< ::VruSubProfileBicyclist> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VruSubProfileBicyclist>() {
  return ::VruSubProfileBicyclist_descriptor();
}
template <> struct is_proto_enum< ::VruSubProfileMotorcyclist> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VruSubProfileMotorcyclist>() {
  return ::VruSubProfileMotorcyclist_descriptor();
}
template <> struct is_proto_enum< ::VruSubProfileAnimal> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VruSubProfileAnimal>() {
  return ::VruSubProfileAnimal_descriptor();
}
template <> struct is_proto_enum< ::YawRateConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::YawRateConfidence>() {
  return ::YawRateConfidence_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_etsi_5fits_5fcdd_2eproto
