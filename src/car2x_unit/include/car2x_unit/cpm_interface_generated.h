// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CPMINTERFACE_H_
#define FLATBUFFERS_GENERATED_CPMINTERFACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

#include "etsi_its_cdd_generated.h"
#include "itspduheader_interface_generated.h"

struct CPMessage;
struct CPMessageBuilder;

struct CpmPayload;
struct CpmPayloadBuilder;

struct ManagmentContainer;
struct ManagmentContainerBuilder;

struct MessageRateRange;
struct MessageRateRangeBuilder;

struct OriginatingStationsContainer;
struct OriginatingStationsContainerBuilder;

struct OriginatingVehicleContainer;
struct OriginatingVehicleContainerBuilder;

struct OriginatingRSUContainer;
struct OriginatingRSUContainerBuilder;

struct SensorInformationContainer;
struct SensorInformationContainerBuilder;

struct SensorInformation;
struct SensorInformationBuilder;

struct PerceptionRegionContainer;
struct PerceptionRegionContainerBuilder;

struct PerceptionRegion;
struct PerceptionRegionBuilder;

struct PerceivedObjectContainer;
struct PerceivedObjectContainerBuilder;

struct PerceivedObject;
struct PerceivedObjectBuilder;

struct CPMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CPMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_GENERATION_DELTA_TIME = 6,
    VT_MGMT_CNTNR = 8,
    VT_CPM_PAYLOAD = 10
  };
  const ItsPduHeader *header() const {
    return GetPointer<const ItsPduHeader *>(VT_HEADER);
  }
  uint64_t generation_delta_time() const {
    return GetField<uint64_t>(VT_GENERATION_DELTA_TIME, 0);
  }
  const ManagmentContainer *mgmt_cntnr() const {
    return GetPointer<const ManagmentContainer *>(VT_MGMT_CNTNR);
  }
  const CpmPayload *cpm_payload() const {
    return GetPointer<const CpmPayload *>(VT_CPM_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint64_t>(verifier, VT_GENERATION_DELTA_TIME, 8) &&
           VerifyOffsetRequired(verifier, VT_MGMT_CNTNR) &&
           verifier.VerifyTable(mgmt_cntnr()) &&
           VerifyOffsetRequired(verifier, VT_CPM_PAYLOAD) &&
           verifier.VerifyTable(cpm_payload()) &&
           verifier.EndTable();
  }
};

struct CPMessageBuilder {
  typedef CPMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<ItsPduHeader> header) {
    fbb_.AddOffset(CPMessage::VT_HEADER, header);
  }
  void add_generation_delta_time(uint64_t generation_delta_time) {
    fbb_.AddElement<uint64_t>(CPMessage::VT_GENERATION_DELTA_TIME, generation_delta_time, 0);
  }
  void add_mgmt_cntnr(::flatbuffers::Offset<ManagmentContainer> mgmt_cntnr) {
    fbb_.AddOffset(CPMessage::VT_MGMT_CNTNR, mgmt_cntnr);
  }
  void add_cpm_payload(::flatbuffers::Offset<CpmPayload> cpm_payload) {
    fbb_.AddOffset(CPMessage::VT_CPM_PAYLOAD, cpm_payload);
  }
  explicit CPMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CPMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CPMessage>(end);
    fbb_.Required(o, CPMessage::VT_HEADER);
    fbb_.Required(o, CPMessage::VT_MGMT_CNTNR);
    fbb_.Required(o, CPMessage::VT_CPM_PAYLOAD);
    return o;
  }
};

inline ::flatbuffers::Offset<CPMessage> CreateCPMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ItsPduHeader> header = 0,
    uint64_t generation_delta_time = 0,
    ::flatbuffers::Offset<ManagmentContainer> mgmt_cntnr = 0,
    ::flatbuffers::Offset<CpmPayload> cpm_payload = 0) {
  CPMessageBuilder builder_(_fbb);
  builder_.add_generation_delta_time(generation_delta_time);
  builder_.add_cpm_payload(cpm_payload);
  builder_.add_mgmt_cntnr(mgmt_cntnr);
  builder_.add_header(header);
  return builder_.Finish();
}

struct CpmPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CpmPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORG_STN_CNTR = 4,
    VT_SNSR_INFO_CNTR = 6,
    VT_PRCPTN_RGN_CNTR = 8,
    VT_PRCVD_OBJ_CNTR = 10
  };
  const OriginatingStationsContainer *org_stn_cntr() const {
    return GetPointer<const OriginatingStationsContainer *>(VT_ORG_STN_CNTR);
  }
  const SensorInformationContainer *snsr_info_cntr() const {
    return GetPointer<const SensorInformationContainer *>(VT_SNSR_INFO_CNTR);
  }
  const PerceptionRegionContainer *prcptn_rgn_cntr() const {
    return GetPointer<const PerceptionRegionContainer *>(VT_PRCPTN_RGN_CNTR);
  }
  const PerceivedObjectContainer *prcvd_obj_cntr() const {
    return GetPointer<const PerceivedObjectContainer *>(VT_PRCVD_OBJ_CNTR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ORG_STN_CNTR) &&
           verifier.VerifyTable(org_stn_cntr()) &&
           VerifyOffsetRequired(verifier, VT_SNSR_INFO_CNTR) &&
           verifier.VerifyTable(snsr_info_cntr()) &&
           VerifyOffsetRequired(verifier, VT_PRCPTN_RGN_CNTR) &&
           verifier.VerifyTable(prcptn_rgn_cntr()) &&
           VerifyOffsetRequired(verifier, VT_PRCVD_OBJ_CNTR) &&
           verifier.VerifyTable(prcvd_obj_cntr()) &&
           verifier.EndTable();
  }
};

struct CpmPayloadBuilder {
  typedef CpmPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_org_stn_cntr(::flatbuffers::Offset<OriginatingStationsContainer> org_stn_cntr) {
    fbb_.AddOffset(CpmPayload::VT_ORG_STN_CNTR, org_stn_cntr);
  }
  void add_snsr_info_cntr(::flatbuffers::Offset<SensorInformationContainer> snsr_info_cntr) {
    fbb_.AddOffset(CpmPayload::VT_SNSR_INFO_CNTR, snsr_info_cntr);
  }
  void add_prcptn_rgn_cntr(::flatbuffers::Offset<PerceptionRegionContainer> prcptn_rgn_cntr) {
    fbb_.AddOffset(CpmPayload::VT_PRCPTN_RGN_CNTR, prcptn_rgn_cntr);
  }
  void add_prcvd_obj_cntr(::flatbuffers::Offset<PerceivedObjectContainer> prcvd_obj_cntr) {
    fbb_.AddOffset(CpmPayload::VT_PRCVD_OBJ_CNTR, prcvd_obj_cntr);
  }
  explicit CpmPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CpmPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CpmPayload>(end);
    fbb_.Required(o, CpmPayload::VT_ORG_STN_CNTR);
    fbb_.Required(o, CpmPayload::VT_SNSR_INFO_CNTR);
    fbb_.Required(o, CpmPayload::VT_PRCPTN_RGN_CNTR);
    fbb_.Required(o, CpmPayload::VT_PRCVD_OBJ_CNTR);
    return o;
  }
};

inline ::flatbuffers::Offset<CpmPayload> CreateCpmPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OriginatingStationsContainer> org_stn_cntr = 0,
    ::flatbuffers::Offset<SensorInformationContainer> snsr_info_cntr = 0,
    ::flatbuffers::Offset<PerceptionRegionContainer> prcptn_rgn_cntr = 0,
    ::flatbuffers::Offset<PerceivedObjectContainer> prcvd_obj_cntr = 0) {
  CpmPayloadBuilder builder_(_fbb);
  builder_.add_prcvd_obj_cntr(prcvd_obj_cntr);
  builder_.add_prcptn_rgn_cntr(prcptn_rgn_cntr);
  builder_.add_snsr_info_cntr(snsr_info_cntr);
  builder_.add_org_stn_cntr(org_stn_cntr);
  return builder_.Finish();
}

struct ManagmentContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ManagmentContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCETIME = 4,
    VT_REFERENCEPOSITION = 6,
    VT_SEGMENTATIONINFO = 8,
    VT_MESSAGERATERANGE = 10,
    VT_STATIONTYPE = 12
  };
  uint64_t referenceTime() const {
    return GetField<uint64_t>(VT_REFERENCETIME, 0);
  }
  const ReferencePosition *referencePosition() const {
    return GetPointer<const ReferencePosition *>(VT_REFERENCEPOSITION);
  }
  const MessageSegmentationInfo *segmentationInfo() const {
    return GetPointer<const MessageSegmentationInfo *>(VT_SEGMENTATIONINFO);
  }
  const MessageRateRange *messageRateRange() const {
    return GetPointer<const MessageRateRange *>(VT_MESSAGERATERANGE);
  }
  StationType stationtype() const {
    return static_cast<StationType>(GetField<int32_t>(VT_STATIONTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REFERENCETIME, 8) &&
           VerifyOffsetRequired(verifier, VT_REFERENCEPOSITION) &&
           verifier.VerifyTable(referencePosition()) &&
           VerifyOffset(verifier, VT_SEGMENTATIONINFO) &&
           verifier.VerifyTable(segmentationInfo()) &&
           VerifyOffset(verifier, VT_MESSAGERATERANGE) &&
           verifier.VerifyTable(messageRateRange()) &&
           VerifyField<int32_t>(verifier, VT_STATIONTYPE, 4) &&
           verifier.EndTable();
  }
};

struct ManagmentContainerBuilder {
  typedef ManagmentContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_referenceTime(uint64_t referenceTime) {
    fbb_.AddElement<uint64_t>(ManagmentContainer::VT_REFERENCETIME, referenceTime, 0);
  }
  void add_referencePosition(::flatbuffers::Offset<ReferencePosition> referencePosition) {
    fbb_.AddOffset(ManagmentContainer::VT_REFERENCEPOSITION, referencePosition);
  }
  void add_segmentationInfo(::flatbuffers::Offset<MessageSegmentationInfo> segmentationInfo) {
    fbb_.AddOffset(ManagmentContainer::VT_SEGMENTATIONINFO, segmentationInfo);
  }
  void add_messageRateRange(::flatbuffers::Offset<MessageRateRange> messageRateRange) {
    fbb_.AddOffset(ManagmentContainer::VT_MESSAGERATERANGE, messageRateRange);
  }
  void add_stationtype(StationType stationtype) {
    fbb_.AddElement<int32_t>(ManagmentContainer::VT_STATIONTYPE, static_cast<int32_t>(stationtype), 0);
  }
  explicit ManagmentContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ManagmentContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ManagmentContainer>(end);
    fbb_.Required(o, ManagmentContainer::VT_REFERENCEPOSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<ManagmentContainer> CreateManagmentContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t referenceTime = 0,
    ::flatbuffers::Offset<ReferencePosition> referencePosition = 0,
    ::flatbuffers::Offset<MessageSegmentationInfo> segmentationInfo = 0,
    ::flatbuffers::Offset<MessageRateRange> messageRateRange = 0,
    StationType stationtype = StationType_STN_TYPE_UNKNOWN) {
  ManagmentContainerBuilder builder_(_fbb);
  builder_.add_referenceTime(referenceTime);
  builder_.add_stationtype(stationtype);
  builder_.add_messageRateRange(messageRateRange);
  builder_.add_segmentationInfo(segmentationInfo);
  builder_.add_referencePosition(referencePosition);
  return builder_.Finish();
}

struct MessageRateRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageRateRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGERATEMIN = 4,
    VT_MESSAGERATEMAX = 6
  };
  const MessageRateHz *messageRateMin() const {
    return GetPointer<const MessageRateHz *>(VT_MESSAGERATEMIN);
  }
  const MessageRateHz *messageRateMax() const {
    return GetPointer<const MessageRateHz *>(VT_MESSAGERATEMAX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MESSAGERATEMIN) &&
           verifier.VerifyTable(messageRateMin()) &&
           VerifyOffsetRequired(verifier, VT_MESSAGERATEMAX) &&
           verifier.VerifyTable(messageRateMax()) &&
           verifier.EndTable();
  }
};

struct MessageRateRangeBuilder {
  typedef MessageRateRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_messageRateMin(::flatbuffers::Offset<MessageRateHz> messageRateMin) {
    fbb_.AddOffset(MessageRateRange::VT_MESSAGERATEMIN, messageRateMin);
  }
  void add_messageRateMax(::flatbuffers::Offset<MessageRateHz> messageRateMax) {
    fbb_.AddOffset(MessageRateRange::VT_MESSAGERATEMAX, messageRateMax);
  }
  explicit MessageRateRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageRateRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageRateRange>(end);
    fbb_.Required(o, MessageRateRange::VT_MESSAGERATEMIN);
    fbb_.Required(o, MessageRateRange::VT_MESSAGERATEMAX);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageRateRange> CreateMessageRateRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MessageRateHz> messageRateMin = 0,
    ::flatbuffers::Offset<MessageRateHz> messageRateMax = 0) {
  MessageRateRangeBuilder builder_(_fbb);
  builder_.add_messageRateMax(messageRateMax);
  builder_.add_messageRateMin(messageRateMin);
  return builder_.Finish();
}

struct OriginatingStationsContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OriginatingStationsContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORG_VEH_CNTR = 4,
    VT_ORG_RSU_CNTR = 6
  };
  const OriginatingVehicleContainer *org_veh_cntr() const {
    return GetPointer<const OriginatingVehicleContainer *>(VT_ORG_VEH_CNTR);
  }
  const OriginatingRSUContainer *org_rsu_cntr() const {
    return GetPointer<const OriginatingRSUContainer *>(VT_ORG_RSU_CNTR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORG_VEH_CNTR) &&
           verifier.VerifyTable(org_veh_cntr()) &&
           VerifyOffset(verifier, VT_ORG_RSU_CNTR) &&
           verifier.VerifyTable(org_rsu_cntr()) &&
           verifier.EndTable();
  }
};

struct OriginatingStationsContainerBuilder {
  typedef OriginatingStationsContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_org_veh_cntr(::flatbuffers::Offset<OriginatingVehicleContainer> org_veh_cntr) {
    fbb_.AddOffset(OriginatingStationsContainer::VT_ORG_VEH_CNTR, org_veh_cntr);
  }
  void add_org_rsu_cntr(::flatbuffers::Offset<OriginatingRSUContainer> org_rsu_cntr) {
    fbb_.AddOffset(OriginatingStationsContainer::VT_ORG_RSU_CNTR, org_rsu_cntr);
  }
  explicit OriginatingStationsContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OriginatingStationsContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OriginatingStationsContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OriginatingStationsContainer> CreateOriginatingStationsContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<OriginatingVehicleContainer> org_veh_cntr = 0,
    ::flatbuffers::Offset<OriginatingRSUContainer> org_rsu_cntr = 0) {
  OriginatingStationsContainerBuilder builder_(_fbb);
  builder_.add_org_rsu_cntr(org_rsu_cntr);
  builder_.add_org_veh_cntr(org_veh_cntr);
  return builder_.Finish();
}

struct OriginatingVehicleContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OriginatingVehicleContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIENTATIONANGLE = 4,
    VT_PITCHANGLE = 6,
    VT_ROLLANGLE = 8,
    VT_TRAILERDATASET = 10
  };
  const Wgs84Angle *orientationAngle() const {
    return GetPointer<const Wgs84Angle *>(VT_ORIENTATIONANGLE);
  }
  const CartesianAngle *pitchAngle() const {
    return GetPointer<const CartesianAngle *>(VT_PITCHANGLE);
  }
  const CartesianAngle *rollAngle() const {
    return GetPointer<const CartesianAngle *>(VT_ROLLANGLE);
  }
  int64_t trailerDataset() const {
    return GetField<int64_t>(VT_TRAILERDATASET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATIONANGLE) &&
           verifier.VerifyTable(orientationAngle()) &&
           VerifyOffset(verifier, VT_PITCHANGLE) &&
           verifier.VerifyTable(pitchAngle()) &&
           VerifyOffset(verifier, VT_ROLLANGLE) &&
           verifier.VerifyTable(rollAngle()) &&
           VerifyField<int64_t>(verifier, VT_TRAILERDATASET, 8) &&
           verifier.EndTable();
  }
};

struct OriginatingVehicleContainerBuilder {
  typedef OriginatingVehicleContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_orientationAngle(::flatbuffers::Offset<Wgs84Angle> orientationAngle) {
    fbb_.AddOffset(OriginatingVehicleContainer::VT_ORIENTATIONANGLE, orientationAngle);
  }
  void add_pitchAngle(::flatbuffers::Offset<CartesianAngle> pitchAngle) {
    fbb_.AddOffset(OriginatingVehicleContainer::VT_PITCHANGLE, pitchAngle);
  }
  void add_rollAngle(::flatbuffers::Offset<CartesianAngle> rollAngle) {
    fbb_.AddOffset(OriginatingVehicleContainer::VT_ROLLANGLE, rollAngle);
  }
  void add_trailerDataset(int64_t trailerDataset) {
    fbb_.AddElement<int64_t>(OriginatingVehicleContainer::VT_TRAILERDATASET, trailerDataset, 0);
  }
  explicit OriginatingVehicleContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OriginatingVehicleContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OriginatingVehicleContainer>(end);
    fbb_.Required(o, OriginatingVehicleContainer::VT_ORIENTATIONANGLE);
    return o;
  }
};

inline ::flatbuffers::Offset<OriginatingVehicleContainer> CreateOriginatingVehicleContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Wgs84Angle> orientationAngle = 0,
    ::flatbuffers::Offset<CartesianAngle> pitchAngle = 0,
    ::flatbuffers::Offset<CartesianAngle> rollAngle = 0,
    int64_t trailerDataset = 0) {
  OriginatingVehicleContainerBuilder builder_(_fbb);
  builder_.add_trailerDataset(trailerDataset);
  builder_.add_rollAngle(rollAngle);
  builder_.add_pitchAngle(pitchAngle);
  builder_.add_orientationAngle(orientationAngle);
  return builder_.Finish();
}

struct OriginatingRSUContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OriginatingRSUContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROADSEGMENT = 4,
    VT_INTERSECTION = 6
  };
  const RoadSegmentReferenceID *roadsegment() const {
    return GetPointer<const RoadSegmentReferenceID *>(VT_ROADSEGMENT);
  }
  const IntersectionReferenceID *intersection() const {
    return GetPointer<const IntersectionReferenceID *>(VT_INTERSECTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ROADSEGMENT) &&
           verifier.VerifyTable(roadsegment()) &&
           VerifyOffsetRequired(verifier, VT_INTERSECTION) &&
           verifier.VerifyTable(intersection()) &&
           verifier.EndTable();
  }
};

struct OriginatingRSUContainerBuilder {
  typedef OriginatingRSUContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_roadsegment(::flatbuffers::Offset<RoadSegmentReferenceID> roadsegment) {
    fbb_.AddOffset(OriginatingRSUContainer::VT_ROADSEGMENT, roadsegment);
  }
  void add_intersection(::flatbuffers::Offset<IntersectionReferenceID> intersection) {
    fbb_.AddOffset(OriginatingRSUContainer::VT_INTERSECTION, intersection);
  }
  explicit OriginatingRSUContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OriginatingRSUContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OriginatingRSUContainer>(end);
    fbb_.Required(o, OriginatingRSUContainer::VT_ROADSEGMENT);
    fbb_.Required(o, OriginatingRSUContainer::VT_INTERSECTION);
    return o;
  }
};

inline ::flatbuffers::Offset<OriginatingRSUContainer> CreateOriginatingRSUContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<RoadSegmentReferenceID> roadsegment = 0,
    ::flatbuffers::Offset<IntersectionReferenceID> intersection = 0) {
  OriginatingRSUContainerBuilder builder_(_fbb);
  builder_.add_intersection(intersection);
  builder_.add_roadsegment(roadsegment);
  return builder_.Finish();
}

struct SensorInformationContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorInformationContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SNSR_INFRMTN = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<SensorInformation>> *snsr_infrmtn() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SensorInformation>> *>(VT_SNSR_INFRMTN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SNSR_INFRMTN) &&
           verifier.VerifyVector(snsr_infrmtn()) &&
           verifier.VerifyVectorOfTables(snsr_infrmtn()) &&
           verifier.EndTable();
  }
};

struct SensorInformationContainerBuilder {
  typedef SensorInformationContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_snsr_infrmtn(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SensorInformation>>> snsr_infrmtn) {
    fbb_.AddOffset(SensorInformationContainer::VT_SNSR_INFRMTN, snsr_infrmtn);
  }
  explicit SensorInformationContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorInformationContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorInformationContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorInformationContainer> CreateSensorInformationContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SensorInformation>>> snsr_infrmtn = 0) {
  SensorInformationContainerBuilder builder_(_fbb);
  builder_.add_snsr_infrmtn(snsr_infrmtn);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SensorInformationContainer> CreateSensorInformationContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<SensorInformation>> *snsr_infrmtn = nullptr) {
  auto snsr_infrmtn__ = snsr_infrmtn ? _fbb.CreateVector<::flatbuffers::Offset<SensorInformation>>(*snsr_infrmtn) : 0;
  return CreateSensorInformationContainer(
      _fbb,
      snsr_infrmtn__);
}

struct SensorInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorInformationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSORID = 4,
    VT_SENSOR_TYPE = 6,
    VT_PERCEPTION_REGION_SHAPE = 8,
    VT_PERCEPTION_REGION_CONF = 10,
    VT_SHADOWINGAPPLIES = 12
  };
  int64_t sensorID() const {
    return GetField<int64_t>(VT_SENSORID, 0);
  }
  SensorType sensor_type() const {
    return static_cast<SensorType>(GetField<int32_t>(VT_SENSOR_TYPE, 0));
  }
  const Shape *perception_region_shape() const {
    return GetPointer<const Shape *>(VT_PERCEPTION_REGION_SHAPE);
  }
  uint32_t perception_region_conf() const {
    return GetField<uint32_t>(VT_PERCEPTION_REGION_CONF, 0);
  }
  bool shadowingapplies() const {
    return GetField<uint8_t>(VT_SHADOWINGAPPLIES, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SENSORID, 8) &&
           VerifyField<int32_t>(verifier, VT_SENSOR_TYPE, 4) &&
           VerifyOffsetRequired(verifier, VT_PERCEPTION_REGION_SHAPE) &&
           verifier.VerifyTable(perception_region_shape()) &&
           VerifyField<uint32_t>(verifier, VT_PERCEPTION_REGION_CONF, 4) &&
           VerifyField<uint8_t>(verifier, VT_SHADOWINGAPPLIES, 1) &&
           verifier.EndTable();
  }
};

struct SensorInformationBuilder {
  typedef SensorInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sensorID(int64_t sensorID) {
    fbb_.AddElement<int64_t>(SensorInformation::VT_SENSORID, sensorID, 0);
  }
  void add_sensor_type(SensorType sensor_type) {
    fbb_.AddElement<int32_t>(SensorInformation::VT_SENSOR_TYPE, static_cast<int32_t>(sensor_type), 0);
  }
  void add_perception_region_shape(::flatbuffers::Offset<Shape> perception_region_shape) {
    fbb_.AddOffset(SensorInformation::VT_PERCEPTION_REGION_SHAPE, perception_region_shape);
  }
  void add_perception_region_conf(uint32_t perception_region_conf) {
    fbb_.AddElement<uint32_t>(SensorInformation::VT_PERCEPTION_REGION_CONF, perception_region_conf, 0);
  }
  void add_shadowingapplies(bool shadowingapplies) {
    fbb_.AddElement<uint8_t>(SensorInformation::VT_SHADOWINGAPPLIES, static_cast<uint8_t>(shadowingapplies), 0);
  }
  explicit SensorInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorInformation>(end);
    fbb_.Required(o, SensorInformation::VT_PERCEPTION_REGION_SHAPE);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorInformation> CreateSensorInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sensorID = 0,
    SensorType sensor_type = SensorType_SNSR_UNDEFINED,
    ::flatbuffers::Offset<Shape> perception_region_shape = 0,
    uint32_t perception_region_conf = 0,
    bool shadowingapplies = false) {
  SensorInformationBuilder builder_(_fbb);
  builder_.add_sensorID(sensorID);
  builder_.add_perception_region_conf(perception_region_conf);
  builder_.add_perception_region_shape(perception_region_shape);
  builder_.add_sensor_type(sensor_type);
  builder_.add_shadowingapplies(shadowingapplies);
  return builder_.Finish();
}

struct PerceptionRegionContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceptionRegionContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRCPN_RGN_LIST = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PerceptionRegion>> *prcpn_rgn_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PerceptionRegion>> *>(VT_PRCPN_RGN_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PRCPN_RGN_LIST) &&
           verifier.VerifyVector(prcpn_rgn_list()) &&
           verifier.VerifyVectorOfTables(prcpn_rgn_list()) &&
           verifier.EndTable();
  }
};

struct PerceptionRegionContainerBuilder {
  typedef PerceptionRegionContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_prcpn_rgn_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PerceptionRegion>>> prcpn_rgn_list) {
    fbb_.AddOffset(PerceptionRegionContainer::VT_PRCPN_RGN_LIST, prcpn_rgn_list);
  }
  explicit PerceptionRegionContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceptionRegionContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceptionRegionContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceptionRegionContainer> CreatePerceptionRegionContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PerceptionRegion>>> prcpn_rgn_list = 0) {
  PerceptionRegionContainerBuilder builder_(_fbb);
  builder_.add_prcpn_rgn_list(prcpn_rgn_list);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceptionRegionContainer> CreatePerceptionRegionContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PerceptionRegion>> *prcpn_rgn_list = nullptr) {
  auto prcpn_rgn_list__ = prcpn_rgn_list ? _fbb.CreateVector<::flatbuffers::Offset<PerceptionRegion>>(*prcpn_rgn_list) : 0;
  return CreatePerceptionRegionContainer(
      _fbb,
      prcpn_rgn_list__);
}

struct PerceptionRegion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceptionRegionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEASUREMENTDELTATIME = 4,
    VT_PERCEPTIONREGIONCONFIDENCE = 6,
    VT_PERCEPTIONREGIONSHAPE = 8,
    VT_SHADOWINGAPPLIES = 10,
    VT_SENSORIDLIST = 12,
    VT_NUMBEROFPERCEIVEDOBJECTS = 14,
    VT_PERCEIVEDOBJECTIDS = 16
  };
  int32_t measurementDeltaTime() const {
    return GetField<int32_t>(VT_MEASUREMENTDELTATIME, 0);
  }
  uint32_t perceptionRegionConfidence() const {
    return GetField<uint32_t>(VT_PERCEPTIONREGIONCONFIDENCE, 0);
  }
  const Shape *perceptionRegionShape() const {
    return GetPointer<const Shape *>(VT_PERCEPTIONREGIONSHAPE);
  }
  bool shadowingApplies() const {
    return GetField<uint8_t>(VT_SHADOWINGAPPLIES, 0) != 0;
  }
  const ::flatbuffers::Vector<uint32_t> *sensorIdList() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_SENSORIDLIST);
  }
  uint32_t numberOfPerceivedObjects() const {
    return GetField<uint32_t>(VT_NUMBEROFPERCEIVEDOBJECTS, 0);
  }
  uint32_t perceivedObjectIds() const {
    return GetField<uint32_t>(VT_PERCEIVEDOBJECTIDS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MEASUREMENTDELTATIME, 4) &&
           VerifyField<uint32_t>(verifier, VT_PERCEPTIONREGIONCONFIDENCE, 4) &&
           VerifyOffsetRequired(verifier, VT_PERCEPTIONREGIONSHAPE) &&
           verifier.VerifyTable(perceptionRegionShape()) &&
           VerifyField<uint8_t>(verifier, VT_SHADOWINGAPPLIES, 1) &&
           VerifyOffset(verifier, VT_SENSORIDLIST) &&
           verifier.VerifyVector(sensorIdList()) &&
           VerifyField<uint32_t>(verifier, VT_NUMBEROFPERCEIVEDOBJECTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_PERCEIVEDOBJECTIDS, 4) &&
           verifier.EndTable();
  }
};

struct PerceptionRegionBuilder {
  typedef PerceptionRegion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_measurementDeltaTime(int32_t measurementDeltaTime) {
    fbb_.AddElement<int32_t>(PerceptionRegion::VT_MEASUREMENTDELTATIME, measurementDeltaTime, 0);
  }
  void add_perceptionRegionConfidence(uint32_t perceptionRegionConfidence) {
    fbb_.AddElement<uint32_t>(PerceptionRegion::VT_PERCEPTIONREGIONCONFIDENCE, perceptionRegionConfidence, 0);
  }
  void add_perceptionRegionShape(::flatbuffers::Offset<Shape> perceptionRegionShape) {
    fbb_.AddOffset(PerceptionRegion::VT_PERCEPTIONREGIONSHAPE, perceptionRegionShape);
  }
  void add_shadowingApplies(bool shadowingApplies) {
    fbb_.AddElement<uint8_t>(PerceptionRegion::VT_SHADOWINGAPPLIES, static_cast<uint8_t>(shadowingApplies), 0);
  }
  void add_sensorIdList(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> sensorIdList) {
    fbb_.AddOffset(PerceptionRegion::VT_SENSORIDLIST, sensorIdList);
  }
  void add_numberOfPerceivedObjects(uint32_t numberOfPerceivedObjects) {
    fbb_.AddElement<uint32_t>(PerceptionRegion::VT_NUMBEROFPERCEIVEDOBJECTS, numberOfPerceivedObjects, 0);
  }
  void add_perceivedObjectIds(uint32_t perceivedObjectIds) {
    fbb_.AddElement<uint32_t>(PerceptionRegion::VT_PERCEIVEDOBJECTIDS, perceivedObjectIds, 0);
  }
  explicit PerceptionRegionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceptionRegion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceptionRegion>(end);
    fbb_.Required(o, PerceptionRegion::VT_PERCEPTIONREGIONSHAPE);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceptionRegion> CreatePerceptionRegion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t measurementDeltaTime = 0,
    uint32_t perceptionRegionConfidence = 0,
    ::flatbuffers::Offset<Shape> perceptionRegionShape = 0,
    bool shadowingApplies = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> sensorIdList = 0,
    uint32_t numberOfPerceivedObjects = 0,
    uint32_t perceivedObjectIds = 0) {
  PerceptionRegionBuilder builder_(_fbb);
  builder_.add_perceivedObjectIds(perceivedObjectIds);
  builder_.add_numberOfPerceivedObjects(numberOfPerceivedObjects);
  builder_.add_sensorIdList(sensorIdList);
  builder_.add_perceptionRegionShape(perceptionRegionShape);
  builder_.add_perceptionRegionConfidence(perceptionRegionConfidence);
  builder_.add_measurementDeltaTime(measurementDeltaTime);
  builder_.add_shadowingApplies(shadowingApplies);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceptionRegion> CreatePerceptionRegionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t measurementDeltaTime = 0,
    uint32_t perceptionRegionConfidence = 0,
    ::flatbuffers::Offset<Shape> perceptionRegionShape = 0,
    bool shadowingApplies = false,
    const std::vector<uint32_t> *sensorIdList = nullptr,
    uint32_t numberOfPerceivedObjects = 0,
    uint32_t perceivedObjectIds = 0) {
  auto sensorIdList__ = sensorIdList ? _fbb.CreateVector<uint32_t>(*sensorIdList) : 0;
  return CreatePerceptionRegion(
      _fbb,
      measurementDeltaTime,
      perceptionRegionConfidence,
      perceptionRegionShape,
      shadowingApplies,
      sensorIdList__,
      numberOfPerceivedObjects,
      perceivedObjectIds);
}

struct PerceivedObjectContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceivedObjectContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBEROFPERCEIVEDOBJECTS = 4,
    VT_PERCEIVEDOBJECTS = 6
  };
  uint32_t numberOfPerceivedObjects() const {
    return GetField<uint32_t>(VT_NUMBEROFPERCEIVEDOBJECTS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<PerceivedObject>> *perceivedObjects() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PerceivedObject>> *>(VT_PERCEIVEDOBJECTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NUMBEROFPERCEIVEDOBJECTS, 4) &&
           VerifyOffset(verifier, VT_PERCEIVEDOBJECTS) &&
           verifier.VerifyVector(perceivedObjects()) &&
           verifier.VerifyVectorOfTables(perceivedObjects()) &&
           verifier.EndTable();
  }
};

struct PerceivedObjectContainerBuilder {
  typedef PerceivedObjectContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_numberOfPerceivedObjects(uint32_t numberOfPerceivedObjects) {
    fbb_.AddElement<uint32_t>(PerceivedObjectContainer::VT_NUMBEROFPERCEIVEDOBJECTS, numberOfPerceivedObjects, 0);
  }
  void add_perceivedObjects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PerceivedObject>>> perceivedObjects) {
    fbb_.AddOffset(PerceivedObjectContainer::VT_PERCEIVEDOBJECTS, perceivedObjects);
  }
  explicit PerceivedObjectContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceivedObjectContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceivedObjectContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceivedObjectContainer> CreatePerceivedObjectContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t numberOfPerceivedObjects = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PerceivedObject>>> perceivedObjects = 0) {
  PerceivedObjectContainerBuilder builder_(_fbb);
  builder_.add_perceivedObjects(perceivedObjects);
  builder_.add_numberOfPerceivedObjects(numberOfPerceivedObjects);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceivedObjectContainer> CreatePerceivedObjectContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t numberOfPerceivedObjects = 0,
    const std::vector<::flatbuffers::Offset<PerceivedObject>> *perceivedObjects = nullptr) {
  auto perceivedObjects__ = perceivedObjects ? _fbb.CreateVector<::flatbuffers::Offset<PerceivedObject>>(*perceivedObjects) : 0;
  return CreatePerceivedObjectContainer(
      _fbb,
      numberOfPerceivedObjects,
      perceivedObjects__);
}

struct PerceivedObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerceivedObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_MEASUREMENTDELTATIME = 6,
    VT_POSITION = 8,
    VT_VELOCITY = 10,
    VT_ACCELERATION = 12,
    VT_ANGLES = 14,
    VT_ZANGULARVELOCITY = 16,
    VT_LOWERTRIANGULARCORRELATIONMATRICES = 18,
    VT_OBJECTDIMENSIONZ = 20,
    VT_OBJECTDIMENSIONY = 22,
    VT_OBJECTDIMENSIONX = 24,
    VT_OBJECTAGE = 26,
    VT_OBJECTPERCEPTIONQUALITY = 28,
    VT_SENSORIDLIST = 30,
    VT_CLASSIFICATION = 32,
    VT_MAPPOSITION = 34
  };
  uint32_t objectID() const {
    return GetField<uint32_t>(VT_OBJECTID, 0);
  }
  int32_t measurementDeltaTime() const {
    return GetField<int32_t>(VT_MEASUREMENTDELTATIME, 0);
  }
  const CartesianPosition3dWithConfidence *position() const {
    return GetPointer<const CartesianPosition3dWithConfidence *>(VT_POSITION);
  }
  const Velocity3dWithConfidence *velocity() const {
    return GetPointer<const Velocity3dWithConfidence *>(VT_VELOCITY);
  }
  const Acceleration3dWithConfidence *acceleration() const {
    return GetPointer<const Acceleration3dWithConfidence *>(VT_ACCELERATION);
  }
  const EulerAnglesWithConfidence *angles() const {
    return GetPointer<const EulerAnglesWithConfidence *>(VT_ANGLES);
  }
  const CartesianAngularVelocityComponent *zAngularVelocity() const {
    return GetPointer<const CartesianAngularVelocityComponent *>(VT_ZANGULARVELOCITY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix>> *lowerTriangularCorrelationMatrices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix>> *>(VT_LOWERTRIANGULARCORRELATIONMATRICES);
  }
  const ObjectDimension *objectDimensionZ() const {
    return GetPointer<const ObjectDimension *>(VT_OBJECTDIMENSIONZ);
  }
  const ObjectDimension *objectDimensionY() const {
    return GetPointer<const ObjectDimension *>(VT_OBJECTDIMENSIONY);
  }
  const ObjectDimension *objectDimensionX() const {
    return GetPointer<const ObjectDimension *>(VT_OBJECTDIMENSIONX);
  }
  uint32_t objectAge() const {
    return GetField<uint32_t>(VT_OBJECTAGE, 0);
  }
  uint32_t objectPerceptionQuality() const {
    return GetField<uint32_t>(VT_OBJECTPERCEPTIONQUALITY, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *sensorIdList() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_SENSORIDLIST);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectClassWithConfidence>> *classification() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectClassWithConfidence>> *>(VT_CLASSIFICATION);
  }
  const MapPosition *mapPosition() const {
    return GetPointer<const MapPosition *>(VT_MAPPOSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OBJECTID, 4) &&
           VerifyField<int32_t>(verifier, VT_MEASUREMENTDELTATIME, 4) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyTable(velocity()) &&
           VerifyOffset(verifier, VT_ACCELERATION) &&
           verifier.VerifyTable(acceleration()) &&
           VerifyOffset(verifier, VT_ANGLES) &&
           verifier.VerifyTable(angles()) &&
           VerifyOffset(verifier, VT_ZANGULARVELOCITY) &&
           verifier.VerifyTable(zAngularVelocity()) &&
           VerifyOffset(verifier, VT_LOWERTRIANGULARCORRELATIONMATRICES) &&
           verifier.VerifyVector(lowerTriangularCorrelationMatrices()) &&
           verifier.VerifyVectorOfTables(lowerTriangularCorrelationMatrices()) &&
           VerifyOffset(verifier, VT_OBJECTDIMENSIONZ) &&
           verifier.VerifyTable(objectDimensionZ()) &&
           VerifyOffset(verifier, VT_OBJECTDIMENSIONY) &&
           verifier.VerifyTable(objectDimensionY()) &&
           VerifyOffset(verifier, VT_OBJECTDIMENSIONX) &&
           verifier.VerifyTable(objectDimensionX()) &&
           VerifyField<uint32_t>(verifier, VT_OBJECTAGE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OBJECTPERCEPTIONQUALITY, 4) &&
           VerifyOffset(verifier, VT_SENSORIDLIST) &&
           verifier.VerifyVector(sensorIdList()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION) &&
           verifier.VerifyVector(classification()) &&
           verifier.VerifyVectorOfTables(classification()) &&
           VerifyOffsetRequired(verifier, VT_MAPPOSITION) &&
           verifier.VerifyTable(mapPosition()) &&
           verifier.EndTable();
  }
};

struct PerceivedObjectBuilder {
  typedef PerceivedObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectID(uint32_t objectID) {
    fbb_.AddElement<uint32_t>(PerceivedObject::VT_OBJECTID, objectID, 0);
  }
  void add_measurementDeltaTime(int32_t measurementDeltaTime) {
    fbb_.AddElement<int32_t>(PerceivedObject::VT_MEASUREMENTDELTATIME, measurementDeltaTime, 0);
  }
  void add_position(::flatbuffers::Offset<CartesianPosition3dWithConfidence> position) {
    fbb_.AddOffset(PerceivedObject::VT_POSITION, position);
  }
  void add_velocity(::flatbuffers::Offset<Velocity3dWithConfidence> velocity) {
    fbb_.AddOffset(PerceivedObject::VT_VELOCITY, velocity);
  }
  void add_acceleration(::flatbuffers::Offset<Acceleration3dWithConfidence> acceleration) {
    fbb_.AddOffset(PerceivedObject::VT_ACCELERATION, acceleration);
  }
  void add_angles(::flatbuffers::Offset<EulerAnglesWithConfidence> angles) {
    fbb_.AddOffset(PerceivedObject::VT_ANGLES, angles);
  }
  void add_zAngularVelocity(::flatbuffers::Offset<CartesianAngularVelocityComponent> zAngularVelocity) {
    fbb_.AddOffset(PerceivedObject::VT_ZANGULARVELOCITY, zAngularVelocity);
  }
  void add_lowerTriangularCorrelationMatrices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix>>> lowerTriangularCorrelationMatrices) {
    fbb_.AddOffset(PerceivedObject::VT_LOWERTRIANGULARCORRELATIONMATRICES, lowerTriangularCorrelationMatrices);
  }
  void add_objectDimensionZ(::flatbuffers::Offset<ObjectDimension> objectDimensionZ) {
    fbb_.AddOffset(PerceivedObject::VT_OBJECTDIMENSIONZ, objectDimensionZ);
  }
  void add_objectDimensionY(::flatbuffers::Offset<ObjectDimension> objectDimensionY) {
    fbb_.AddOffset(PerceivedObject::VT_OBJECTDIMENSIONY, objectDimensionY);
  }
  void add_objectDimensionX(::flatbuffers::Offset<ObjectDimension> objectDimensionX) {
    fbb_.AddOffset(PerceivedObject::VT_OBJECTDIMENSIONX, objectDimensionX);
  }
  void add_objectAge(uint32_t objectAge) {
    fbb_.AddElement<uint32_t>(PerceivedObject::VT_OBJECTAGE, objectAge, 0);
  }
  void add_objectPerceptionQuality(uint32_t objectPerceptionQuality) {
    fbb_.AddElement<uint32_t>(PerceivedObject::VT_OBJECTPERCEPTIONQUALITY, objectPerceptionQuality, 0);
  }
  void add_sensorIdList(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> sensorIdList) {
    fbb_.AddOffset(PerceivedObject::VT_SENSORIDLIST, sensorIdList);
  }
  void add_classification(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectClassWithConfidence>>> classification) {
    fbb_.AddOffset(PerceivedObject::VT_CLASSIFICATION, classification);
  }
  void add_mapPosition(::flatbuffers::Offset<MapPosition> mapPosition) {
    fbb_.AddOffset(PerceivedObject::VT_MAPPOSITION, mapPosition);
  }
  explicit PerceivedObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PerceivedObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PerceivedObject>(end);
    fbb_.Required(o, PerceivedObject::VT_POSITION);
    fbb_.Required(o, PerceivedObject::VT_MAPPOSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<PerceivedObject> CreatePerceivedObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t objectID = 0,
    int32_t measurementDeltaTime = 0,
    ::flatbuffers::Offset<CartesianPosition3dWithConfidence> position = 0,
    ::flatbuffers::Offset<Velocity3dWithConfidence> velocity = 0,
    ::flatbuffers::Offset<Acceleration3dWithConfidence> acceleration = 0,
    ::flatbuffers::Offset<EulerAnglesWithConfidence> angles = 0,
    ::flatbuffers::Offset<CartesianAngularVelocityComponent> zAngularVelocity = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix>>> lowerTriangularCorrelationMatrices = 0,
    ::flatbuffers::Offset<ObjectDimension> objectDimensionZ = 0,
    ::flatbuffers::Offset<ObjectDimension> objectDimensionY = 0,
    ::flatbuffers::Offset<ObjectDimension> objectDimensionX = 0,
    uint32_t objectAge = 0,
    uint32_t objectPerceptionQuality = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> sensorIdList = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectClassWithConfidence>>> classification = 0,
    ::flatbuffers::Offset<MapPosition> mapPosition = 0) {
  PerceivedObjectBuilder builder_(_fbb);
  builder_.add_mapPosition(mapPosition);
  builder_.add_classification(classification);
  builder_.add_sensorIdList(sensorIdList);
  builder_.add_objectPerceptionQuality(objectPerceptionQuality);
  builder_.add_objectAge(objectAge);
  builder_.add_objectDimensionX(objectDimensionX);
  builder_.add_objectDimensionY(objectDimensionY);
  builder_.add_objectDimensionZ(objectDimensionZ);
  builder_.add_lowerTriangularCorrelationMatrices(lowerTriangularCorrelationMatrices);
  builder_.add_zAngularVelocity(zAngularVelocity);
  builder_.add_angles(angles);
  builder_.add_acceleration(acceleration);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  builder_.add_measurementDeltaTime(measurementDeltaTime);
  builder_.add_objectID(objectID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PerceivedObject> CreatePerceivedObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t objectID = 0,
    int32_t measurementDeltaTime = 0,
    ::flatbuffers::Offset<CartesianPosition3dWithConfidence> position = 0,
    ::flatbuffers::Offset<Velocity3dWithConfidence> velocity = 0,
    ::flatbuffers::Offset<Acceleration3dWithConfidence> acceleration = 0,
    ::flatbuffers::Offset<EulerAnglesWithConfidence> angles = 0,
    ::flatbuffers::Offset<CartesianAngularVelocityComponent> zAngularVelocity = 0,
    const std::vector<::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix>> *lowerTriangularCorrelationMatrices = nullptr,
    ::flatbuffers::Offset<ObjectDimension> objectDimensionZ = 0,
    ::flatbuffers::Offset<ObjectDimension> objectDimensionY = 0,
    ::flatbuffers::Offset<ObjectDimension> objectDimensionX = 0,
    uint32_t objectAge = 0,
    uint32_t objectPerceptionQuality = 0,
    const std::vector<uint32_t> *sensorIdList = nullptr,
    const std::vector<::flatbuffers::Offset<ObjectClassWithConfidence>> *classification = nullptr,
    ::flatbuffers::Offset<MapPosition> mapPosition = 0) {
  auto lowerTriangularCorrelationMatrices__ = lowerTriangularCorrelationMatrices ? _fbb.CreateVector<::flatbuffers::Offset<LowerTriangularPositiveSemidefiniteMatrix>>(*lowerTriangularCorrelationMatrices) : 0;
  auto sensorIdList__ = sensorIdList ? _fbb.CreateVector<uint32_t>(*sensorIdList) : 0;
  auto classification__ = classification ? _fbb.CreateVector<::flatbuffers::Offset<ObjectClassWithConfidence>>(*classification) : 0;
  return CreatePerceivedObject(
      _fbb,
      objectID,
      measurementDeltaTime,
      position,
      velocity,
      acceleration,
      angles,
      zAngularVelocity,
      lowerTriangularCorrelationMatrices__,
      objectDimensionZ,
      objectDimensionY,
      objectDimensionX,
      objectAge,
      objectPerceptionQuality,
      sensorIdList__,
      classification__,
      mapPosition);
}

#endif  // FLATBUFFERS_GENERATED_CPMINTERFACE_H_
